<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>后端搬运工</title>
  
  <subtitle>公众号：后端搬运工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.fanhaobai.com/"/>
  <updated>2024-04-24T02:45:05.707Z</updated>
  <id>https://www.fanhaobai.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现一个自定义规则引擎</title>
    <link href="https://www.fanhaobai.com/2024/04/design-rule-engine.html"/>
    <id>https://www.fanhaobai.com/2024/04/design-rule-engine.html</id>
    <published>2024-04-23T13:00:00.000Z</published>
    <updated>2024-04-24T02:45:05.707Z</updated>
    
    <content type="html"><![CDATA[<p>规则引擎的功能可以简化为当满足一些条件时触发一些操作，通常使用 DSL 自定义语法来表述。规则引擎需要先解析 DSL 语法形成语法树，然后遍历语法树得到完整的语法表达式，最后执行这些语法表达式完成规则的执行。</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/12805423-37FB-4225-91E3-EC6473BA720C.png" alt="规则引擎"><span id="more"></span></p><p>本文以 <a href="https://github.com/bilibili/gengine">gengine</a> 来探讨如何设计和实现一个自定义规则引擎。</p><h2 id="支持的语句"><a href="#支持的语句" class="headerlink" title="支持的语句"></a>支持的语句</h2><p>为了满足基本的业务规则需求，规则引擎应该要支持的语句有：</p><h3 id="逻辑与算术运算"><a href="#逻辑与算术运算" class="headerlink" title="逻辑与算术运算"></a>逻辑与算术运算</h3><ul><li>数学运算（+、-、*、/）</li><li>逻辑运算（&amp;&amp;、||、!）</li><li>比较运算（==、!=、&gt;、&lt;、&gt;=、&lt;=）</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul><li>条件（IF ELSE）</li><li>循环 (FOR)</li></ul><h3 id="高级语句"><a href="#高级语句" class="headerlink" title="高级语句"></a>高级语句</h3><ul><li>对象属性访问（对象.属性）</li><li>方法调用（func()）</li></ul><h2 id="规则语法的解析"><a href="#规则语法的解析" class="headerlink" title="规则语法的解析"></a>规则语法的解析</h2><p>规则的 DSL 语法定义应该简单明了，gengine 使用了开源的语法解析器 Antlr4 来定义和解析规则语法。</p><h3 id="定义规则语法"><a href="#定义规则语法" class="headerlink" title="定义规则语法"></a>定义规则语法</h3><p>规则的 DSL 基本语法格式如下：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;rulename&quot;</span> <span class="string">&quot;rule-describtion&quot;</span> salience  <span class="number">10</span></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则体</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中规则体为具体规则语句，由上述的 <a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E5%8F%A5">逻辑与算术运算</a>、<a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E5%8F%A5">流程控制</a>、<a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E5%8F%A5">高级语句</a> 组合而成。 </p><p>例如，<strong>判断为一个大额异常订单</strong>的规则体：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> Order.Price&gt;= <span class="number">1000000</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写解析器语法"><a href="#编写解析器语法" class="headerlink" title="编写解析器语法"></a>编写解析器语法</h3><p>Antlr4 解析器语法定义文件后缀名为<code>.g4</code>，以下内容为解析器的语法定义，解析器根据语法定义去逐行解析生成语法树。</p><p>这里省略了一些非核心的语法定义并做了简化，完整内容查看 <a href="https://github.com/howborn/blog/blob/master/source/_posts/2024/04/design-rule-engine/gengine.g4">gengine.g4</a>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">grammar gengine;</span><br><span class="line"></span><br><span class="line">primary: ruleEntity+;</span><br><span class="line"><span class="comment">// 规则定义</span></span><br><span class="line">ruleEntity:  RULE ruleName ruleDescription? salience? BEGIN ruleContent END;</span><br><span class="line">ruleName : stringLiteral;</span><br><span class="line">ruleDescription : stringLiteral;</span><br><span class="line">salience : SALIENCE integer;</span><br><span class="line"><span class="comment">// 规则体</span></span><br><span class="line">ruleContent : statements;</span><br><span class="line">statements: statement* returnStmt?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本语句</span></span><br><span class="line">statement : ifStmt | breakStmt;</span><br><span class="line"></span><br><span class="line">expression : mathExpression</span><br><span class="line">            | expression comparisonOperator expression</span><br><span class="line">            | expression logicalOperator expression</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">mathExpression : mathExpression  mathMdOperator mathExpression</span><br><span class="line">               | mathExpression  mathPmOperator mathExpression</span><br><span class="line">               | expressionAtom</span><br><span class="line">               | LR_BRACKET mathExpression RR_BRACKET</span><br><span class="line">               ;</span><br><span class="line"></span><br><span class="line">expressionAtom</span><br><span class="line">    : functionCall</span><br><span class="line">    | constant</span><br><span class="line">    | variable</span><br><span class="line">    ;</span><br><span class="line">returnStmt : RETURN expression?;</span><br><span class="line">ifStmt : IF expression LR_BRACE statements RR_BRACE elseIfStmt*  elseStmt?;</span><br><span class="line">elseStmt : ELSE LR_BRACE statements RR_BRACE;</span><br><span class="line"></span><br><span class="line">constant</span><br><span class="line">    : booleanLiteral</span><br><span class="line">    | integer</span><br><span class="line">    | stringLiteral</span><br><span class="line">    ;</span><br><span class="line">functionArgs</span><br><span class="line">    : (constant | variable  | functionCall | expression)  (<span class="string">&#x27;,&#x27;</span>(constant | variable | functionCall | expression))*</span><br><span class="line">    ;</span><br><span class="line">integer : MINUS? INT;</span><br><span class="line">stringLiteral: DQUOTA_STRING;</span><br><span class="line">booleanLiteral : TRUE | FALSE;</span><br><span class="line">functionCall : SIMPLENAME LR_BRACKET functionArgs? RR_BRACKET;</span><br><span class="line">variable :  SIMPLENAME | DOTTEDNAME;</span><br><span class="line">mathPmOperator : PLUS | MINUS;</span><br><span class="line">mathMdOperator : MUL | DIV;</span><br><span class="line">comparisonOperator : GT | LT | GTE | LTE | EQUALS | NOTEQUALS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字省略</span></span><br></pre></td></tr></table></figure><h3 id="解析器生成语法树"><a href="#解析器生成语法树" class="headerlink" title="解析器生成语法树"></a>解析器生成语法树</h3><p>如，<strong>判断为一个大额异常订单</strong>的规则：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;order-large-price&quot;</span> <span class="string">&quot;订单大额金额&quot;</span> salience <span class="number">10</span></span><br><span class="line">begin</span><br><span class="line">    <span class="keyword">if</span> Order.Price &gt;= <span class="number">1000000</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>语法解析器解析之后，生成语法树：</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/6082eaf6-9534-4989-86d6-2422a3ab54b0.png" alt="语法树"></p><h3 id="遍历语法树生成语句表达式"><a href="#遍历语法树生成语句表达式" class="headerlink" title="遍历语法树生成语句表达式"></a>遍历语法树生成语句表达式</h3><p>解析器生成语法树之后，只需要遍历语法树即可得到完整的语句表达式。 Antlr4 解析器会生成 Listener 接口，这些接口在遍历语法树时会被调用。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gengineListener <span class="keyword">interface</span> &#123;</span><br><span class="line">    antlr.ParseTreeListener</span><br><span class="line">    <span class="comment">// 省略了一些只列举了部分方法</span></span><br><span class="line">    <span class="comment">// EnterRuleEntity is called when entering the ruleEntity production.</span></span><br><span class="line">    EnterRuleEntity(c *RuleEntityContext)</span><br><span class="line">    <span class="comment">// ExitRuleEntity is called when exiting the ruleEntity production.</span></span><br><span class="line">    ExitRuleEntity(c *RuleEntityContext)</span><br><span class="line">    <span class="comment">// EnterRuleContent is called when entering the ruleContent production.</span></span><br><span class="line">    EnterRuleContent(c *RuleContentContext)</span><br><span class="line">    <span class="comment">// ExitRuleContent is called when exiting the ruleContent production.</span></span><br><span class="line">    ExitRuleContent(c *RuleContentContext)</span><br><span class="line">    <span class="comment">// EnterStatement is called when entering the statement production.</span></span><br><span class="line">    EnterStatement(c *StatementContext)</span><br><span class="line">    <span class="comment">// ExitStatement is called when exiting the statement production.</span></span><br><span class="line">    ExitStatement(c *StatementContext)</span><br><span class="line">    <span class="comment">// EnterIfStmt is called when entering the ifStmt production.</span></span><br><span class="line">    EnterIfStmt(c *IfStmtContext)</span><br><span class="line">    <span class="comment">// ExitIfStmt is called when exiting the ifStmt production.</span></span><br><span class="line">    ExitIfStmt(c *IfStmtContext)</span><br><span class="line">    <span class="comment">// EnterExpression is called when entering the expression production.</span></span><br><span class="line">    EnterExpression(c *ExpressionContext)</span><br><span class="line">    <span class="comment">// ExitExpression is called when exiting the expression production.</span></span><br><span class="line">    ExitExpression(c *ExpressionContext)</span><br><span class="line">    <span class="comment">// EnterInteger is called when entering the integer production.</span></span><br><span class="line">    EnterInteger(c *IntegerContext)</span><br><span class="line">    <span class="comment">// ExitInteger is called when exiting the integer production.</span></span><br><span class="line">    ExitInteger(c *IntegerContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在遍历语法树时，每个节点都有 EnterXXX() 和 ExitXXX() 方法存在，是成对出现的。</p><p>因此要遍历语法树只需要实现 gengineListener 接口即可，gengine 巧妙的引入<code>栈</code>结构，遍历完语法树后（树的递归遍历就是进栈出栈过程），就得到了完整的规则语句表达式。 这里只列举部分方法，完整实现见 <a href="https://github.com/bilibili/gengine/blob/main/internal/iparser/gengine_parser_listener.go">gengine_parser_listener</a>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GengineParserListener <span class="keyword">struct</span> &#123;</span><br><span class="line">    parser.BasegengineListener</span><br><span class="line"></span><br><span class="line">    KnowledgeContext *base.KnowledgeContext</span><br><span class="line">    Stack            *stack.Stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GengineParserListener)</span></span> EnterRuleEntity(ctx *parser.RuleEntityContext) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(g.ParseErrors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    entity := &amp;base.RuleEntity&#123;</span><br><span class="line">        Salience: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    g.ruleName = <span class="string">&quot;&quot;</span></span><br><span class="line">    g.ruleDescription = <span class="string">&quot;&quot;</span></span><br><span class="line">    g.salience = <span class="number">0</span></span><br><span class="line">    g.Stack.Push(entity)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GengineParserListener)</span></span> ExitRuleEntity(ctx *parser.RuleEntityContext) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(g.ParseErrors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    entity := g.Stack.Pop().(*base.RuleEntity)</span><br><span class="line">    g.KnowledgeContext.RuleEntities[entity.RuleName] = entity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gengine 通过解析器解析规则内容之后，规则的数据结构如下：</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/65ebb70a-3e2d-4e20-a1f2-227fc08c0669.png" alt="规则数据结构"></p><p>全局的 hashmap 以规则名为 key，规则体为 value，规则体中的 ruleContent 为该规则所有的语句表达式列表，列表中的值指向具体的语句表达式实体，语句表达式实体由 <strong>逻辑与算术运算</strong>、<strong>流程控制（IF、FOR）</strong>等基本语句组成。</p><h2 id="规则语法的执行"><a href="#规则语法的执行" class="headerlink" title="规则语法的执行"></a>规则语法的执行</h2><p>其实遍历语法树的过程中，将规则的执行逻辑也放入 ExitXXX() 方法，这样就能一并完成规则的解析和执行。但是 gengine 没有这么做，而是将规则的解析和执行解耦，因为规则的解析往往只需要初始化一次，或者在规则有变更时热更新解析，而规则的执行则是在需要校验规则的时候。</p><p>从 gengine 的规则数据结构可知，只需要遍历全局的 hashmap，即可按顺序执行所有的规则（顺序模式），执行每一个规则后会通过<code>addResult()</code>方法记录执行结果：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Gengine)</span></span> Execute(rb *builder.RuleBuilder, b <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> rb.Kc.RuleEntities &#123;</span><br><span class="line">        v, err, bx := r.Execute(rb.Dc)</span><br><span class="line">        <span class="keyword">if</span> bx &#123;</span><br><span class="line">            <span class="comment">// 记录每个规则执行结果</span></span><br><span class="line">            g.addResult(r.RuleName, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于某一个规则的执行，则会去遍历规则体 ruleContent 的所有语句表达式列表，然后按顺序去执行该规则下的所有语句表达式：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Statements)</span></span> Evaluate(dc *context.DataContext, Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value) (reflect.Value, <span class="type">error</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, statement := <span class="keyword">range</span> s.StatementList &#123;</span><br><span class="line">        v, err, b := statement.Evaluate(dc, Vars)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), err, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="comment">// return的情况不需要继续执行</span></span><br><span class="line">            <span class="keyword">return</span> v, <span class="literal">nil</span>, b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.ReturnStatement != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.ReturnStatement.Evaluate(dc, Vars)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gengine 为每个语句类型都实现了 Evaluate() 方法，这里只讨论 IF 语句的执行：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IfStmt <span class="keyword">struct</span> &#123;</span><br><span class="line">    Expression     *Expression</span><br><span class="line">    StatementList  *Statements</span><br><span class="line">    ElseIfStmtList []*ElseIfStmt</span><br><span class="line">    ElseStmt       *ElseStmt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IfStmt)</span></span> Evaluate(dc *context.DataContext, Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value) (reflect.Value, <span class="type">error</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行条件表达式</span></span><br><span class="line">    it, err := i.Expression.Evaluate(dc, Vars)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), err, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行条件为真时的语句</span></span><br><span class="line">    <span class="keyword">if</span> it.Bool() &#123;</span><br><span class="line">        <span class="keyword">if</span> i.StatementList == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i.StatementList.Evaluate(dc, Vars)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中条件表达式<code>Expression.Evaluate()</code>为计算条件表达式的值：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Expression)</span></span> Evaluate(dc *context.DataContext, Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value) (reflect.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 原子表达式</span></span><br><span class="line">    <span class="keyword">var</span> atom reflect.Value</span><br><span class="line">    <span class="keyword">if</span> e.ExpressionAtom != <span class="literal">nil</span> &#123;</span><br><span class="line">        evl, err := e.ExpressionAtom.Evaluate(dc, Vars)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), err</span><br><span class="line">        &#125;</span><br><span class="line">        atom = evl</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较操作</span></span><br><span class="line">    <span class="keyword">if</span> e.ComparisonOperator != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 计算左值</span></span><br><span class="line">        lv, err := e.ExpressionLeft.Evaluate(dc, Vars)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算右值</span></span><br><span class="line">        rv, err := e.ExpressionRight.Evaluate(dc, Vars)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略了类型转化</span></span><br><span class="line">        <span class="keyword">switch</span> e.ComparisonOperator &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;==&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv == rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;!=&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv != rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv &gt; rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv &lt; rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&gt;=&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv &gt;= rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;&lt;=&quot;</span>:</span><br><span class="line">            b = reflect.ValueOf(lv &lt;= rv)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归执行到<code>ExpressionAtom.Evaluate()</code>原子表达式时，就可以得到该原子表达式的值以结束递归：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ExpressionAtom)</span></span> Evaluate(dc *context.DataContext, Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value) (reflect.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(e.Variable) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 是变量则取变量值，通过反射获取注入的自定义对象值</span></span><br><span class="line">        <span class="keyword">return</span> dc.GetValue(Vars, e.Variable)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e.Constant != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 是常量就返回值</span></span><br><span class="line">        <span class="keyword">return</span> e.Constant.Evaluate(dc, Vars)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持自定义对象注入"><a href="#支持自定义对象注入" class="headerlink" title="支持自定义对象注入"></a>支持自定义对象注入</h2><p>在上下文中注入自定义对象后，就可以在规则中使用注入的对象。使用例子：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则体</span></span><br><span class="line">rule <span class="string">&quot;test-object&quot;</span> <span class="string">&quot;测试自定义对象&quot;</span> salience <span class="number">10</span></span><br><span class="line">begin</span><br><span class="line">    <span class="comment">// 访问自定义对象Order</span></span><br><span class="line">    <span class="keyword">if</span> Order.Price &gt;= <span class="number">1000000</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入自定义对象Order</span></span><br><span class="line">dataContext := gctx.NewDataContext()</span><br><span class="line">dataContext.Add(<span class="string">&quot;Order&quot;</span>, Order)</span><br></pre></td></tr></table></figure><p>现在来看下 gengine 的具体实现，主要是使用反射特性：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DataContext)</span></span> Add(key <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    dc.lockBase.Lock()</span><br><span class="line">    <span class="keyword">defer</span> dc.lockBase.Unlock()</span><br><span class="line">    dc.base[key] = reflect.ValueOf(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gengine 解析规则时会将自定义对象标记为<code>variable</code>类型，通过 GetValue() 获取自定义对象属性值：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取变量值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DataContext)</span></span> GetValue(Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value, variable <span class="type">string</span>) (reflect.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(variable, <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 对象a.b</span></span><br><span class="line">        structAndField := strings.Split(variable, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(structAndField) == <span class="number">2</span> &#123;</span><br><span class="line">            a := structAndField[<span class="number">0</span>]</span><br><span class="line">            b := structAndField[<span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 获取注入的对象</span></span><br><span class="line">            dc.lockBase.Lock()</span><br><span class="line">            v, ok := dc.base[a]</span><br><span class="line">            dc.lockBase.Unlock()</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="keyword">return</span> core.GetStructAttributeValue(v, b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射获取对象属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStructAttributeValue</span><span class="params">(obj reflect.Value, fieldName <span class="type">string</span>)</span></span> (reflect.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    stru := obj</span><br><span class="line">    <span class="keyword">var</span> attrVal reflect.Value</span><br><span class="line">    <span class="keyword">if</span> stru.Kind() == reflect.Ptr &#123;</span><br><span class="line">        attrVal = stru.Elem().FieldByName(fieldName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attrVal = stru.FieldByName(fieldName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attrVal, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持自定义方法注入"><a href="#支持自定义方法注入" class="headerlink" title="支持自定义方法注入"></a>支持自定义方法注入</h2><p>同样在上下文中注入自定义方法后，也可以在规则中使用注入的方法。使用例子：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则体</span></span><br><span class="line">rule <span class="string">&quot;test-func&quot;</span> <span class="string">&quot;测试自定义方法&quot;</span> salience <span class="number">10</span></span><br><span class="line">begin</span><br><span class="line">    <span class="comment">// 自定义方法GetCount获取指标数据（患者当天的订单数量）</span></span><br><span class="line">    num = GetCount(<span class="string">&quot;order-patient-id&quot;</span>, Order.PatientId)</span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入自定义方法GetCount</span></span><br><span class="line">dataSvc := s.indicatorDao.NewDataService(ctx)</span><br><span class="line">dataContext := gctx.NewDataContext()</span><br><span class="line">dataContext.Add(<span class="string">&quot;GetCount&quot;</span>, dataSvc.GetCount)</span><br></pre></td></tr></table></figure><p>gengine 自定义方法的注入也是使用反射来实现，自定义方法的注入同自定义对象一样也是使用 Add() 方法注入。</p><p>gengine 解析规则时会将自定义方法标记为<code>functionCall</code>类型：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DataContext)</span></span> ExecFunc(Vars <span class="keyword">map</span>[<span class="type">string</span>]reflect.Value, funcName <span class="type">string</span>, parameters []reflect.Value) (reflect.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取注入的方法</span></span><br><span class="line">    dc.lockBase.Lock()</span><br><span class="line">    v, ok := dc.base[funcName]</span><br><span class="line">    dc.lockBase.Unlock()</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        args := core.ParamsTypeChange(v, parameters)</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        res := v.Call(args)</span><br><span class="line">        raw, e := core.GetRawTypeValue(res)</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> reflect.ValueOf(<span class="literal">nil</span>), e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raw, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持并发执行"><a href="#支持并发执行" class="headerlink" title="支持并发执行"></a>支持并发执行</h2><p>通常情况下顺序模式执行即可满足要求，但是当规则数量比较大时，顺序执行的耗时就会比较长。</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/36E0B373-95A2-4E26-AFE2-ED9522CCB708.png" alt="顺序模式"></p><p>规则引擎在执行所有规则的时候，其实是遍历全局的 hashmap 然后再顺序执行每一个规则，由于每个规则之间没有依赖关系，因此可以用每一个规则一个协程来并发执行。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Gengine)</span></span> ExecuteConcurrent(rb *builder.RuleBuilder) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(rb.Kc.RuleEntities))</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> rb.Kc.RuleEntities &#123;</span><br><span class="line">        rr := r</span><br><span class="line">        <span class="comment">// 协程并发</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            v, e, bx := rr.Execute(rb.Dc)</span><br><span class="line">            <span class="keyword">if</span> bx &#123;</span><br><span class="line">                g.addResult(rr.RuleName, v)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// 省略部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有了规则引擎之后，很多在业务代码中的 if-else、switch 硬编码，都能抽象为规则并使用规则引擎，这样能通过配置规则代替硬编码，能极大地缩短变更上线时间。</p><h3 id="业务风控"><a href="#业务风控" class="headerlink" title="业务风控"></a>业务风控</h3><p>通过业务数据分析，可以抽象出用户异常行为的规则：</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/C0C5B489-90D1-4937-A8D8-55459E951ABC.png" alt="风控规则"></p><p>然后，风控系统在判断是否为风险操作时，只需要规则引擎加载并执行风控规则，即可得到结果。<br>想要提高风控系统的准确性，只需要不断地迭代完善风控规则。</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/C290970F-D33E-49DF-846B-577E62694709.png" alt="风控系统"></p><p>规则引擎在业务风控的实践，可以参考 <a href="https://www.fanhaobai.com/2022/06/risk-rule.html">基于准实时规则引擎的业务风控实践</a>。</p><h3 id="运营活动"><a href="#运营活动" class="headerlink" title="运营活动"></a>运营活动</h3><p>拿最常见的抽奖和做任务 2 种运营活动来说，都可以将具体活动逻辑抽象为业务规则：<br>① 抽奖，不同的人&amp;不同的场景对应不同的奖池（中奖概率与奖品集合规则）；<br>② 做任务，任务领取规则、任务完成指标动态可配（任务规则）；</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/30B59826-F443-4D9A-AC98-42F7E28127D5.png" alt="运营活动"></p><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>针对某些特定的用户或者某种场景的用户，下发特定的展示内容或者推送短信等触达消息，都可以将这些特定用户的逻辑梳理为内容分发规则。</p><p><img src="//www.fanhaobai.com/2024/04/design-rule-engine/E937E855-8B7C-4B4C-9761-0764D563BE42.png" alt="内容分发"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;规则引擎的功能可以简化为当满足一些条件时触发一些操作，通常使用 DSL 自定义语法来表述。规则引擎需要先解析 DSL 语法形成语法树，然后遍历语法树得到完整的语法表达式，最后执行这些语法表达式完成规则的执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2024/04/design-rule-engine/12805423-37FB-4225-91E3-EC6473BA720C.png&quot; alt=&quot;规则引擎&quot;&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.fanhaobai.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>千人千面个性化推荐系统</title>
    <link href="https://www.fanhaobai.com/2023/01/recommender-system.html"/>
    <id>https://www.fanhaobai.com/2023/01/recommender-system.html</id>
    <published>2023-01-02T06:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.727Z</updated>
    
    <content type="html"><![CDATA[<p>千人千面是指系统基于用户的兴趣，通过复杂算法来推荐个性化的内容，不再是千篇一律，达到用户所见即所需的效果，能显著提高成交转化率，更能提升用户体验。</p><p><img src="//www.fanhaobai.com/2023/01/recommender-system/19F578B4-4B33-4F28-AAE4-D4C71308A360.png" alt="推荐系统"><span id="more"></span></p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>千人千面</li><li>个性化推荐</li><li>内容系统</li><li>算法</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>目前我们日常使用互联网应用几乎都应用了个性化推荐技术，但是它的推广应用却不是一蹴而就的。</p><ul><li><p>第一阶段<br>2012年今日头条上线，第一个利用推荐系统进行流量分发的内容APP</p></li><li><p>第二阶段<br>2015年淘宝双11全面开启“千人千面”时代</p></li><li><p>现在<br>知乎、抖音、美团等各大应用都在使用推荐系统进行个性化内容推荐</p></li></ul><h2 id="商业价值"><a href="#商业价值" class="headerlink" title="商业价值"></a>商业价值</h2><h3 id="提升用户体验"><a href="#提升用户体验" class="headerlink" title="提升用户体验"></a>提升用户体验</h3><p>所见即所需，不再需要用户从成千上万的内容中去挑选自己感兴趣的。</p><h3 id="提高成交转化率"><a href="#提高成交转化率" class="headerlink" title="提高成交转化率"></a>提高成交转化率</h3><p>精准推广，用户成交冲动更强。</p><h2 id="解决方案介绍"><a href="#解决方案介绍" class="headerlink" title="解决方案介绍"></a>解决方案介绍</h2><h3 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h3><h4 id="搜索列表"><a href="#搜索列表" class="headerlink" title="搜索列表"></a>搜索列表</h4><ul><li>淘宝搜索商品<br>关键字搜索，并根据相似度排序来推荐相似的商品。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/5D1A9AD7-9EDF-4607-A2D2-8B73D9FEA7B5.png" alt="淘宝搜索商品"></p><ul><li>美团外卖搜索<br>关键字搜索，并根据商家距离、评分、配送速度等因素来综合排序推荐。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/7A956F05-52D9-4B2F-9466-62883F81958D.png" alt="美团外卖"></p><ul><li>信息流<br>知乎首页信息流，推荐有浏览、赞同、评价的同类内容，以及关注的人的内容，曾发表过的文章有相同主题的内容。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/D1C891D1-878A-4B95-97D7-BBA7AFAB3467.png" alt="知乎"></p><ul><li>猜你喜欢<br>推荐用户购买过、浏览过商品的同类商品，还可以推荐对相同商品有相同行为的这类用户的购买和浏览商品。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/74661B99-43E6-4532-9B93-AAB9469E5DD1.png" alt="猜你喜欢"></p><h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p>因为推荐系统整个的技术难度较大，一般都是算法专业且有经验的团队来做。实践中可以分3个阶段来做：千人几面——千人百面——千人千面</p><ul><li>萌芽：千人几面<br>基于规则匹配推荐。制定一些简单的业务规则，如根据用户自己对内容产生的浏览次数（看了又看）、购买次数（买了还买），收藏次数来做简单的推荐；或者根据性别年龄分类来做推荐，18岁的女生都喜欢什么，中年大叔又都喜欢什么。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/E2A4D0D2-EA74-4130-A8CE-4B7FBD9E9E40.png" alt="千人几面"></p><ul><li>起步：千人百面<br>基于内容的推荐。如果只是推荐用户已经产生行为的内容，那这些内容也只会是单一的，对用户吸引性不强。那么我们可以基于用户产生行为的这些内容做相似推荐，如推荐相同分类、品牌、标签的内容。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/5FF361FE-B7B5-4A01-9DA5-CF9AEC5B7462.png" alt="千人百面"></p><ul><li>绽芒：千人千面，比你自己更懂你<br>基于协同过滤的推荐。基于内容的推荐已经能基本满足用户的推荐需求，却不能做到真正的千人千面，因为都是基于用户自己的行为数据来做推荐。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/41C31DFF-9546-413B-82A5-794DC47488B7.png" alt="千人千面"></p><p>协同过滤不单单只根据自己的喜好，而且还引入了相同行为的人的喜好来进行推荐，即我喜欢的内容，他也喜欢，那么他喜欢的其他内容我可能也很喜欢。以人类人这样推荐更加充分，而且可以深入挖掘用户潜在的兴趣。</p><p><strong>那怎么计算内容相似度呢？</strong><br>首先提取出内容的特征，又通计算得出了用户喜欢的特征，那么可以通过余弦相似度计算出内容间的相似度，做为个性化推荐的依据。余弦相似度是指通过计算两个向量的夹角余弦值来评估他们的相似度，夹角越小，两个向量越相似；夹角越大，两个向量越不同。</p><p><img src="//www.fanhaobai.com/2023/01/recommender-system/BD317F5E-8689-4139-BE07-FC82C6EEA69A.png" alt="内容相似度"></p><h2 id="我们的机会"><a href="#我们的机会" class="headerlink" title="我们的机会"></a>我们的机会</h2><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li>药房与药品列表<br>能直接猜出用户所需的药品，而不是简单配一些常见药。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/B4417679-0FCA-4EA0-8E95-CAA95912C05E.png" alt="药房与药品列表"></p><ul><li>医生列表<br>对于一个肝病患者展示这些，患者也只能再去搜医生的名字或者科室才能找到医生。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/E7E33224-409F-44E4-8A39-EDA85F89435C.png" alt="医生列表"></p><ul><li>学术文章信息流<br>医生很忙，不能推些他不感兴趣的学术内容打扰他。</li></ul><p><img src="//www.fanhaobai.com/2023/01/recommender-system/97FD0BB9-EA8C-4BBD-BAAA-8721149084F3.png" alt="学术文章信息流"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千人千面是指系统基于用户的兴趣，通过复杂算法来推荐个性化的内容，不再是千篇一律，达到用户所见即所需的效果，能显著提高成交转化率，更能提升用户体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2023/01/recommender-system/19F578B4-4B33-4F28-AAE4-D4C71308A360.png&quot; alt=&quot;推荐系统&quot;&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.fanhaobai.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Flink在用户画像上的应用</title>
    <link href="https://www.fanhaobai.com/2022/12/user-profile-use-flink.html"/>
    <id>https://www.fanhaobai.com/2022/12/user-profile-use-flink.html</id>
    <published>2022-12-23T11:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.722Z</updated>
    
    <content type="html"><![CDATA[<p>将 Flink 应用于用户画像的场景，既能轻松应对大量的计算量，也能提供实时的计算结果，还能避免开发同学用编程的方式开发数据清洗任务。<br><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/FAA84305-96B3-4934-8991-C5ACE2752C5A.png" alt="风控抽象过程"><span id="more"></span></p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>大数据计算</li><li>SQL</li></ul><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p>解决计算海量数据计算量大、延迟高的性能问题，如用户画像需要计算大量业务和事件数据的场景。<br><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/082D3F30-8845-4943-AC1E-6AF494885350.png" alt="海量数据"></p><h2 id="商业价值"><a href="#商业价值" class="headerlink" title="商业价值"></a>商业价值</h2><h3 id="数据即价值"><a href="#数据即价值" class="headerlink" title="数据即价值"></a>数据即价值</h3><p>对平台积累的大量数据进行挖掘分析，创造出潜在的商业价值。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是-Flink"><a href="#什么是-Flink" class="headerlink" title="什么是 Flink"></a>什么是 Flink</h3><p>Flink 是一个分布式计算引擎，可以用来做批处理，即处理历史数据；也可以用来做流处理，即实时地处理数据流，并实时地产生数据的结果。<br><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/DD0DBEE8-32B8-4A78-B0A2-3907A710907A.png" alt="Flink处理数据流程"></p><p>Flink 特点：</p><ul><li>性能突出：计算量大-百亿级、延迟低-秒级</li><li>支持 SQL 作业：只需要写 SQL 逻辑，简单上手快</li><li>有状态支持容错：即发生了失败，也不会丢失、多计算或者少计算</li></ul><p>Flink 支持丰富的数据源，能满足大部分的业务场景需求。数据输入源支持 MySQL、Mongo 等数据库，也支持 Kafka 等事件消息中心；数据输出源支持 MySQL、Mongo、Redis 等数据库，也支持 Hbase、Hive 等数据仓库。</p><h3 id="当前行业现状"><a href="#当前行业现状" class="headerlink" title="当前行业现状"></a>当前行业现状</h3><p>Flink 已成为了大数据计算引擎的首选，国内各大厂都有相应的落地实践案例，技术比较成熟。各云厂商也都提供了相应的云计算产品：</p><ul><li>腾讯云：<a href="https://cloud.tencent.com/product/oceanus">Oceanus</a></li><li>阿里云：<a href="https://www.aliyun.com/product/bigdata/sc">Flink</a></li></ul><h2 id="解决方案介绍"><a href="#解决方案介绍" class="headerlink" title="解决方案介绍"></a>解决方案介绍</h2><h3 id="Flink-怎样接入"><a href="#Flink-怎样接入" class="headerlink" title="Flink 怎样接入"></a>Flink 怎样接入</h3><p><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/FAA84305-96B3-4934-8991-C5ACE2752C5A.png" alt="Flink怎样接入"></p><p>Flink 数据输入端接入 MySQL 数据库和 Kafka 消息中心，能同时对业务数据和业务事件 2 种数据类型进行处理。<br>Flink 计算输出结果一般存储在 Hive、Hbase 等大数据数仓。 因此，接入已有系统数据源并不需要做任何改造。</p><h3 id="SQL-作业使用"><a href="#SQL-作业使用" class="headerlink" title="SQL 作业使用"></a>SQL 作业使用</h3><p>数据的计算逻辑任务，一般都会选择 SQL 作业的类型。<br>对开发者友好，只需要用 SQL 表达出对应逻辑即可。</p><p><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/4C7CA16C-53B3-455A-86B0-D0917B69C21E.png" alt="SQL作业"></p><h2 id="我们的机会"><a href="#我们的机会" class="headerlink" title="我们的机会"></a>我们的机会</h2><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><p><img src="//www.fanhaobai.com/2022/12/user-profile-use-flink/96A9AAFE-201F-48DF-8318-ED035B06269C.png" alt="架构"></p><p>如图所示，交易数据、处方数据、用户基础数据、用户行为数据作为数据源，经过大数据 Flink 计算清洗、结构化、预处理后，产出疾病特征、基本属性、行为特征画像数据。</p><p>借助于 Flink，这一切只需要编写 SQL 即可，数据的处理、分布式调度我们都不需要关心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将 Flink 应用于用户画像的场景，既能轻松应对大量的计算量，也能提供实时的计算结果，还能避免开发同学用编程的方式开发数据清洗任务。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2022/12/user-profile-use-flink/FAA84305-96B3-4934-8991-C5ACE2752C5A.png&quot; alt=&quot;风控抽象过程&quot;&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.fanhaobai.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>基于准实时规则引擎的业务风控实践</title>
    <link href="https://www.fanhaobai.com/2022/06/risk-rule.html"/>
    <id>https://www.fanhaobai.com/2022/06/risk-rule.html</id>
    <published>2022-06-28T12:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.707Z</updated>
    
    <content type="html"><![CDATA[<p>在当今复杂的互联网环境下，我们的系统时时刻刻都暴露在风险（刷单党、羊毛党）的攻击之中，如果我们不采取有效防御措施，那么这些风险就会对业务造成很大的损失。</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/24476377-1566-4cfd-bcd6-3d8af562e57c.png" alt="风控抽象过程"><span id="more"></span></p><p>用公式可以表达出风控规则和风险数据的系统关系：z=f(x, y)，f 为系统风控规则，x 为系统实时输入风险数据，y 为系统的事实数据。</p><h2 id="挑战性"><a href="#挑战性" class="headerlink" title="挑战性"></a>挑战性</h2><ul><li><strong>数据量大</strong>，计算延时严重</li><li><strong>风控策略多变</strong></li></ul><p><img src="//www.fanhaobai.com/2022/06/risk-rule/c3d8e074-443d-4b14-9533-ff45fd32a4c7.png" alt="挑战性"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>准确及时<strong>识别风险</strong></li><li>采取有效<strong>防御措施</strong></li></ul><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>基于大数据实时计算和可热更新的通用规则引擎，搭建一套业务风控系统。</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/08e98b72-3fbd-4c58-a8a4-aa88af950499.png" alt="架构图"></p><p><strong>业务风险</strong>：刷单（订单）、薅羊毛（活动）、恶意注册和异常登录（用户）</p><p><strong>业务服务</strong>：</p><ul><li><strong>风控</strong>系统：<strong>识别</strong>业务风险，根据业务数据或埋点信息来判断当前用户或事件有无风险；</li><li><strong>惩罚</strong>系统：对系统风险操作进行<strong>控制或惩罚</strong>，如禁止下单、增加验证码、限制登录等；</li><li><strong>分析</strong>系统（管理系统）：提供<strong>系统管理</strong>和<strong>数据展示分析</strong>。系统管理如规则管理，分析业务数据如风险的订单，分析系统指标数据如某策略规则拦截率，以及时修正策略规则；</li></ul><p><strong>系统引擎</strong>：</p><ul><li>规则引擎：<strong>策略规则</strong>的<strong>解析</strong>和<strong>执行</strong>，选用 B 站开源的 <a href="https://github.com/bilibili/gengine">gengine</a> 规则引擎（golang）；</li><li>大数据计算引擎：<strong>实时在线</strong>或离线计算<strong>业务指标数据</strong>，选用 Flink + Kafka 流计算引擎，指标数据存储在 Redis（数据异构）。各云厂商提供相应服务，如腾讯云流计算 <a href="https://cloud.tencent.com/document/product/849/48301">Oceanus</a>；</li></ul><p>消息中心：各系统之间通过事件驱动，选用 Kafka</p><p>存储：</p><ul><li>MySQL：风控规则等</li><li>Redis：指标数据</li><li>Mongo：操作日志、快照等</li></ul><h2 id="系统工作流程"><a href="#系统工作流程" class="headerlink" title="系统工作流程"></a>系统工作流程</h2><p><img src="//www.fanhaobai.com/2022/06/risk-rule/6c0c61f3-f53b-4a3e-bc40-caa4e868e981.png" alt="工作流程"></p><p>包含 3 个数据流。</p><ul><li><strong>实时风控数据流</strong>：由<strong>红线</strong>标识。业务同步调用风控系统，返回风险识别结果，并作相应惩罚，为系统核心链路；</li><li><strong>准实时指标数据流</strong>：由<strong>蓝线</strong>标识。大数据计算引擎实时异步写入，准备业务指标数据并存储在 Redis，为系统准实时链路；</li><li><strong>准实时/离线分析数据流</strong>：由<strong>绿线</strong>标识。异步写入，生成业务报表和评估风控系统表现的数据，以供进行数据分析；</li></ul><h2 id="风控规则抽象"><a href="#风控规则抽象" class="headerlink" title="风控规则抽象"></a>风控规则抽象</h2><p><img src="//www.fanhaobai.com/2022/06/risk-rule/75345e28-87b4-4b77-8912-606821c5d08d.png" alt="风控规则抽象"></p><p>风控规则通常分 2 种，即统计规则和主体属性规则。都可以抽象为通用公式：</p><ul><li>统计规则：{某时间段}，{某主体} 在 {某个统计维度的结果} {比较操作符} {阈值}</li><li>主体属性规则：{主体}.{属性名}</li></ul><blockquote><p>下文将以 <strong>1天内同一患者ID订单数超过5笔</strong> 规则进行示例和说明。</p></blockquote><h2 id="大数据实时计算引擎"><a href="#大数据实时计算引擎" class="headerlink" title="大数据实时计算引擎"></a>大数据实时计算引擎</h2><p><img src="//www.fanhaobai.com/2022/06/risk-rule/2cf3e5c4-2a75-4f3b-a51e-f0a206a386e8.png" alt="大数据计算引擎"></p><p>Flink 输入数据为 JSON 格式，Flink 的数据源有 2 种：</p><ul><li><strong>业务事件 -&gt; Kafka -&gt; Flink</strong>，业务事件需要转化为 JSON 消息格式</li><li><strong>业务数据 -&gt; DTS -&gt; Kafka -&gt; Flink</strong>，支持全量和增量读取数据</li></ul><h3 id="数据指标存储"><a href="#数据指标存储" class="headerlink" title="数据指标存储"></a>数据指标存储</h3><p>指标数据<strong>异构</strong>，用空间换时间。Redis 的 <strong>zset</strong> 结构，通过 <code>ZCOUNT key startTime endTime</code> 操作即可统计任意时间段 <strong>startTime</strong> 至 <strong>endTime</strong> 内的统计需求。</p><table><thead><tr><th>规则</th><th>实现</th><th>写操作</th><th>读操作</th></tr></thead><tbody><tr><td>1天内同一患者ID订单数超过5笔</td><td>key：患者id<br>value：订单id<br>score：下单时间</td><td>ZADD<br>O(M*log(N)</td><td>ZCOUNT<br>O(log(N)+M)</td></tr></tbody></table><p>形如 <strong>1天内同一患者ID订单数超过5笔</strong> 规则，数据指标存储格式：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">risk:order-patient-id:<span class="number">123456</span></span><br><span class="line">|-<span class="number">-111111</span>        <span class="number">1652929153</span></span><br><span class="line">|-<span class="number">-222222</span>        <span class="number">1652932753</span></span><br><span class="line">|-<span class="number">-333333</span>        <span class="number">1652939953</span></span><br></pre></td></tr></table></figure><p>统计指标为：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startTime 和 endTime 对应为1天时间间隔</span></span><br><span class="line">ZCOUNT risk:order-patient-id:<span class="number">123456</span> <span class="number">1652940185</span> <span class="number">1652853785</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>随着时间的推移，zset 会出现元素越来越多的情况，后续可以通过定期升级 key 版本号的方式来解决，每次升级版本号之后需要批处理初始化所有指标数据。</p><h3 id="创建指标数据实时计算作业"><a href="#创建指标数据实时计算作业" class="headerlink" title="创建指标数据实时计算作业"></a>创建指标数据实时计算作业</h3><p>选用 Flink 的 SQL 作业类型，见 创建 SQL 作业。<br>形如 <strong>1天内同一患者ID订单数超过5笔</strong> 规则，定义源表和目标表是为了 SQL 中方便使用。</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/d50d0ac4-e740-4ee5-a744-b8c9a593a8be.png" alt="SQL作业"></p><h4 id="数据源表"><a href="#数据源表" class="headerlink" title="数据源表"></a>数据源表</h4><p>定义 MySQL 数据源表，字段跟数据表一一<strong>对应映射</strong>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `risk_input_order` (</span><br><span class="line">    `id`            <span class="type">INT</span>,</span><br><span class="line">    `pid`           <span class="type">INT</span>,</span><br><span class="line">    `doctor_id`     <span class="type">INT</span>,</span><br><span class="line">    `patient_id`    <span class="type">INT</span>,</span><br><span class="line">    `deliver_phone` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    `deliver_name`  <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    `delivery_address` <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    `prescription_id`  <span class="type">INT</span>,</span><br><span class="line">    `total_price`      <span class="type">INT</span>,</span><br><span class="line">    `is_test`          TINYINT,</span><br><span class="line">    `created_at`       <span class="type">TIMESTAMP</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="comment">-- 定义 Kafka 参数</span></span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;med_dts_b_convert&#x27;</span>,  <span class="comment">-- 消费的 Topic</span></span><br><span class="line">    <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;latest-offset&#x27;</span>, <span class="comment">-- 可以是 latest-offset / earliest-offset / specific-offsets / group-offsets / timestamp 的任何一种</span></span><br><span class="line">    <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;172.28.28.13:9092&#x27;</span>,  <span class="comment">-- Kafka 连接地址</span></span><br><span class="line">    <span class="string">&#x27;properties.group.id&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;risk_input_order&#x27;</span>,            <span class="comment">-- 指定 Group ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 定义数据格式 (JSON 格式)</span></span><br><span class="line">    <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;json.fail-on-missing-field&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;false&#x27;</span>,  <span class="comment">-- 遇到缺失字段不会报错</span></span><br><span class="line">    <span class="string">&#x27;json.ignore-parse-errors&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;true&#x27;</span>      <span class="comment">-- 忽略任何解析报错</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="目标表"><a href="#目标表" class="headerlink" title="目标表"></a>目标表</h4><p>定义 Redis 目标表，对应 <code>ZADD key value score</code> 操作写入数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `risk_output_order_patient_id` (  </span><br><span class="line">    `key`   STRING,</span><br><span class="line">    `<span class="keyword">value</span>` STRING</span><br><span class="line">    `score` <span class="keyword">DOUBLE</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;redis&#x27;</span>,          </span><br><span class="line">    <span class="string">&#x27;command&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;zadd&#x27;</span>,              <span class="comment">-- redis zadd命令写入数据</span></span><br><span class="line">    <span class="string">&#x27;nodes&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;192.28.28.217:6379&#x27;</span>,  <span class="comment">-- redis连接地址。</span></span><br><span class="line">    <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;yourpassword&#x27;</span>   </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="数据计算逻辑"><a href="#数据计算逻辑" class="headerlink" title="数据计算逻辑"></a>数据计算逻辑</h4><p>直接使用 SQL 来<strong>清洗</strong>和<strong>合并</strong>数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 清洗患者id维度订单数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> risk_output_order_patient_id</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">CONCAT(<span class="string">&#x27;risk:order-patient-id:&#x27;</span>, patient_id) <span class="keyword">AS</span> `key`,</span><br><span class="line">id <span class="keyword">AS</span> <span class="keyword">value</span>,</span><br><span class="line">UNIX_TIMESTAMP(created_at) <span class="keyword">AS</span> score</span><br><span class="line"><span class="keyword">FROM</span> risk_input_order</span><br><span class="line"><span class="keyword">WHERE</span> pid <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="流批一体（流处理和批处理一套逻辑）"><a href="#流批一体（流处理和批处理一套逻辑）" class="headerlink" title="流批一体（流处理和批处理一套逻辑）"></a>流批一体（流处理和批处理一套逻辑）</h3><p>在首次初始化指标数据或者新增数据指标的场景下，需要支持读取全量和增量数据，流批一体后，这样无需维护两套流程。</p><h4 id="源表数据过期时间"><a href="#源表数据过期时间" class="headerlink" title="源表数据过期时间"></a>源表数据过期时间</h4><p>其实要做到<strong>流批一体</strong>，只需要 Flink <strong>源表历史数据的过期时间不小于指标数据统计周期</strong>即可。系统 Kafka 消息<strong>过期时间增大</strong>为 30 天，则指标数据统计周期最大也为 30 天（已经满足风控规则要求），因此系统是可以做到流批一体的。</p><h4 id="初始化和新增指标数据"><a href="#初始化和新增指标数据" class="headerlink" title="初始化和新增指标数据"></a>初始化和新增指标数据</h4><p>因为在风控场景，规则中的指标数据只需要最近统计周期时间的数据，可以直接<strong>重置 Kafka 消息位点</strong>来批处理源表历史数据，即可清洗出对应的指标数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `risk_input_order` (</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="comment">-- 定义 Kafka 参数</span></span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;earliest-offset&#x27;</span>, <span class="comment">-- 最早消费位点</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="风控系统"><a href="#风控系统" class="headerlink" title="风控系统"></a>风控系统</h2><p>封装规则引擎形成 <strong>risk-service</strong> 服务，供业务直接调用。<br>风险识别流程：</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/07072d15-ffc0-434e-9417-cc04fd0ae979.png" alt="风险识别流程"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>对外提供业务风险识别接口、业务数据或事件上报接口。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单风控</span></span><br><span class="line">service RiskOrder &#123;</span><br><span class="line">    <span class="comment">// 风险识别</span></span><br><span class="line">    rpc CheckRisk (CheckRiskReq) returns (CheckRiskResp);</span><br><span class="line">    <span class="comment">// 数据/事件上报</span></span><br><span class="line">    rpc Report (ReportReq) returns (ReportResp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p>很多的规则形成<strong>规则集</strong>，规则集组成一颗<strong>决策树</strong>，决策树是规则引擎核心的判断逻辑。</p><h3 id="规则体语法"><a href="#规则体语法" class="headerlink" title="规则体语法"></a>规则体语法</h3><p>是一种自定义的 <strong>DSL</strong> 语法。支持<strong>运算符</strong>、支持<strong>基础数据类型</strong>、支持<strong>条件语句</strong>、支持并发语句块、并支持<strong>结构体和方法注入</strong>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则名必须唯一</span></span><br><span class="line">rule <span class="string">&quot;rulename&quot;</span> <span class="string">&quot;rule-describtion&quot;</span> salience priority</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则体</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>形如 <strong>一天内同一患者ID订单数超过5笔</strong> 规则，规则体语法为：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;pa-daily-order-count&quot;</span> <span class="string">&quot;一天内同一患者ID订单数规则&quot;</span> salience <span class="number">10</span></span><br><span class="line">begin</span><br><span class="line"><span class="keyword">if</span> GetData(<span class="string">&quot;order-patient-id&quot;</span>, Patient.UserId, <span class="number">24</span>*<span class="number">3600</span>) &gt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 命中规则</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="获取事实和指标数据"><a href="#获取事实和指标数据" class="headerlink" title="获取事实和指标数据"></a>获取事实和指标数据</h3><p>通过对规则引擎<strong>注入预定义</strong>的<strong>结构体</strong>和<strong>方法</strong>，可以实现在规则体中获取事实和指标数据。</p><ul><li>事实数据<br>对规则引擎注入 <strong>User</strong>、<strong>Patient</strong> 结构体引用(指针)，在规则体中通过 <strong>{主体}.{属性}</strong> 的方式即可获取到事实的某个属性。</li></ul><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取事实数据</span></span><br><span class="line">user := xuser.GetUserInfo(userId)</span><br><span class="line">patient := xuser.GetPatientInfo(userId)</span><br><span class="line"></span><br><span class="line">dataContext := context.NewDataContext()</span><br><span class="line"><span class="comment">// 事实数据注入</span></span><br><span class="line">dataContext.Add(<span class="string">&quot;User&quot;</span>, user)</span><br><span class="line">dataContext.Add(<span class="string">&quot;Patient&quot;</span>, patient)</span><br></pre></td></tr></table></figure><ul><li>指标数据<br>对规则引擎注入 <strong>GetData()</strong> 方法，参数是一个<strong>三元组</strong>，在规则体中通过 <strong>GetData(“指标名”, “主体id”, “时间周期”)</strong> 的方式即可获得指标数据。</li></ul><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指标数据函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DataService)</span></span> GetData(indicator <span class="type">string</span>, subjectId <span class="type">string</span>, period <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    key := fmt.sprintf(<span class="string">&quot;risk:%s:%s&quot;</span>, indicator, subjectId)</span><br><span class="line">    endTime := time.Now().Unix()</span><br><span class="line">    startTime := endTime - period</span><br><span class="line">    </span><br><span class="line">    err, res := redis.SCount(key, startTime, endTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 注入函数会忽略 error 返回值，通过错误标志来区分报错和默认值的情况</span></span><br><span class="line">        s.SetError(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数注入规则引擎</span></span><br><span class="line">dataContext := context.NewDataContext()</span><br><span class="line">dataSvc := &amp;DataService&#123;&#125;</span><br><span class="line">dataContext.Add(<span class="string">&quot;GetData&quot;</span>, dataSvc.GetData)</span><br></pre></td></tr></table></figure><h3 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h3><p>支持<strong>并行模式</strong>和<strong>混合模式</strong>执行，目前只考虑并行模式。</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/5d6f4a50-a372-4280-bdef-df106aa1684b.png" alt="执行模式"></p><h3 id="规则编译与执行"><a href="#规则编译与执行" class="headerlink" title="规则编译与执行"></a>规则编译与执行</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">dataContext := context.NewDataContext()</span><br><span class="line"><span class="comment">// 数据、函数注入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rules []<span class="type">string</span></span><br><span class="line"><span class="comment">// rules from MySQL...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则编译</span></span><br><span class="line">ruleBuilder := builder.NewRuleBuilder(dataContext)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> rules &#123;</span><br><span class="line">    <span class="keyword">if</span> err := ruleBuilder.BuildRuleWithIncremental(r); <span class="literal">nil</span> != err &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则并行模式执行</span></span><br><span class="line">eng := engine.NewGengine()</span><br><span class="line"><span class="keyword">if</span> err := eng.ExecuteConcurrent(ruleBuilder); <span class="literal">nil</span> != err &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dataSvc.HasError() &#123;</span><br><span class="line">    <span class="comment">// 规则执行过程中，获取数据发生的报错</span></span><br><span class="line">    <span class="keyword">return</span> dataSvc.FirstError()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果 map[命中规则ID]interface&#123;&#125;</span></span><br><span class="line">resMap, _ := eng.GetRulesResultMap()</span><br></pre></td></tr></table></figure><h2 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h2><p>管理系统包含<strong>惩罚系统</strong>和<strong>分析系统</strong>。系统功能如下：</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/ccd31bea-13f9-456e-b908-9d682e2bd5c3.png" alt="管理系统功能图"></p><h2 id="怎样发布一个规则"><a href="#怎样发布一个规则" class="headerlink" title="怎样发布一个规则"></a>怎样发布一个规则</h2><p>一个完整的风控规则发布流程：</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/cd83c013-eccc-42ce-8075-5fd7267edf3d.png" alt="风控规则发布流程"></p><p>研发工程师可以在管理后台很方便地编写规则，并支持版本管理：</p><p><img src="//www.fanhaobai.com/2022/06/risk-rule/c54f0ab7-1a73-4c2e-998c-76d02148c8dc.png" alt="后台编写规则"></p><h2 id="怎样接入一个新的业务风险"><a href="#怎样接入一个新的业务风险" class="headerlink" title="怎样接入一个新的业务风险"></a>怎样接入一个新的业务风险</h2><p>只需要做 2 件事：</p><ol><li>生成业务<strong>指标数据</strong></li><li>配置业务<strong>风控规则</strong></li></ol><h2 id="系统降级"><a href="#系统降级" class="headerlink" title="系统降级"></a>系统降级</h2><p>因为业务系统会同步调用风控系统进行风险识别，如果风控系统不可用时，则业务系统也不可用，因此需要系统<strong>降级措施</strong>。</p><ul><li><strong>关闭场景开关</strong><br>紧急情况可关闭场景开关，业务风险识别接口则直接返回<strong>无风险</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在当今复杂的互联网环境下，我们的系统时时刻刻都暴露在风险（刷单党、羊毛党）的攻击之中，如果我们不采取有效防御措施，那么这些风险就会对业务造成很大的损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2022/06/risk-rule/24476377-1566-4cfd-bcd6-3d8af562e57c.png&quot; alt=&quot;风控抽象过程&quot;&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.fanhaobai.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="https://www.fanhaobai.com/2021/12/2021-personal-summary.html"/>
    <id>https://www.fanhaobai.com/2021/12/2021-personal-summary.html</id>
    <published>2021-12-31T13:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关键词：不轴</p></blockquote><p>这一年信息量还是挺大，做了很多项目，但是业务产出较少（有一些外部因素），职级也未能得到晋升。经过这一年的时间沉淀，不再自以为是，以更开放的心态接受身边事物的改变。</p><p><img src="//www.fanhaobai.com/2021/12/2021-personal-summary/10183cff-d8cc-4e5f-97cb-b897a256bd41.png" alt="预览图"><span id="more"></span></p><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="业务第一"><a href="#业务第一" class="headerlink" title="业务第一"></a>业务第一</h3><p>不再以为技术最牛逼，更多考虑的是用户体验，跟产品撕逼的情况少了，愿意去提供更好的方案，更会站在产品的角度去懂得产品同学的想法。业务第一，产品第二，技术第三，技术赋能产品，产品驱动业务，一切都是为了业务。</p><p>最近有一个业务需求，需求前期阶段就同产品同学对接过几次，确定了可行方案。但是到了需求评审阶段，又进行了多次修改调整，需求评审时间跨度1周+，这就导致剩余给开发和测试的时间只有 1 周了。项目参与同学怨声载道，不满情绪较多。<br>这时我就陷入了两难境地，为了让项目参与同学解气也一起喷产品同学（你这需求能不能行了），还是试图让项目同学理解这种特殊情况（项目同学：理解个屁啊，开发时间这么短，谁能理解我啊，到时候上不了线又说技术同学不给力）？<br>我是项目技术 Owner，要解决这种僵局需要多做少说，解释就是掩饰，只能想办法解决需求变更的原因。先拉上产品同学从技术视角提供可行的解决方案，从用户视角优化流程体验，确定最终的产品核心流程链路，这些一期先上线不能再变动。<br>其他的统统放后续优化迭代，在一期上线之后再处理。</p><h3 id="技术重构"><a href="#技术重构" class="headerlink" title="技术重构"></a>技术重构</h3><p>这一年在上游产品输出一般的情况下，我们抽了大部分时间做了系统重构，填了很多坑（也又埋了一些坑），业务完成了收口，也为后续业务迭代打好基础。超过 85% 的业务已完成系统重构，2 个重构项目获得了标杆 OKR。</p><p><strong>怎么选定重构项目？</strong></p><p>从实际出发，是业务或开发痛点的才去重构，不要为了重构而重构。</p><ul><li>历史包袱重且迭代频繁的核心业务功能</li><li>迭代频繁可抽象通用化的功能</li><li>迭代频繁可配置化的功能</li></ul><p><strong>怎么实施重构？</strong></p><p>不着急大步推进重构，拆分成不同的迭代周期，每期的任务是具体的，是可以完成，是进度可控的。另外找到合适的时间点去做重构，借力合适的业务需求去做重构，就会事半功倍。</p><p>合适的时间点去做重构，有这样一个例子：<br>由于历史原因，我们有个问诊系统，对接了百度、腾讯且各自为独立系统，算上我们自己的系统有 3 套类似功能的系统，在 APP 端也是不同的功能流程。这样用户体验不好，开发维护体验也不好。<br>之前我们团队一直在小步重构自己的这套系统（功能已兼容其他 2 套系统），而其他2套对接三方的系统重构优先级放的比较低。<br>直到有一天，业务团队说三方对接业务暂停了，借此时机我们快速推进了问诊系统重构，把 APP 端的功能统一为一个流程了。</p><p>重构过程中，我比较关注怎么为以后的开发提效：</p><ul><li>功能复用，减少重复开发</li><li>配置化，不需要开发和发版</li></ul><p><strong>重构后有什么收获？</strong></p><ul><li><p>人员更熟悉业务了<br>之前由于人员流动，部分新同学进来，加上业务文档缺失，短期没人熟悉业务，导致问题频出。重构前，会先梳理出业务文档和技术方案，有了文档沉淀。重构后，团队参与重构的同学也熟悉业务了。</p></li><li><p>历史包袱少了<br>历史代码逻辑本来就设计不合理，因为逻辑混乱再加上后续的迭代修改，没人看得懂也没人敢优化逻辑，就成了一堆祖传代码（屎山）。后续修改维护都需要花大量时间梳理逻辑找到需要修改的点，另任何修改都需要测试全面覆盖用例。</p></li><li><p>系统更合理更可扩展了<br>举一个例子，诊室 IM 按钮的配置化改造后，后端可以直接配置下发。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;@&quot;,      // 按钮名称</span><br><span class="line">    &quot;menuType&quot;: 1,    // 按钮类型</span><br><span class="line">    &quot;url&quot;: &quot;&quot;,        // 按钮跳转scheme</span><br><span class="line">    &quot;apiAddress&quot;: &quot;&quot;, // 按钮点击触发接口</span><br><span class="line">    &quot;tag&quot;: null       // 按钮角标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>95% 情况的修改不需要 APP 发版。前几天，公司 CTO 觉得现在的按钮顺序不太合理，找到我想要调整一下，我当时心里窃喜，还好我们已经提前做了配置化改造，不然就要被喷了。<br>可以配置化后，很快就完成了按钮顺序调整。这件事也让我更体会到技术手段的重要性，之前 Native 开发按钮，也不是不可用，只是不够灵活，任何修改需要发版，关键时刻救不了火。</p><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>每个人都是某块业务的 Owner，协作起来比较顺畅，执行力比较强（自我感觉）。</p><h3 id="拥抱变化"><a href="#拥抱变化" class="headerlink" title="拥抱变化"></a>拥抱变化</h3><p>公司经历了几次组织架构调整，团队人员有进有出，也以开放的心态拥抱这种变化，因为唯一不变的就是变化。<br>最近一次组织架构调整，原本团队 20 人左右（包括 Native），对 APP 终端的业务功能负责。这次调整，我把 Native 交给了一个比我更合适的同事。<br>其一，我后端出身，对 Native 技术不熟悉，属于外行管内行的情况，可能由于我这方面的短视，无法提供更有建设性的意见，对这些同学的发展不利；其二，在团队内也没有找到合适的同学来补位。</p><p>但是我还是挺感谢这一段时间经历，对我来说是一个跨界，接触到了之前没关注的领域，拓展了自己的技术视野，会全局考虑技术实现方案，对后续工作也是很有帮助。<br>比如之前后端在设计技术方案的时候不会考虑 Native 这边，出现过 1 个页面需要调用 20 多个接口的情况（Native 同学咋没原则，不知道拒绝），Native 代码里也充斥着大量的业务逻辑实现。对此后续在团队里面形成规定：</p><ul><li>接口要收敛</li><li>业务逻辑收口到后端，前端只做展示和交互逻辑</li></ul><h3 id="充分信任"><a href="#充分信任" class="headerlink" title="充分信任"></a>充分信任</h3><p>相信团队的每一个人，不再觉得只有自己能做。把一些事授权给团队成员去做，对他们才会有更多成长机会。</p><ul><li>充分信任。疑人不用，用人不疑</li><li>授权指导。明确任务、时间、验收标准，以及如果是我大概会去怎么做</li><li>监督。正向反馈，即时修偏</li><li>拿结果。做得怎么样，问题复盘改进</li></ul><h3 id="寻找关键人"><a href="#寻找关键人" class="headerlink" title="寻找关键人"></a>寻找关键人</h3><p>以点带面，良币驱逐劣币。抓好团队这些关键人，让他们经历更多事情的蹂躏快速成长起来，负责更多的事，担更多的责任，避免团队因我这个单点而导致的翻车。</p><h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><h3 id="新的角色"><a href="#新的角色" class="headerlink" title="新的角色"></a>新的角色</h3><p>加入了后端技术委员会，能为团队做更多的事，面对更有挑战的一些技术难题。</p><p>以下 2 个案例都是为了解决团队发版日必过凌晨的问题，团队发布效率低导致加班严重。</p><p><strong>发布流水线</strong></p><p>微服务化之后，稍微大一点的项目发布都会有 10+ 的应用，之前全是人工手动到发布平台上一个一个应用点发布，效率低，且容易出现发布遗漏应用的情况。<br>另外如果是多个项目发布，那么就需要排队等待，后面发布的项目就遭殃了。</p><p>有段时间我深受其害，想办法解决这种情况。刚好质效部门有个同学有些想法，于是我俩来回拉扯了几次，确定了发布流水线大概功能：每个迭代需求系统自动生成发布清单，<br>多个迭代可以合并发布，支持一键部署完成代码合并和应用发布。这哥们也是给力，过了一段时间就做好上线了，当然我们部门也就成了第一个吃螃蟹的人。效果很明显，后续发布效率提高了很多。</p><p><strong>预发布环境</strong></p><p>之前工程部门已经搞过一次，但是没有落地成功。一是方案不是很合理；二是需要对接的业务团队较多，协调困难；三是没有做到开箱即用（工程部只管搭好环境，预发环境的应用还需要业务团队自己部署）。</p><p>基于之前的教训，我先是设计出整体实施方案，并得到了技术委员会的通过，然后拉上各业务线技术负责人，告知背景并需要得到资源支持（1 个人就好，小部分应用需要做一点小改造）， 最后我就拉上运维开始实施，搭建环境并批量部署应用。<br>预发环境搭建好之后，白天可以在预发环境（真实的数据一致的环境）测试验收，因为降低了发布风险所以可以提前发布生产了，后续发布到很晚的情况就更少了。</p><h3 id="时间怎么分配"><a href="#时间怎么分配" class="headerlink" title="时间怎么分配"></a>时间怎么分配</h3><p>负责的业务更多了，大部分事情都会先到我这里。可一天时间就这么多（995 又咋样），怎么办？搬出我的时间四象限：</p><p><img src="//www.fanhaobai.com/2021/12/2021-personal-summary/a2d1e849-2e1f-42a3-a054-69005e91755b.jpg" alt="预览图"></p><h2 id="明年TODO"><a href="#明年TODO" class="headerlink" title="明年TODO"></a>明年TODO</h2><ul><li>能负责 1 个新产品落地，从 0 到 1 更需要系统设计，更有挑战，也更有成就感</li><li>跟其他团队合作更多，认识更多的人，发现更多的团队问题</li><li>个人职级晋升，负责更多的事，担更多的责任（背更多的锅）</li><li>养成读书习惯，复制行业榜样的经验</li></ul><p>职场即战场，很残酷很现实，需要实力和运气，如果当前的情况左右不了，就随它去吧，先丰富自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关键词：不轴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一年信息量还是挺大，做了很多项目，但是业务产出较少（有一些外部因素），职级也未能得到晋升。经过这一年的时间沉淀，不再自以为是，以更开放的心态接受身边事物的改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2021/12/2021-personal-summary/10183cff-d8cc-4e5f-97cb-b897a256bd41.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
    
      <category term="成长" scheme="https://www.fanhaobai.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker轻松部署Hexo博客系统</title>
    <link href="https://www.fanhaobai.com/2020/12/hexo-to-docker.html"/>
    <id>https://www.fanhaobai.com/2020/12/hexo-to-docker.html</id>
    <published>2020-12-27T06:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.705Z</updated>
    
    <content type="html"><![CDATA[<p>我的 <a href="https://www.fanhaobai.com/">博客</a> 停服已经有几个月了，主要原因是使用的 <a href="https://cloud.google.com/free/">Google Cloud</a> 免费服务器已经到期了，而整个博客系统的迁移成本很大，因此迟迟没有开启服务。</p><p><img src="//www.fanhaobai.com/2020/12/hexo-to-docker/704035c6-348e-439b-9048-d05a2a18ef1f.png" alt="预览图"><span id="more"></span></p><p>这周末，终于有时间来彻底解决博客迁移问题了。通过改造 Hexo 博客系统，使其支持 Docker 部署，彻底摆脱了运行环境依赖，以后再更换云服务器厂商时，就可以做到快速平滑迁移了。</p><p>我的博客做过定制化改造，使用的是 <a href="https://github.com/fan-haobai/hexo-theme-yilia">hexo-theme-yilia</a> 作为主题，评论使用的是 <a href="https://github.com/fan-haobai/disqus-php-api">disqus-php-api</a>，支持 HTTPS 协议，因此本次改造主要涉及这些。</p><h2 id="Docker-环境"><a href="#Docker-环境" class="headerlink" title="Docker 环境"></a>Docker 环境</h2><h3 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h3><p>由于没有了 Google Cloud 的免费使用资格，只能在国内挑选较便宜的腾讯云云服务器厂商，购买了一台低配云服务器。</p><p>这台服务器的操作系统是 <a href="">CentOS</a>，我们选用 <a href="https://docs.docker.com/compose/install/">Docker Compose</a> 作为容器编排工具。</p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.删除旧的Docker版本</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.添加Docker源</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装Docker</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo yum install docker-ce-20.10.1 docker-ce-cli-20.10.1 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看Docker版本</span></span><br><span class="line">docker -v</span><br><span class="line">Docker version 20.10.1, build 831ebea</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.获取docker-compose脚本</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.增加可执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看版本</span></span><br><span class="line">docker-compose --version</span><br><span class="line">docker-compose version 1.27.4, build 40524192</span><br></pre></td></tr></table></figure><h2 id="项目改造"><a href="#项目改造" class="headerlink" title="项目改造"></a>项目改造</h2><h3 id="调整目录结构"><a href="#调整目录结构" class="headerlink" title="调整目录结构"></a>调整目录结构</h3><p>之前的目录结构较为单一，需调整项目目录结构。调整后的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── _config.yml           <span class="comment"># Hexo配置文件</span></span><br><span class="line">├── disqus                <span class="comment"># Disqus评论</span></span><br><span class="line">├── themes                <span class="comment"># Hexo主题</span></span><br><span class="line">│   └── yilia             <span class="comment"># hexo-theme-yilia主题</span></span><br><span class="line">├── <span class="built_in">source</span>                <span class="comment"># 文章.md文件</span></span><br><span class="line">├── public                <span class="comment"># Hexo发布后的静态资源文件</span></span><br><span class="line">├── dockerfiles           <span class="comment"># Dockerfile文件</span></span><br><span class="line">│   ├── nginx</span><br><span class="line">│   ├── nodejs</span><br><span class="line">│   └── php</span><br><span class="line">├── docker-compose.yml    <span class="comment"># 容器编排配置</span></span><br><span class="line">├── docker.env            <span class="comment"># Docker环境变量文件</span></span><br><span class="line">├── docker.example.env    <span class="comment"># Docker环境变量示例文件</span></span><br><span class="line">├── network-override.yml  <span class="comment"># 容器编排配置（特殊网络）</span></span><br><span class="line">└── package.json          <span class="comment"># Hexo依赖包</span></span><br></pre></td></tr></table></figure><p>其中，<code>disqus</code> 和 <code>yilia</code> 目录分别对应 <a href="https://github.com/fan-haobai/disqus-php-api">disqus-php-api</a> 和 <a href="https://github.com/fan-haobai/hexo-theme-yilia">hexo-theme-yilia</a> 这 2 个子项目，并采用 <code>submodule</code> 模式管理这些源代码。</p><blockquote><p>在 <code>submodule</code> 模式下，<code>clone</code> 和 <code>pull</code> 命令会有一些变化，分别为 <code>git clone --recursive https://github.com/fan-haobai/blog.git</code><br>和 <code>git pull &amp;&amp; git submodule foreach git pull origin master</code>。</p></blockquote><h3 id="编排容器"><a href="#编排容器" class="headerlink" title="编排容器"></a>编排容器</h3><p>本博客系统，主要依赖 <code>NodeJS</code>、<code>PHP</code>、<code>Nginx</code> 环境，因此分别构建 3 个容器。</p><h3 id="配置-docker-compose-yml"><a href="#配置-docker-compose-yml" class="headerlink" title="配置 docker-compose.yml"></a>配置 docker-compose.yml</h3><p>Docker Compose 会根据 <code>docker-compose.yml</code> 配置文件，来自动编排容器。配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    restart: always</span><br><span class="line">    build: ./dockerfiles/nginx</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment"># 博客源代码</span></span><br><span class="line">      - <span class="string">&quot;/var/www/blog:/var/www/blog&quot;</span></span><br><span class="line">      <span class="comment"># HTTPS证书</span></span><br><span class="line">      - <span class="string">&quot;/var/www/ssl/certs:/var/www/ssl/certs&quot;</span></span><br><span class="line">      <span class="comment"># Nginx配置</span></span><br><span class="line">      - <span class="string">&quot;<span class="variable">$PWD</span>/dockerfiles/nginx/conf.d:/etc/nginx/conf.d&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: /bin/bash /start.sh</span><br><span class="line">    env_file:</span><br><span class="line">      - docker.env</span><br><span class="line">    extra_hosts:</span><br><span class="line">      - <span class="string">&quot;raw.githubusercontent.com:199.232.96.133&quot;</span></span><br><span class="line">    container_name: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  nodejs:</span><br><span class="line">    build: ./dockerfiles/nodejs</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;4000:4000&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/var/www/blog:/var/www/blog&quot;</span></span><br><span class="line">    container_name: <span class="string">&quot;nodejs&quot;</span></span><br><span class="line">  php:</span><br><span class="line">    restart: always</span><br><span class="line">    build: ./dockerfiles/php</span><br><span class="line">    expose:</span><br><span class="line">      - <span class="string">&quot;9000&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/var/www/blog:/var/www/blog&quot;</span></span><br><span class="line">    container_name: <span class="string">&quot;php&quot;</span></span><br></pre></td></tr></table></figure><p>其中，<code>services</code> 下为需要编排的 <code>nodejs</code>、<code>php</code>、<code>nginx</code> 容器服务。每个容器服务都可以灵活配置，常见的配置参数如下：</p><ul><li>restart：容器退出时，是否重启</li><li>build：构建容器 Dockerfile 文件所在的目录</li><li>ports：映射端口</li><li>volumes：挂载目录</li><li>command：容器启动后执行的命令</li><li>env_file：环境变量文件</li><li>extra_hosts：域名IP映射</li><li>container_name：容器名称</li></ul><blockquote><p>Docker Compose 支持多配置文件，且为覆盖关系。因此将 <code>ssl-override.yml</code> 作为获取 HTTPS 证书时启动容器的配置文件。</p></blockquote><h3 id="配置-docker-env"><a href="#配置-docker-env" class="headerlink" title="配置 docker.env"></a>配置 docker.env</h3><p>环境变量统一配置在 <code>docker.env</code> 文件中，并增加示例环境文件 <code>docker.example.env</code>。环境变量目前较少，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否启用HTTPS证书</span></span><br><span class="line">ENABLE_SSL=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持HTTPS协议的域名</span></span><br><span class="line">SSL_DOMAINS=fanhaobai.com,www.fanhaobai.com</span><br></pre></td></tr></table></figure><h3 id="构建-Dockerfile"><a href="#构建-Dockerfile" class="headerlink" title="构建 Dockerfile"></a>构建 Dockerfile</h3><p>Dockerfile 文件统一放在 <code>dockerfiles</code> 目录下，并分别建立 <code>nodejs</code>、<code>php</code>、<code>nginx</code> 文件夹。</p><h4 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h4><p>该容器下需要安装 <code>git</code>、<code>npm</code>。Dockerfile 文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node:12-alpine</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;https://mirrors.ustc.edu.cn/alpine/v3.9/main/&quot;</span> &gt; /etc/apk/repositories  \</span><br><span class="line">    &amp;&amp; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org \</span><br><span class="line">    &amp;&amp; apk add --no-cache git \</span><br><span class="line">    &amp;&amp; npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">ADD *.sh /</span><br><span class="line">RUN <span class="built_in">chmod</span> 777 /*.sh</span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;/start.sh&quot;</span>]</span><br></pre></td></tr></table></figure><p>其中，<code>start.sh</code> 为容器的启动脚本，主要作用为生成静态资源文件。内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/www/blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新代码</span></span><br><span class="line">git pull &amp;&amp; git submodule foreach git pull origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态资源</span></span><br><span class="line">npm install --force</span><br><span class="line"><span class="comment"># hexo clean</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>该容器基于官方的基础镜像，安装一些必要的扩展。Dockerfile 文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM php:7.3.7-fpm-alpine3.9</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;https://mirrors.aliyun.com/alpine/v3.9/main/&#x27;</span> &gt; /etc/apk/repositories &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;https://mirrors.aliyun.com/alpine/v3.9/community/&#x27;</span> &gt;&gt; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装扩展</span></span><br><span class="line">RUN apk add --no-cache <span class="variable">$PHPIZE_DEPS</span> \</span><br><span class="line">    &amp;&amp; apk add --no-cache libstdc++ libzip-dev vim\</span><br><span class="line">    &amp;&amp; apk update \</span><br><span class="line">    &amp;&amp; apk del <span class="variable">$PHPIZE_DEPS</span></span><br><span class="line">RUN apk add --no-cache freetype libpng libjpeg-turbo freetype-dev libpng-dev libjpeg-turbo-dev \</span><br><span class="line">    &amp;&amp; apk update \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ --with-png-dir=/usr/include/ \</span><br><span class="line">    &amp;&amp; docker-php-ext-install -j$(<span class="built_in">nproc</span>) gd \</span><br><span class="line">    &amp;&amp; docker-php-ext-install -j$(<span class="built_in">nproc</span>) opcache \</span><br><span class="line">    &amp;&amp; docker-php-ext-install -j$(<span class="built_in">nproc</span>) bcmath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">RUN <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$PHP_INI_DIR</span>/php.ini-production&quot;</span> <span class="string">&quot;<span class="variable">$PHP_INI_DIR</span>/php.ini&quot;</span></span><br><span class="line">ADD conf.d/* <span class="variable">$PHP_INI_DIR</span>/conf.d/</span><br></pre></td></tr></table></figure><p>其中，<code>conf.d</code> 下为 <code>php</code> 的配置文件。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ul><li>Dockerfile 文件</li></ul><p>该容器基于官方的基础镜像，并安装 <code>cron</code>、<code>wget</code>、<code>python</code>。Dockerfile 文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cron等</span></span><br><span class="line">RUN sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list \</span><br><span class="line">    &amp;&amp; apt-get update &amp;&amp; apt-get install -y cron wget python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动脚本和配置</span></span><br><span class="line">ADD *.sh /</span><br><span class="line">ADD nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTPS证书生成脚本</span></span><br><span class="line">ADD ssl/* /var/www/ssl/</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /var/www/ssl/*.sh</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">chmod</span> 777 -R /var/log/nginx</span><br></pre></td></tr></table></figure><p>其中，<code>conf.d</code> 下为 <code>nginx</code> 的配置文件，<code>ssl</code> 下为 HTTPS 证书的生成脚本。</p><ul><li>HTTPS 证书生成脚本</li></ul><p><code>ssl</code> 下的 <code>init_ssl.sh</code> 为首次获取 HTTPS 证书脚本，<code>refresh_cert.sh</code> 为更新 HTTPS 证书脚本。</p><p>其中，<code>init_ssl.sh</code> 脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Stoping nginx ...&quot;</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Starting nginx ...&quot;</span></span><br><span class="line">docker-compose -f docker-compose.yml -f ssl-override.yml up --force-recreate --build -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启动完成</span></span><br><span class="line"><span class="keyword">until</span> [ <span class="string">&quot;`docker inspect -f &#123;&#123;.State.Running&#125;&#125; nginx`&quot;</span>==<span class="string">&quot;true&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;### Wait nginx docker start ...&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 0.1;</span><br><span class="line"><span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成HTTPS证书</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Gen nginx ssl ...&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> nginx /bin/bash /var/www/ssl/refresh_cert.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启nginx</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Restart nginx ...&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> nginx nginx -s reload</span><br></pre></td></tr></table></figure><blockquote><p><code>ssl-override.yml</code> 会覆盖 <code>docker-compose.yml</code> 中的环境变量，因此会将环境变量 <code>ENABLE_SSL</code> 设置为 <code>false</code>，并将 <code>php</code> 解析到 <code>127.0.0.1</code>，以确保 <code>nginx</code> 容器在首次能成功启动。 </p></blockquote><p>而 <code>refresh_cert.sh</code> 脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span>=<span class="string">&#x27;/var/www/ssl&#x27;</span></span><br><span class="line">certs_dir=<span class="string">&quot;<span class="variable">$dir</span>/certs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$certs_dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$certs_dir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$SSL_DOMAINS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;### Domains is empty&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Starting ssl ...&quot;</span></span><br><span class="line"></span><br><span class="line">openssl genrsa 4096 &gt; account.key</span><br><span class="line">openssl genrsa 4096 &gt; domain.key</span><br><span class="line"></span><br><span class="line">domains=`<span class="built_in">echo</span> <span class="string">&quot;DNS:<span class="variable">$SSL_DOMAINS</span>&quot;</span> | sed <span class="string">&#x27;s/,/&amp;DNS:/g&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Gen domain key, domains: <span class="variable">$domains</span> ...&quot;</span></span><br><span class="line">openssl req -new -sha256 -key domain.key -subj <span class="string">&quot;/&quot;</span> -reqexts SAN -config \</span><br><span class="line">    &lt;(<span class="built_in">cat</span> /etc/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">&quot;[SAN]\nsubjectAltName=<span class="variable">$domains</span>&quot;</span>)) &gt; domain.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Download acme_tiny script ...&quot;</span></span><br><span class="line">wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py -O acme_tiny.py</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### Gen chained cert ...&quot;</span></span><br><span class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir <span class="variable">$dir</span>/challenges/ &gt; signed.crt || <span class="built_in">exit</span></span><br><span class="line">openssl dhparam -out dhparams.pem 2048</span><br><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span><br><span class="line"><span class="built_in">cat</span> signed.crt intermediate.pem &gt; chained.pem</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;### End ssl ...&quot;</span></span><br></pre></td></tr></table></figure><p>其中，<code>SSL_DOMAINS</code> 为环境变量文件 <code>docker.env</code> 中配置需要支持 HTTPS 的域名。</p><ul><li>容器启动脚本</li></ul><p>在该容器启动后，会执行 <code>start.sh</code> 脚本。其内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span>=<span class="string">&quot;/var/www/ssl&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$dir</span>/challenges&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用HTTPS</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ENABLE_SSL</span>&quot;</span> = <span class="string">&quot;false&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改nginx配置, 不启用HTTPS</span></span><br><span class="line">    sed -i <span class="string">&#x27;/https/d&#x27;</span> /etc/nginx/nginx.conf</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每2个月更新一次, 并重启nginx容器</span></span><br><span class="line">    ssl_cron=<span class="string">&quot;0 0 1 */2 * <span class="variable">$dir</span>/refresh_cert.sh &amp;&amp; nginx -s reload 2&gt;&gt; /var/log/acme_tiny.log&quot;</span></span><br><span class="line">    crontab -l | &#123; <span class="built_in">cat</span>; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ssl_cron</span>&quot;</span>; &#125; | crontab -</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">nginx -g <span class="string">&quot;daemon off;&quot;</span></span><br></pre></td></tr></table></figure><p>其中需要注意，当不启用 HTTPS 协议时，需要将 Nginx 配置修改为不启用 HTTPS；而启用时，会添加每 2 个月重新生成证书的定时任务。<code>nginx</code> 也需要改为前台启动模式，否则容器会因没有前台程序而自动退出。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>前面的一切都准备就绪后，部署就异常简单了，后续再迁移时，也只需要简单做部署这一步就好了。</p><ul><li>配置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> docker.example.env docker.env</span><br></pre></td></tr></table></figure><ul><li>获取HTTPS证书</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash dockerfiles/nginx/ssl/init_ssl.sh</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果无需支持HTTPS协议，则跳过此步骤，并将环境变量 <code>ENABLE_SSL</code> 修改为 <code>false</code>。</p></blockquote><ul><li>启动所有容器</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up --force-recreate --build -d</span><br></pre></td></tr></table></figure><p>如果一切顺利，那么运行 <code>docker ps -a</code> 命令就能看到已成功启动的容器，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED      STATUS      PORTS                    NAMES</span><br><span class="line">b0307bac08d7   blog_nodejs   <span class="string">&quot;sh /start.sh&quot;</span>           2 days ago   Up 2 days   0.0.0.0:4000-&gt;4000/tcp   nodejs</span><br><span class="line">e8ef7a1e9271   blog_nginx    <span class="string">&quot;/docker-entrypoint.…&quot;</span>   2 days ago   Up 2 days   0.0.0.0:80-&gt;80/tcp       nginx</span><br><span class="line">af7baad788c5   blog_php      <span class="string">&quot;docker-php-entrypoi…&quot;</span>   2 days ago   Up 2 days   9000/tcp                 php</span><br></pre></td></tr></table></figure><p>通过 <a href="https://www.fanhaobai.com/">www.fanhaobai.com</a> 域名也可以直接访问到本站了。</p><blockquote><p>使用 <a href="https://github.com/sigoden/webhook">webhook-cli</a> 工具可以支持代码自动部署，详细见 <a href="https://www.fanhaobai.com/2018/03/hexo-deploy.html">我的博客发布上线方案 — Hexo</a>。</p></blockquote><p><strong>更新 <a href="#">»</a></strong></p><ul><li><a href="https://github.com/fan-haobai/disqus-php-api">disqus-php-api</a> 已替换为开源的 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a>，无需再单独部署。</li><li>博客源码 <a href="https://github.com/howborn/blog">howborn/blog</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的 &lt;a href=&quot;https://www.fanhaobai.com/&quot;&gt;博客&lt;/a&gt; 停服已经有几个月了，主要原因是使用的 &lt;a href=&quot;https://cloud.google.com/free/&quot;&gt;Google Cloud&lt;/a&gt; 免费服务器已经到期了，而整个博客系统的迁移成本很大，因此迟迟没有开启服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2020/12/hexo-to-docker/704035c6-348e-439b-9048-d05a2a18ef1f.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="工具" scheme="https://www.fanhaobai.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>自建一个简易的OpenAPI网关</title>
    <link href="https://www.fanhaobai.com/2020/07/openapi.html"/>
    <id>https://www.fanhaobai.com/2020/07/openapi.html</id>
    <published>2020-07-15T11:30:00.000Z</published>
    <updated>2024-04-18T08:38:12.700Z</updated>
    
    <content type="html"><![CDATA[<p>网关（API Gateway）是请求流量的唯一入口，可以适配各类渠道和业务，处理各种协议接入、路由与报文转换、同步异步调用等，来管理 API 接口和进行请求流量控制，在微服务架构中，网关尤为重要。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/ffc6e25d-7044-467d-8b7c-910831249968.jpeg" alt="预览图"><span id="more"></span></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当然，现在已有很多开源软件，如 <a href="https://github.com/Kong/kong">Kong</a>、<a href="https://gravitee.io/">Gravitee</a>、<a href="https://github.com/Netflix/zuul">Zuul</a>。</p><p>这些开源网关固然功能齐全，但对于我们业务来说，有点太重了，我们有部分定制化需求，为此我们自建了一个轻量级的 OpenAPI 网关，主要供第三方渠道对接使用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><h4 id="接口鉴权"><a href="#接口鉴权" class="headerlink" title="接口鉴权"></a>接口鉴权</h4><ul><li>请求 5s 自动过期</li><li>参数 md5 签名</li><li>模块粒度的权限控制</li></ul><h4 id="接口版本控制"><a href="#接口版本控制" class="headerlink" title="接口版本控制"></a>接口版本控制</h4><ul><li>支持转发到不同服务</li><li>支持转发到同一个服务不同接口</li></ul><h4 id="事件回调"><a href="#事件回调" class="headerlink" title="事件回调"></a>事件回调</h4><ul><li>事件订阅</li><li>最大重试 3 次</li><li>重试时间采用衰减策略（30s、60s、180s）</li></ul><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>从第三方请求 API 链路来说，第三方渠道通过 HTTP 协议请求 OpenAPI 网关，网关再将请求转发到对应的内部服务端口，这些端口层通过 gRPC 调用请求到服务层，处理完请求后依次返回。</p><p>从事件回调请求链路来说，服务层通过 HTTP 协议发起事件回调请求到 OpenAPI 网关，并立即返回成功。OpenAPI 网关异步完成第三方渠道事件回调请求。 </p><p><img src="//www.fanhaobai.com/2020/07/openapi/f227c462-b9b9-4846-aeae-23c579b05087.jpeg" alt="系统架构"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="网关配置"><a href="#网关配置" class="headerlink" title="网关配置"></a>网关配置</h3><p>由于网关存在内部服务和第三方渠道配置，更为了实现配置的热更新，我们采用了 ETCD 存储配置，存储格式为 JSON。</p><h4 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h4><p>配置分为以下 3 类：</p><ul><li>第三方 AppId 配置</li><li>内外 API 映射关系</li><li>内部服务地址</li></ul><h4 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h4><p>a、第三方 AppId 配置</p><p><img src="//www.fanhaobai.com/2020/07/openapi/9655aec3-aa6c-4353-819e-a095a0fdd5bf.png" alt="AppId配置"></p><p>b、内部服务地址</p><p><img src="//www.fanhaobai.com/2020/07/openapi/48e89e9b-eede-4aec-b98f-ce50cc112c99.png" alt="内部服务地址"></p><p>c、内外 API 映射关系</p><p><img src="//www.fanhaobai.com/2020/07/openapi/676dcc84-628d-493c-8ab6-c9f2ec3053df.png" alt="API映射关系"></p><h4 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h4><p>利用 ETCD 的 watch 监听，可以轻易实现配置的热更新。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/549e72de-cdbd-4b8d-a238-085f226d7555.jpg" alt="配置热更新"></p><p>当然也还是需要主动拉取配置的情况，如重启服务的时候。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/ae062ec1-7f3c-4535-916b-c9cd08734a7d.jpg" alt="拉取热更新"></p><h3 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h3><p>第三方调用 API 接口的时序，大致如下：</p><p><img src="//www.fanhaobai.com/2020/07/openapi/a4768e8e-f961-4270-ba9d-69d2a317d49b.png" alt="API调用时序"></p><h4 id="参数格式"><a href="#参数格式" class="headerlink" title="参数格式"></a>参数格式</h4><p>为了简化对接流程，我们统一了 API 接口的请求参数格式。请求方式支持 POST 或者 GET。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/d0131310-b7f8-4deb-aa9e-fcc6b28a47a2.png" alt="API调用时序"></p><h4 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h4><p>签名采用 md5 加密方式，算法可描述为：</p><p>1、将参数 p、m、a、t、v、ak、secret 的值按顺序拼接，得到字符串；<br>2、md5 第 1 步的字符串并截取前 16 位， 得到新字符串；<br>3、将第 2 步的字符串转化为小写，即为签名；</p><p>PHP 版的请求，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$appId</span> = <span class="string">&#x27;app id&#x27;</span>;</span><br><span class="line"><span class="variable">$appSecret</span> = <span class="string">&#x27;app secret&#x27;</span>;</span><br><span class="line"><span class="variable">$api</span> = <span class="string">&#x27;api method&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务参数</span></span><br><span class="line"><span class="variable">$businessParams</span> = [</span><br><span class="line">  <span class="string">&#x27;orderId&#x27;</span> =&gt; <span class="string">&#x27;123123132&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$time</span> = <span class="title function_ invoke__">time</span>();</span><br><span class="line"><span class="variable">$params</span> = [</span><br><span class="line">  <span class="string">&#x27;p&#x27;</span>  =&gt; <span class="title function_ invoke__">json_encode</span>(<span class="variable">$businessParams</span>),</span><br><span class="line">  <span class="string">&#x27;m&#x27;</span>  =&gt; <span class="string">&#x27;inquiry&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>  =&gt; <span class="variable">$api</span>,</span><br><span class="line">  <span class="string">&#x27;t&#x27;</span>  =&gt; <span class="variable">$time</span>,</span><br><span class="line">  <span class="string">&#x27;v&#x27;</span>  =&gt; <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;ak&#x27;</span> =&gt; <span class="variable">$appId</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$signStr</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">array_values</span>(<span class="variable">$params</span>)) . <span class="variable">$appSecret</span>;</span><br><span class="line"><span class="variable">$sign</span> = <span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$signStr</span>), <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$params</span>[<span class="string">&#x27;s&#x27;</span>] = <span class="variable">$sign</span>;</span><br></pre></td></tr></table></figure><h4 id="接口版本控制-1"><a href="#接口版本控制-1" class="headerlink" title="接口版本控制"></a>接口版本控制</h4><p>不同的接口版本，可以转发请求到不同的服务，或同一个服务的不同接口。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/c6987388-682d-403f-8621-caa1fa6cd266.png" alt="接口版本控制"></p><h3 id="事件回调-1"><a href="#事件回调-1" class="headerlink" title="事件回调"></a>事件回调</h3><p>通过事件回调机制，第三方可以订阅自己关注的事件。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/4b6660db-0e0c-4c6d-9716-0e63820f45e1.png" alt="接口版本控制"></p><h2 id="对接接入"><a href="#对接接入" class="headerlink" title="对接接入"></a>对接接入</h2><h3 id="渠道接入"><a href="#渠道接入" class="headerlink" title="渠道接入"></a>渠道接入</h3><p>只需要配置第三方 AppId 信息，包括 secret、回调地址、模块权限。</p><p><img src="//www.fanhaobai.com/2020/07/openapi/3321e082-1857-4c2b-8d19-a60334f9b4f5.png" alt="渠道AppId配置"></p><p>即，需要在 ETCD 执行如下操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl <span class="built_in">set</span> /openapi/app/baidu <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;Id&quot;: &quot;baidu&quot;,</span></span><br><span class="line"><span class="string">    &quot;Secret&quot;: &quot;00cf2dcbf8fb6e73bc8de50a8c64880f&quot;,</span></span><br><span class="line"><span class="string">    &quot;Modules&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;inquiry&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;module&quot;: &quot;inquiry&quot;,</span></span><br><span class="line"><span class="string">            &quot;CallBack&quot;: &quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="服务接入"><a href="#服务接入" class="headerlink" title="服务接入"></a>服务接入</h3><p>a、配置内部服务地址</p><p><img src="//www.fanhaobai.com/2020/07/openapi/1a902abb-fb35-42e1-9f3a-c18e12074f11.png" alt="配置内部服务地址"></p><p>即，需要在 ETCD 执行如下操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl <span class="built_in">set</span> /openapi/backend/form_openapi <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;type&quot;: &quot;form&quot;,</span></span><br><span class="line"><span class="string">    &quot;Url&quot;: &quot;http://med-ih-openapi.app.svc.cluster.local&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>b、配置内外 API 映射关系</p><p><img src="//www.fanhaobai.com/2020/07/openapi/39befe95-381e-47ad-879d-e5433e778078.png" alt="配置内部服务地址"></p><p>同样，需要在 ETCD 执行如下操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ etcdctl <span class="built_in">set</span> /openapi/api/inquiry/createMedicine.v2 <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;Module&quot;: &quot;inquiry&quot;,</span></span><br><span class="line"><span class="string">    &quot;Method&quot;: &quot;createMedicine&quot;,</span></span><br><span class="line"><span class="string">    &quot;Backend&quot;: &quot;form_openapi&quot;,</span></span><br><span class="line"><span class="string">    &quot;ApiParams&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;path&quot;: &quot;inquiry/medicine-clinic/create&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>c、接入事件回调</p><p>接入服务也需要按照第三方接入方式，并申请 AppId。回调业务参数约定为：</p><p><img src="//www.fanhaobai.com/2020/07/openapi/ba4a385e-add6-40fe-aa30-40866f8e4f40.png" alt="配置内部服务地址"></p><p>Golang 版本的接入，如下：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">AppId = <span class="string">&quot;__inquiry&quot;</span></span><br><span class="line">AppSecret = <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">Version = <span class="string">&quot;1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CallbackReq <span class="keyword">struct</span> &#123;</span><br><span class="line">TargetAppId <span class="type">string</span>                 <span class="comment">//目标APP Id</span></span><br><span class="line">Module      <span class="type">string</span>                 <span class="comment">//目标模块</span></span><br><span class="line">Event       <span class="type">string</span>                 <span class="comment">//事件</span></span><br><span class="line">Params      <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">//参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateData</span><span class="params">(req CallbackReq)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    params, _ := json.Marshal(req.Params)</span><br><span class="line">p := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;ak&quot;</span>: req.TargetAppId,</span><br><span class="line"><span class="string">&quot;m&quot;</span>:  req.Module,</span><br><span class="line"><span class="string">&quot;e&quot;</span>:  req.Event,</span><br><span class="line"><span class="string">&quot;p&quot;</span>:  <span class="type">string</span>(params),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pStr, _ := json.Marshal(p)</span><br><span class="line">postParams := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;p&quot;</span>:  <span class="type">string</span>(pStr),</span><br><span class="line"><span class="string">&quot;m&quot;</span>:  <span class="string">&quot;callback&quot;</span>,</span><br><span class="line"><span class="string">&quot;a&quot;</span>:  <span class="string">&quot;callback&quot;</span>,</span><br><span class="line"><span class="string">&quot;t&quot;</span>:  fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, time.Now().Unix()),</span><br><span class="line"><span class="string">&quot;v&quot;</span>:  Version,</span><br><span class="line"><span class="string">&quot;ak&quot;</span>: AppId,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postParams[<span class="string">&quot;s&quot;</span>] = sign(getSignData(postParams) + AppSecret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> postParams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSignData</span><span class="params">(params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Join([]<span class="type">string</span>&#123;params[<span class="string">&quot;p&quot;</span>], params[<span class="string">&quot;m&quot;</span>], params[<span class="string">&quot;a&quot;</span>], params[<span class="string">&quot;t&quot;</span>], params[<span class="string">&quot;v&quot;</span>], params[<span class="string">&quot;ak&quot;</span>]&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.ToLower(utils.Md5(str)[<span class="number">0</span>:<span class="number">16</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><ul><li>后台支持配置 AppId</li><li>事件回调失败请求支持手动重试</li><li>请求限流</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网关（API Gateway）是请求流量的唯一入口，可以适配各类渠道和业务，处理各种协议接入、路由与报文转换、同步异步调用等，来管理 API 接口和进行请求流量控制，在微服务架构中，网关尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2020/07/openapi/ffc6e25d-7044-467d-8b7c-910831249968.jpeg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Go" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/Go/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>在分布式系统使用Kafka</title>
    <link href="https://www.fanhaobai.com/2020/05/use-kafka.html"/>
    <id>https://www.fanhaobai.com/2020/05/use-kafka.html</id>
    <published>2020-05-12T04:30:00.000Z</published>
    <updated>2024-04-18T08:38:12.698Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，常常使用消息系统进行系统解耦，并实现一些异步业务逻辑，保证系统最终数据一致性。这里主要介绍在实际中落地使用 Kafka 的一些事项。</p><p><img src="//www.fanhaobai.com/2020/05/use-kafka/1589262505081.png" alt="预览图"><span id="more"></span></p><h2 id="消息TOPIC"><a href="#消息TOPIC" class="headerlink" title="消息TOPIC"></a>消息TOPIC</h2><p>根据不同业务，拆分不同的 Topic。</p><h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><h3 id="格式定义"><a href="#格式定义" class="headerlink" title="格式定义"></a>格式定义</h3><p>推送至 Kafka 的消息统一使用 JSON 结构，数据如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/StatusEvent&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XXXXXXXXXX&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>消息结构定义为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息事件数据</span></span><br><span class="line"><span class="keyword">type</span> PbEventMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 事件数据类型：包/结构体名</span></span><br><span class="line">   Type <span class="type">string</span></span><br><span class="line">   <span class="comment">// 事件数据</span></span><br><span class="line">   Data []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>Type</code> 为消息类型，<code>Type</code> 为消息事件的 PB 结构体名称；<code>Data</code> 为 PB 协议的事件数据，见下文。</p><blockquote><p>由于 PB 只序列化字段类型和顺序，因此同一个 PB 数据流在反序列化时，存在多个类型消息事件解释。而同一个 Topic 会存在多个类型消息事件，只通过 PB 并不能区分消息，因此引入 Type 用来区分不同类型消息。</p></blockquote><h3 id="事件数据"><a href="#事件数据" class="headerlink" title="事件数据"></a>事件数据</h3><p>例如，当业务订单状态发生扭转时，会产生订单状态事件消息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">订单状态</span><br><span class="line">message StatusEvent &#123;</span><br><span class="line">    // 订单transNo</span><br><span class="line">    uint64 trans_no = 1;</span><br><span class="line">    // 状态</span><br><span class="line">    uint32 status = 2;</span><br><span class="line">    // 扩展数据</span><br><span class="line">    string ext = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务消费"><a href="#业务消费" class="headerlink" title="业务消费"></a>业务消费</h2><p>通过消费 Kafka 消息，实现部分业务逻辑。在实现 Consume 时，需要注意以下几个事项：</p><p>1、原则上保持职责单一原则</p><p>即不同的业务逻辑要拆分到不同的 Consume 实现。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume PaySms</span></span><br><span class="line"><span class="comment">// 支付短信提醒</span></span><br><span class="line"><span class="keyword">type</span> PaySms <span class="keyword">struct</span> &#123;</span><br><span class="line">   handler.Base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h PaySms)</span></span> Handle(msg *cevent.PbEventMessagee) <span class="type">error</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume PayWx</span></span><br><span class="line"><span class="comment">// 支付公众号消息通知</span></span><br><span class="line"><span class="keyword">type</span> PayWx <span class="keyword">struct</span> &#123;</span><br><span class="line">   handler.Base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h PayWx)</span></span> Handle(msg *cevent.PbEventMessage) <span class="type">error</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、只消费自己关注的 Type 类型消息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume PaySms</span></span><br><span class="line"><span class="keyword">type</span> PaySms <span class="keyword">struct</span> &#123;</span><br><span class="line">   handler.Base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h PaySms)</span></span> Handle(msg *cevent.PbEventMessage) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">       event = <span class="built_in">new</span>(StatusEvent)</span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 只消费自己关注的 Type 类型消息</span></span><br><span class="line">   <span class="keyword">if</span> !msg.Unmarshal(event, msg) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件数据消息</span></span><br><span class="line"><span class="keyword">type</span> PbEventMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 事件数据类型：包/结构体名</span></span><br><span class="line">   Type <span class="type">string</span></span><br><span class="line">   <span class="comment">// 事件数据</span></span><br><span class="line">   Data []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msg PbEventMessage)</span></span> Unmarshal(event PbEvent) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">// 事件数据类型校验</span></span><br><span class="line">   t := utils.FullTypeNameOf(event)</span><br><span class="line">   <span class="keyword">if</span> msg.Type != t &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;type %s cannot be converted to %s&quot;</span>, msg.Type, t)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 数据解码</span></span><br><span class="line">   err := event.XXX_Unmarshal(msg.Data)</span><br><span class="line">   <span class="keyword">if</span> <span class="literal">nil</span> != err &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、消费异常重试机制</p><p>消息消费采用 <a href="">至少一次</a> 的消费语义，即 先消费后保存读取偏移量。若消费失败，则不更新读取偏移量，会继续消费该失败消息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 ConsumerGroupHandler 接口</span></span><br><span class="line"><span class="keyword">type</span> defaultConsumer <span class="keyword">struct</span> &#123;</span><br><span class="line">   handler cevent.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *defaultConsumer)</span></span> Setup(sarama.ConsumerGroupSession) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *defaultConsumer)</span></span> Cleanup(sarama.ConsumerGroupSession) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumeClaim must start a consumer loop of ConsumerGroupClaim&#x27;s Messages().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *defaultConsumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> msg := <span class="keyword">range</span> claim.Messages() &#123;</span><br><span class="line">      c.logger.Debugf(</span><br><span class="line">         <span class="string">&quot;message topic[%q] timestamp[%v] partition[%d] offset[%d]&quot;</span>,</span><br><span class="line">         msg.Topic, msg.Timestamp, msg.Partition, msg.Offset,</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析消息</span></span><br><span class="line">      pbMsg := &amp;cevent.PbEventMessage&#123;&#125;</span><br><span class="line">      err := json.Unmarshal(msg.Value, pbMsg)</span><br><span class="line">      <span class="keyword">if</span> <span class="literal">nil</span> != err &#123;</span><br><span class="line">           <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;msg unmarshal failed&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 消费逻辑，失败返回错误</span></span><br><span class="line">      <span class="keyword">if</span> err := c.handler(pbMsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">           c.logger.Info(fmt.Sprintf(<span class="string">&quot;event handle failed, data: %s, err: %s&quot;</span>, msg.Value, err))</span><br><span class="line">           <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;event handle failed，data: %s&quot;</span>, msg.Value)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 成功，更新偏移量标记该消息已被消费过</span></span><br><span class="line">      session.MarkMessage(msg, <span class="string">&quot;&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <a href="">至少一次</a> 消费语义，会导致消息重复消费，因此消费逻辑需要做幂等处理。</p><p>4、不同业务逻辑的 Consume 应该使用不同的 Group</p><p>一是，为了减少不同业务逻辑失败时之间的相互影响；二是，同一个消息在同一个 Group 的 Consume，只会被消费一次，否则存在部分 Consume 丢失消息的情况。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">consume.Listen(<span class="string">&quot;order-pay-sms&quot;</span>, message.PaySms&#123;&#125;.Handle)</span><br><span class="line">consume.Listen(<span class="string">&quot;order-pay-wx&quot;</span>, message.PayWx&#123;&#125;.Handle)</span><br></pre></td></tr></table></figure><h2 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h2><p>为了保持最终数据一致性，消息在生产和消费时都做了重试机制。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>1、推送失败重试机制</p><p>投递消息使用同步应答模式，当消息推送失败时，这里才用 <a href="">最大努力尝试</a> 策略保持数据最终一致性。</p><p><img src="//www.fanhaobai.com/2020/05/use-kafka/1589251986346.png" alt="推送失败重试机制"></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>2、消费异常重试机制</p><p><img src="//www.fanhaobai.com/2020/05/use-kafka/1589258896838.jpg" alt="消费异常重试机制"></p><blockquote><p>特别注意需要处理脏数据，防止因为错误数据导致消费阻塞。</p></blockquote><p>3、只消费自己关注的 Type 类型消息</p><p><img src="//www.fanhaobai.com/2020/05/use-kafka/1589258912991.jpg" alt="关注只关注Type类型消息"></p><p>具体实现，见 <a href="#%E4%B8%9A%E5%8A%A1%E6%B6%88%E8%B4%B9">业务消费</a> 部分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在分布式系统中引入消息系统，使得各系统可以只关注自己的业务逻辑，系统维护性更强，同时能极大的提高系统的稳定性。但是由于具有异步特性，存在一定的使用场景限制，对于实时响应的系统，还是建议直接使用 RPC 调用完成交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，常常使用消息系统进行系统解耦，并实现一些异步业务逻辑，保证系统最终数据一致性。这里主要介绍在实际中落地使用 Kafka 的一些事项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2020/05/use-kafka/1589262505081.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Go" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/Go/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>商品价格的多币种方案</title>
    <link href="https://www.fanhaobai.com/2019/02/multi-currency-price.html"/>
    <id>https://www.fanhaobai.com/2019/02/multi-currency-price.html</id>
    <published>2019-02-28T05:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.697Z</updated>
    
    <content type="html"><![CDATA[<p>假若，你是某个国内电商平台的商品中心项目负责人。突然今天，接到了一个这样的需求：商品在原人民币价格的基础架构上，须支持卢比（印度）价格。</p><p><img src="//www.fanhaobai.com/2019/02/multi-currency-price/434ddc25-3b51-4753-b5d5-b765ac5ca30c.jpg" alt="预览图"><span id="more"></span></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需求点，可以描述为：</p><ul><li>购买的用户，商品价格需要支持卢比；</li><li>营运人员，商品管理系统依然使用人民币价格；</li></ul><p>同样这个需求，定了以下两个硬指标：</p><ul><li>必须实现需求；</li><li>必须快速上线；</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我们必须承认的是，这确实是个简单的需求，但这也是个够坑爹的需求。主要遇到的问题如下：</p><ul><li>涉及商品价格的系统众多；</li><li>各上层系统调用商品价格接口繁多；</li><li>商品价格相关字段较多；</li></ul><p>为了实现快速上线，我们在原人民币的商品价格基础架构上，只能进行少量且合适的改造。所以，最后我们的改造方向为：尽量只改造商品价格源头系统，即商品中心，其他上层系统尽量不改动。</p><h2 id="可行性调研"><a href="#可行性调研" class="headerlink" title="可行性调研"></a>可行性调研</h2><p>改造商品中心，商品价格支持卢比。可行的改造方案有 2 种：</p><p>1、数据表价格字段存卢比</p><p>将原人民币价格相关的数据表字段，存卢比值，数据表并新增人民币字段。</p><p>2、接口输出数据时转化为卢比</p><p>原人民币相关的数据表字段依然存人民币值，在接口输出数据时，将价格相关字段值转化为卢比。</p><p>针对以上方案，我们需要注意 2 个问题：</p><ul><li>汇率会每天变化，所以商品价格也会变化；</li><li>后续商品价格，可能须支持多币种；</li></ul><p>上述 <a href="#">方案 ①</a>，商品中心只需改造数据表。然后每天根据汇率刷新商品价格，原价格字段就都变成了卢比。方案相对简单，也容易操作，但缺点是：对任然需要人民币价格的系统，即商品管理系统须改造。<br><a href="#">方案 ②</a>，需要改造商品中心业务逻辑。由于涉及的价格字段较多，改造较复杂，主要优点是：汇率变动对商品价格影响较小，且可拓展支持多币种价格（可以根据地区标识，获取相应的商品价格）。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终，为了系统的可扩展性，我们选择了方案 ②。</p><p><img src="//www.fanhaobai.com/2019/02/multi-currency-price/b5c63729-fd94-4f3b-b107-1b345d26c1c6.png" alt="解决方案"></p><p>这里主要改造了商品中心，主要解决 <a href="#%E9%80%8F%E4%BC%A0%E5%9C%B0%E5%8C%BA%E6%A0%87%E8%AF%86">透传地区标识</a> 和 <a href="#%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B8%81%E7%A7%8D%E4%BB%B7%E6%A0%BC">支持多币种价格</a> 这 2 个问题。</p><h3 id="透传地区标识"><a href="#透传地区标识" class="headerlink" title="透传地区标识"></a>透传地区标识</h3><p>我们的业务系统主要分为 API 和 Service 项目，API 暴露出 HTTP 接口，API 与 Service 和 Service 与 Service 之前使用 RPC 接口通信。由于商品中心涉及到价格的接口繁多，不可能对每个接口都增加地区标识的参数。所以我们弄了一套调用链路透传地区标识的机制。</p><h4 id="机制原理"><a href="#机制原理" class="headerlink" title="机制原理"></a>机制原理</h4><p>思路就是，先将地区标识放在全局上下文中，API 接口通过 Header 头<code>X-Location</code>携带地区标识；而对于 RPC 接口，我们的 RPC 框架已支持了 Context，不需要改造。</p><p><img src="//www.fanhaobai.com/2019/02/multi-currency-price/4ff6ceb3-44c9-4edf-bfdb-23cf50b22c6f.png" alt="透传地区标识机制"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="传递全局上下文"><a href="#传递全局上下文" class="headerlink" title="传递全局上下文"></a>传递全局上下文</h5><p>由于 RPC 框架已支持了 Context，所以 API 和 RPC 接口透传全局上下文略有不同。实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$context</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// API在这里直接获取X-Location头</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_LOCATION&#x27;</span>])) &#123;</span><br><span class="line">            <span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>] = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_LOCATION&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RPC Server会自动获取Context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述<code>init()</code>方法，需要在项目入口位置初始化。</p></blockquote><p>其中，RPC 接口不需要操作全局上下文。因为 RPC Client 在调用时会自动获取全局变量<code>$context</code>值并在 RPC 协议数据中追加 Context，同时 RPC Server 在收到请求时会自动获取 RPC 协议数据中的 Context 值并设置全局变量<code>$context</code>。</p><p>RPC Client 传递 Context 实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">addGlobalContext</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$context</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$context</span> = !<span class="title function_ invoke__">is_array</span>(<span class="variable">$context</span>) ? <span class="keyword">array</span>() : <span class="variable">$context</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data为待请求的RPC协议数据</span></span><br><span class="line">    <span class="variable">$data</span>[<span class="string">&#x27;Context&#x27;</span>] = <span class="variable">$context</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC Server 获取 Context 实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGlobalContext</span>(<span class="params"><span class="variable">$packet</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$context</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$context</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">// packet为接收的RPC协议数据</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$packet</span>[<span class="string">&#x27;Context&#x27;</span>])) &#123;</span><br><span class="line">        <span class="variable">$context</span> = <span class="variable">$packet</span>[<span class="string">&#x27;Context&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置了 Context 后，RPC 通信时协议数据会携带<code>location</code>字段，内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">RPC</span><br><span class="line"><span class="number">325</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#123;\&quot;version\&quot;:\&quot;1.0\&quot;,\&quot;user\&quot;:\&quot;xxx\&quot;,\&quot;password\&quot;:\&quot;xxx\&quot;,\&quot;timestamp\&quot;:1553225486.5455,\&quot;class\&quot;:\&quot;xxx\&quot;,\&quot;method\&quot;:\&quot;xxx\&quot;,\&quot;params\&quot;:[1]&#125;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span><span class="attr">&quot;Context&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="string">&quot;india&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="设置地区标识"><a href="#设置地区标识" class="headerlink" title="设置地区标识"></a>设置地区标识</h5><p>到这里，我们只需要在全局上下文设置地区标识即可。一旦我们设置了地区标识，所有业务系统就会在本次的调用链路中透传这个地区标识。实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"><span class="variable">$location</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$context</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>] = <span class="variable">$location</span>;</span><br><span class="line">        <span class="comment">// API需要在这里单独设置X-Location头</span></span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;X-Location: &#x27;</span> . <span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取地区标识"><a href="#获取地区标识" class="headerlink" title="获取地区标识"></a>获取地区标识</h5><p>设置了地区标识后，就可以在本次调用链路的所有业务系统中直接获取。实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$context</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;china&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$context</span>[<span class="string">&#x27;location&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持多币种价格"><a href="#支持多币种价格" class="headerlink" title="支持多币种价格"></a>支持多币种价格</h3><h4 id="商品中心"><a href="#商品中心" class="headerlink" title="商品中心"></a>商品中心</h4><p>有了地区标识后，商品中心服务就可以根据地区标识对价格字段进行转化了。因为设计到价格的数据表和价格字段较多，这里直接从数据层（Model）进行改造。</p><h5 id="改造获取数据方法"><a href="#改造获取数据方法" class="headerlink" title="改造获取数据方法"></a>改造获取数据方法</h5><p>下述的<code>ReadBase</code>类是所有数据表 Model 的基类，所有获取数据表数据的方法都继承或调用自<code>getOne()</code> 和<code>getAll()</code>方法，所以我们只需要改造这两个方法。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadBase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getOne</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$cond</span>, <span class="variable">$fields</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$data</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getReader</span>()-&gt;<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">getFields</span>(<span class="variable">$fields</span>))-&gt;<span class="keyword">from</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getTableName</span>())-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$cond</span>)-&gt;<span class="title function_ invoke__">queryRow</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getExchangePrice</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAll</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$cond</span>, <span class="variable">$fields</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$data</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getReader</span>()-&gt;<span class="title function_ invoke__">select</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">getFields</span>(<span class="variable">$fields</span>))-&gt;<span class="keyword">from</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getTableName</span>())-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$cond</span>)-&gt;<span class="title function_ invoke__">queryAll</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$data</span>) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> &amp;<span class="variable">$one</span>) &#123;</span><br><span class="line">                 <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getExchangePrice</span>(<span class="variable">$one</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后缀匹配价格字段"><a href="#后缀匹配价格字段" class="headerlink" title="后缀匹配价格字段"></a>后缀匹配价格字段</h5><p>由于涉及到价格字段名字较多，且具有不确定性，所以这里使用后缀方式匹配。为了防止一些字段命名不规范，这里引入了黑名单机制。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">isExchangeField</span>(<span class="params"><span class="variable">$field</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$priceSuffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;cost&#x27;</span>, <span class="string">&#x27;_price&#x27;</span>);</span><br><span class="line">    <span class="variable">$black</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$field</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$priceSuffix</span> <span class="keyword">as</span> <span class="variable">$suffix</span>) &#123;</span><br><span class="line">        <span class="variable">$lastPos</span> = <span class="variable">$len</span> - <span class="title function_ invoke__">strlen</span>(<span class="variable">$suffix</span>);</span><br><span class="line">        <span class="comment">// 非黑名单且非is_</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$field</span>, <span class="variable">$black</span>)</span><br><span class="line">            &amp;&amp; <span class="literal">false</span> === <span class="title function_ invoke__">strpos</span>(<span class="variable">$field</span>, <span class="string">&#x27;is_&#x27;</span>)</span><br><span class="line">            &amp;&amp; <span class="variable">$lastPos</span> === <span class="title function_ invoke__">strpos</span>(<span class="variable">$field</span>, <span class="variable">$suffix</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前缀为<code>is_</code>的字段一般定义为标识字段，默认为非价格字段。</p></blockquote><h5 id="计算地区价格"><a href="#计算地区价格" class="headerlink" title="计算地区价格"></a>计算地区价格</h5><p>上述<code>getExchangePrice()</code>方法，用来根据地区标识转化价格覆盖到原价格字段，并自增以<code>_origin</code>后缀的人民币价格字段。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getExchangePrice</span>(<span class="params">&amp;<span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$originPrice</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$field</span> =&gt; &amp;<span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否是价格字段</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isExchangeField</span>(<span class="variable">$field</span>)) &#123;</span><br><span class="line">            <span class="variable">$originField</span> = <span class="variable">$field</span> . <span class="string">&#x27;_origin&#x27;</span>;</span><br><span class="line">            <span class="variable">$originPrice</span>[<span class="variable">$originField</span>] = <span class="variable">$value</span>;</span><br><span class="line">            <span class="comment">// 获取对应地区的价格</span></span><br><span class="line">            <span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getExchangePrice</span>(<span class="variable">$value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$data</span> = <span class="title function_ invoke__">array_merge</span>(<span class="variable">$originPrice</span>, <span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getExchangePrice</span>(<span class="params"><span class="variable">$price</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取地区标识</span></span><br><span class="line">    <span class="variable">$location</span> = <span class="title class_">Location</span>::<span class="title function_ invoke__">get</span>();</span><br><span class="line">    <span class="comment">// 汇率</span></span><br><span class="line">    <span class="variable">$exchangeRateConfig</span> = <span class="title class_">\Config</span>::<span class="variable">$exchangeRate</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$location</span> === <span class="string">&#x27;china&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$price</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$exchangeRateConfig</span>[<span class="variable">$location</span>])) &#123;</span><br><span class="line">        <span class="variable">$exchangeRate</span> = <span class="variable">$exchangeRateConfig</span>[<span class="variable">$location</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">\BusinessException</span>(<span class="string">&quot;not found <span class="subst">$location</span> exchange rate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上取值并保留两位小数</span></span><br><span class="line">    <span class="variable">$exchangePrice</span> = <span class="title function_ invoke__">bcmul</span>(<span class="variable">$price</span>, <span class="variable">$exchangeRate</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">number_format</span>(<span class="title function_ invoke__">ceil</span>(<span class="variable">$exchangePrice</span> * <span class="number">100</span>) / <span class="number">100</span>, <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getExchangePrice()</code>方法会调用<code>Location::get()</code>获取地区标识，并根据汇率计算实时价格。</p><p>最终，商品中心改造后，得到的部分商品价格信息，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 人民币价格10，汇率10.87</span></span><br><span class="line">market_price: <span class="number">108.7</span></span><br><span class="line">market_price_origin: <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="API系统"><a href="#API系统" class="headerlink" title="API系统"></a>API系统</h4><p>对于所有 API 的项目，我们只需要让客户端在所有的请求中增加<code>X-Location</code>头即可。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GET</span> /product/detail/<span class="number">1</span> HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Request Headers</span><br><span class="line">  X-Location: india</span><br></pre></td></tr></table></figure><p>API 项目需在入口文件处，初始化地区标识。如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Location</span>::<span class="title function_ invoke__">init</span>();</span><br></pre></td></tr></table></figure><h4 id="商品管理系统"><a href="#商品管理系统" class="headerlink" title="商品管理系统"></a>商品管理系统</h4><p>对于商品管理系统，我们为了方便运营操作，所有商品价格都应以人民币。因此，我们只需要初始化地区标识为中国，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Location</span>::<span class="title function_ invoke__">init</span>();</span><br><span class="line"><span class="comment">// 地区设置为中国</span></span><br><span class="line"><span class="title class_">Location</span>::<span class="title function_ invoke__">set</span>(<span class="string">&#x27;china&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了实现需求很容易，但是要做到合理且快速却不简单。本文的实现的方案，避免了很多坑，但同时也可能又埋下了一些坑。没有一套方案是万能的，慢慢去优化吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假若，你是某个国内电商平台的商品中心项目负责人。突然今天，接到了一个这样的需求：商品在原人民币价格的基础架构上，须支持卢比（印度）价格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2019/02/multi-currency-price/434ddc25-3b51-4753-b5d5-b765ac5ca30c.jpg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="架构" scheme="https://www.fanhaobai.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E6%9E%B6%E6%9E%84/PHP/"/>
    
    
      <category term="架构" scheme="https://www.fanhaobai.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡算法 — 平滑加权轮询</title>
    <link href="https://www.fanhaobai.com/2018/12/load-balance-smooth-weighted-round-robin.html"/>
    <id>https://www.fanhaobai.com/2018/12/load-balance-smooth-weighted-round-robin.html</id>
    <published>2018-12-02T12:45:12.000Z</published>
    <updated>2024-04-18T08:38:12.696Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">负载均衡算法 — 轮询</a> 一文中，我们就指出了加权轮询算法一个明显的缺陷。即在某些特殊的权重下，加权轮询调度会生成不均匀的实例序列，这种不平滑的负载可能会使某些实例出现瞬时高负载的现象，导致系统存在宕机的风险。为了解决这个调度缺陷，就提出了 <a href="#">平滑加权轮询</a> 调度算法。</p><p><img src="//www.fanhaobai.com/2018/12/load-balance-smooth-weighted-round-robin/fc16ba37-06b0-4193-9969-7541852dd46c.jpg" alt="预览图"><span id="more"></span></p><h2 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h2><p>为了说明平滑加权轮询调度的平滑性，使用以下 3 个特殊的权重实例来演示调度过程。</p><table><thead><tr><th>服务实例</th><th>权重值</th></tr></thead><tbody><tr><td>192.168.10.1:2202</td><td>5</td></tr><tr><td>192.168.10.2:2202</td><td>1</td></tr><tr><td>192.168.10.3:2202</td><td>1</td></tr></tbody></table><p>我们已经知道通过 <a href="https://www.fanhaobai.com/2018/12/load-balance-round-robin.html#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2">加权轮询</a> 算法调度后，会生成如下不均匀的调度序列。</p><table><thead><tr><th>请求</th><th>选中的实例</th></tr></thead><tbody><tr><td>1</td><td>192.168.10.1:2202</td></tr><tr><td>2</td><td>192.168.10.1:2202</td></tr><tr><td>3</td><td>192.168.10.1:2202</td></tr><tr><td>4</td><td>192.168.10.1:2202</td></tr><tr><td>5</td><td>192.168.10.1:2202</td></tr><tr><td>6</td><td>192.168.10.2:2202</td></tr><tr><td>7</td><td>192.168.10.3:2202</td></tr></tbody></table><p>接下来，我们就使用平滑加权轮询算法调度上述实例，看看生成的实例序列如何？</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>假设有 N 台实例 S = {S1, S2, …, Sn}，配置权重 W = {W1, W2, …, Wn}，有效权重 CW = {CW1, CW2, …, CWn}。每个实例 i 除了存在一个配置权重 Wi 外，还存在一个当前有效权重 CWi，且 CWi 初始化为 Wi；指示变量 currentPos 表示当前选择的实例 ID，初始化为 -1；所有实例的配置权重和为 weightSum；</p><p>那么，调度算法可以描述为：<br>1、初始每个实例 i 的 <strong>当前有效权重</strong> CWi 为 <strong>配置权重</strong> Wi，并求得配置权重和 weightSum；<br>2、选出 <strong>当前有效权重</strong> <a href="#">最大</a> 的实例，将 <strong>当前有效权重</strong> CWi 减去所有实例的 <strong>权重和</strong> weightSum，且变量 currentPos 指向此位置；<br>3、将每个实例 i 的 <strong>当前有效权重</strong> CWi 都加上 <strong>配置权重</strong> Wi；<br>4、此时变量 currentPos 指向的实例就是需调度的实例；<br>5、每次调度重复上述步骤 2、3、4；</p><p>上述 3 个服务，配置权重和 weightSum 为 7，其调度过程如下：</p><table><thead><tr><th>请求</th><th>选中前的当前权重</th><th>currentPos</th><th>选中的实例</th><th>选中后的当前权重</th></tr></thead><tbody><tr><td>1</td><td>{5, 1, 1}</td><td>0</td><td>192.168.10.1:2202</td><td>{-2, 1, 1}</td></tr><tr><td>2</td><td>{3, 2, 2}</td><td>0</td><td>192.168.10.1:2202</td><td>{-4, 2, 2}</td></tr><tr><td>3</td><td>{1, 3, 3}</td><td>1</td><td>192.168.10.2:2202</td><td>{1, -4, 3}</td></tr><tr><td>4</td><td>{6, -3, 4}</td><td>0</td><td>192.168.10.1:2202</td><td>{-1, -3, 4}</td></tr><tr><td>5</td><td>{4, -2, 5}</td><td>2</td><td>192.168.10.3:2202</td><td>{4, -2, -2}</td></tr><tr><td>6</td><td>{9, -1, -1}</td><td>0</td><td>192.168.10.1:2202</td><td>{2, -1, -1}</td></tr><tr><td>7</td><td>{7, 0, 0}</td><td>0</td><td>192.168.10.1:2202</td><td>{0, 0, 0}</td></tr><tr><td>8</td><td>{5, 1, 1}</td><td>0</td><td>192.168.10.1:2202</td><td>{-2, 1, 1}</td></tr></tbody></table><p>可以看出上述调度序列分散是非常均匀的，且第 8 次调度时当前有效权重值又回到 {0, 0, 0}，实例的状态同初始状态一致，所以后续可以一直重复调度操作。</p><blockquote><p>此轮询调度算法思路首先被 Nginx 开发者提出，见 <a href="https://github.com/phusion/nginx/commit/27e94984486058d73157038f7950a0a36ecc6e35">phusion/nginx</a> 部分。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="https://github.com/fan-haobai/load-balance/blob/master/Robin/SmoothWeightedRobin.php">代码实现</a></h2><p>这里使用 PHP 来实现，源码见 <a href="https://github.com/fan-haobai/load-balance/blob/master/Robin/SmoothWeightedRobin.php">fan-haobai/load-balance</a> 部分。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmoothWeightedRobin</span> <span class="keyword">implements</span> <span class="title">RobinInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$services</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$total</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$currentPos</span> = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$services</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$services</span> <span class="keyword">as</span> <span class="variable">$ip</span> =&gt; <span class="variable">$weight</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;services[] = [</span><br><span class="line">                <span class="string">&#x27;ip&#x27;</span>      =&gt; <span class="variable">$ip</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span>  =&gt; <span class="variable">$weight</span>,</span><br><span class="line">                <span class="string">&#x27;current_weight&#x27;</span> =&gt; <span class="variable">$weight</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;total = <span class="title function_ invoke__">count</span>(<span class="variable">$this</span>-&gt;services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取最大当前有效权重实例的位置</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;currentPos = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getMaxCurrentWeightPos</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前权重减去权重和</span></span><br><span class="line">        <span class="variable">$currentWeight</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getCurrentWeight</span>(<span class="variable">$this</span>-&gt;currentPos) - <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getSumWeight</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">setCurrentWeight</span>(<span class="variable">$this</span>-&gt;currentPos, <span class="variable">$currentWeight</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个实例的当前有效权重加上配置权重</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">recoverCurrentWeight</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;services[<span class="variable language_">$this</span>-&gt;currentPos][<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getSumWeight()</code>为所有实例的配置权重和；<code>getCurrentWeight()</code>和 <code>setCurrentWeight()</code>分别用于获取和设置指定实例的当前有效权重；<code>getMaxCurrentWeightPos()</code>求得最大当前有效权重的实例位置，实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getMaxCurrentWeightPos</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$currentWeight</span> = <span class="variable">$pos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;services <span class="keyword">as</span> <span class="variable">$index</span> =&gt; <span class="variable">$service</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$service</span>[<span class="string">&#x27;current_weight&#x27;</span>] &gt; <span class="variable">$currentWeight</span>) &#123;</span><br><span class="line">            <span class="variable">$currentWeight</span> = <span class="variable">$service</span>[<span class="string">&#x27;current_weight&#x27;</span>];</span><br><span class="line">            <span class="variable">$pos</span> = <span class="variable">$index</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$pos</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recoverCurrentWeight()</code>用于调整每个实例的当前有效权重，即加上配置权重，实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">recoverCurrentWeight</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;services <span class="keyword">as</span> <span class="variable">$index</span> =&gt; &amp;<span class="variable">$service</span>) &#123;</span><br><span class="line">        <span class="variable">$service</span>[<span class="string">&#x27;current_weight&#x27;</span>] += <span class="variable">$service</span>[<span class="string">&#x27;weight&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在配置<code>services</code>服务列表时，同样需要指定其权重：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$services</span> = [</span><br><span class="line">    <span class="string">&#x27;192.168.10.1:2202&#x27;</span> =&gt; <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.2:2202&#x27;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.3:2202&#x27;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h2><p>可惜的是，关于此调度算法严谨的数学证明少之又少，不过网友 <a href="https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/">tenfy</a> 给出的 <a href="https://github.com/bigbuger">安大神</a> 证明过程，非常值得参考和学习。</p><h3 id="证明权重合理性"><a href="#证明权重合理性" class="headerlink" title="证明权重合理性"></a>证明权重合理性</h3><p>假如有 n 个结点，记第 i 个结点的权重是 $x_i$，设总权重为 $S = x_1 + x_2 + … + x_n$。选择分两步：<br>1、为每个节点加上它的权重值；<br>2、选择最大的节点减去总的权重值；</p><p>n 个节点的初始化值为 [0, 0, …, 0]，数组长度为 n，值都为 0。第一轮选择的第 1 步执行后，数组的值为 $[x_1, x_2, …, x_n]$。</p><p>假设第 1 步后，最大的节点为 j，则第 j 个节点减去 S。<br>所以第 2 步的数组为 $[x_1, x_2, …, x_j-S, …, x_n]$。 执行完第 2 步后，数组的和为：<br>$x_1 + x_2 + … + x_j-S + … + x_n =&gt; x_1 + x_2 + … + x_n - S = S - S = 0$</p><p>由此可见，每轮选择第 1 步操作都是数组的总和加上 S，第 2 步总和再减去 S，所以每轮选择完后的数组总和都为 0。</p><p>假设总共执行 S 轮选择，记第 i 个结点选择 $m_i$ 次。第 i 个结点的当前权重为 $w_i$。 假设节点 j 在第 t 轮（t &lt; S）之前，已经被选择了 $x_j$ 次，记此时第 j 个结点的当前权重为 $w_j = t * x_j - x_j * S = (t - S) * x_j &lt; 0$， 因为 t 恒小于 S，所以 $w_j &lt; 0$。</p><p>前面假设总共执行 S 轮选择，则剩下 S-t 轮 j 都不会被选中，上面的公式 $w_j = (t - S) * x_j + (S - t) * x_j = 0$。 所以在剩下的选择中，$w_j$ 永远小于等于 0，由于上面已经证明任何一轮选择后，数组总和都为 0，则必定存在一个节点 k 使得 $w_k &gt; 0$，永远不会再选中节点 j。</p><p>由此可以得出，第 i 个结点最多被选中 $x_i$ 次，即 $m_i &lt;= x_i$。<br>因为 $S = m_1 + m_2 + … + m_n$ 且 $S = x_1 + x_2 + … + x_n$。 所以，可以得出 $m_i == x_i$。</p><h3 id="证明平滑性"><a href="#证明平滑性" class="headerlink" title="证明平滑性"></a>证明平滑性</h3><p>证明平滑性，只要证明不要一直都是连续选择那一个节点即可。</p><p>跟上面一样，假设总权重为 S，假如某个节点 i 连续选择了 t（$t &lt; x_i$） 次，只要存在下一次选择的不是节点 i，即可证明是平滑的。</p><p>假设 $t = x_i - 1$，此时第 i 个结点的当前权重为 $w_i = t * x_i - t * S = (x_i - 1) * x_i - (x_i - 1) * S$。证明下一轮的第 1 步执行完的值 $w_i + x_i$ 不是最大的即可。</p><p>$w_i + x_i =&gt; (x_i - 1) * x_i - (x_i - 1) * S + x_i =&gt;$<br>$x_i^2 - x_i * S + S =&gt; (x_i - 1) * (x_i - S) + x_i$</p><p>因为 $x_i$ 恒小于 S，所以 $x_i - S &lt;= -1$。 所以上面：<br>$(x_i - 1) * (x_i - S) + x_i &lt;= (x_i - 1) * -1 + x_i = -x_i + 1 + x_i = 1$</p><p>所以第 t 轮后，再执行完第 1 步的值 $w_i + x_i &lt;= 1$。<br>如果这 t 轮刚好是最开始的 t 轮，则必定存在另一个结点 j 的值为 $x_j * t$，所以有 $w_i + x_i &lt;= 1 &lt; 1 * t &lt; x_j * t$。所以下一轮肯定不会选中 i。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管，平滑加权轮询算法改善了加权轮询算法调度的缺陷，即调度序列分散的不均匀，避免了实例负载突然加重的可能，但是仍然不能动态感知每个实例的负载。</p><p>若由于实例权重配置不合理，或者一些其他原因加重系统负载的情况，平滑加权轮询都无法实现每个实例的负载均衡，这时就需要 <a href="#">有状态</a> 的调度算法来完成。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html">负载均衡算法 — 轮询</a> <span>（2018-11-29）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://www.fanhaobai.com/2018/11/load-balance-round-robin.html&quot;&gt;负载均衡算法 — 轮询&lt;/a&gt; 一文中，我们就指出了加权轮询算法一个明显的缺陷。即在某些特殊的权重下，加权轮询调度会生成不均匀的实例序列，这种不平滑的负载可能会使某些实例出现瞬时高负载的现象，导致系统存在宕机的风险。为了解决这个调度缺陷，就提出了 &lt;a href=&quot;#&quot;&gt;平滑加权轮询&lt;/a&gt; 调度算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/12/load-balance-smooth-weighted-round-robin/fc16ba37-06b0-4193-9969-7541852dd46c.jpg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/PHP/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡算法 — 轮询</title>
    <link href="https://www.fanhaobai.com/2018/11/load-balance-round-robin.html"/>
    <id>https://www.fanhaobai.com/2018/11/load-balance-round-robin.html</id>
    <published>2018-11-29T11:20:10.000Z</published>
    <updated>2024-04-18T08:38:12.696Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，为了实现负载均衡，必然会涉及到负载调度算法，如 Nginx 和 RPC 服务发现等场景。常见的负载均衡算法有  <a href="#">轮询</a>、<a href="#">源地址 Hash</a>、<a href="#">最少连接数</a>，而 <strong>轮询</strong> 是最简单且应用最广的算法。</p><p><img src="//www.fanhaobai.com/2018/11/load-balance-round-robin/1e858872-6235-4131-98ba-433690eb32c1.jpg" alt="预览图"><span id="more"></span></p><p>3 种常见的轮询调度算法，分别为 <a href="#%E7%AE%80%E5%8D%95%E8%BD%AE%E8%AF%A2">简单轮询</a>、<a href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2">加权轮询</a>、<a href="#">平滑加权轮询</a>。本文将用如下 4 个服务，来详细说明轮询调度过程。</p><table><thead><tr><th>服务实例</th><th>权重值</th></tr></thead><tbody><tr><td>192.168.10.1:2202</td><td>1</td></tr><tr><td>192.168.10.2:2202</td><td>2</td></tr><tr><td>192.168.10.3:2202</td><td>3</td></tr><tr><td>192.168.10.4:2202</td><td>4</td></tr></tbody></table><h2 id="简单轮询"><a href="#简单轮询" class="headerlink" title="简单轮询"></a>简单轮询</h2><p>简单轮询是轮询算法中最简单的一种，但由于它不支持配置负载，所以应用较少。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>假设有 N 台实例 S = {S1, S2, …, Sn}，指示变量 currentPos 表示当前选择的实例 ID，初始化为 -1。算法可以描述为：<br>1、调度到下一个实例；<br>2、若所有实例已被 <strong>调度</strong> 过一次，则从头开始调度；<br>3、每次调度重复步骤 1、2；</p><p>调度过程，如下：</p><table><thead><tr><th>请求</th><th>currentPos</th><th>选中的实例</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>192.168.10.1:2202</td></tr><tr><td>2</td><td>1</td><td>192.168.10.2:2202</td></tr><tr><td>3</td><td>2</td><td>192.168.10.3:2202</td></tr><tr><td>4</td><td>3</td><td>192.168.10.4:2202</td></tr><tr><td>5</td><td>0</td><td>192.168.10.1:2202</td></tr></tbody></table><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="https://github.com/fan-haobai/load-balance/blob/master/Robin/Robin.php">代码实现</a></h3><p>这里使用 PHP 来实现，源码见 <a href="https://github.com/fan-haobai/load-balance">fan-haobai/load-balance</a> 部分。</p><p>首先，定义一个统一的操作接口，主要有<code>init()</code>和<code>next()</code>这 2 个方法。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RobinInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化服务权重</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $services</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$services</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，根据简单轮询算法思路，实现上述接口：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robin</span> <span class="keyword">implements</span> <span class="title">RobinInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$services</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$total</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$currentPos</span> = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$services</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;services = <span class="variable">$services</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;total = <span class="title function_ invoke__">count</span>(<span class="variable">$services</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已调度完一圈,重置currentPos值为第一个实例位置</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;currentPos = (<span class="variable language_">$this</span>-&gt;currentPos + <span class="number">1</span>) % <span class="variable language_">$this</span>-&gt;total;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;services[<span class="variable language_">$this</span>-&gt;currentPos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>total</code>为总实例数量，<code>services</code>为服务实例列表。由于简单轮询不需要配置权重，因此可简单配置为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$services</span> = [</span><br><span class="line">    <span class="string">&#x27;192.168.10.1:2202&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.2:2202&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.3:2202&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.4:2202&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>在实际应用中，同一个服务会部署到不同的硬件环境，会出现性能不同的情况。若直接使用简单轮询调度算法，给每个服务实例相同的负载，那么，必然会出现资源浪费的情况。因此为了避免这种情况，一些人就提出了下面的 <a href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2">加权轮询</a> 算法。</p><h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><p>加权轮询算法引入了“权”值，改进了简单轮询算法，可以根据硬件性能配置实例负载的权重，从而达到资源的合理利用。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>假设有 N 台实例 S = {S1, S2, …, Sn}，权重 W = {W1, W2, …, Wn}，指示变量 currentPos 表示当前选择的实例 ID，初始化为 -1；变量 currentWeight 表示当前权重，初始值为 max(S)；max(S) 表示 N 台实例的最大权重值，gcd(S) 表示 N 台实例权重的最大公约数。</p><p>算法可以描述为：<br>1、从上一次调度实例起，遍历后面的每个实例；<br>2、若所有实例已被遍历过一次，则减小 currentWeight 为 currentWeight - gcd(S)，并从头开始遍历；若 currentWeight 小于等于 0，则重置为 max(S)；<br>3、<strong>直到</strong> 遍历的实例的权重大于等于 currentWeight 时结束，此时实例为需调度的实例；<br>4、每次调度重复步骤 1、2、3；</p><p>例如，上述 4 个服务，最大权重 max(S) 为 4，最大公约数 gcd(S) 为 1。其调度过程如下：</p><table><thead><tr><th>请求</th><th>currentPos</th><th>currentWeight</th><th>选中的实例</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>4</td><td>192.168.10.4:2202</td></tr><tr><td>2</td><td>2</td><td>3</td><td>192.168.10.3:2202</td></tr><tr><td>3</td><td>3</td><td>3</td><td>192.168.10.4:2202</td></tr><tr><td>4</td><td>1</td><td>2</td><td>192.168.10.2:2202</td></tr><tr><td>…</td><td>…</td><td>…</td><td>….</td></tr><tr><td>9</td><td>2</td><td>1</td><td>192.168.10.3:2202</td></tr><tr><td>10</td><td>3</td><td>4</td><td>192.168.10.4:2202</td></tr></tbody></table><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><a href="https://github.com/fan-haobai/load-balance/blob/master/Robin/WeightRobin.php">代码实现</a></h3><p>这里使用 PHP 来实现，源码见 <a href="https://github.com/fan-haobai/load-balance">fan-haobai/load-balance</a> 部分。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedRobin</span> <span class="keyword">implements</span> <span class="title">RobinInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$services</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$total</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$currentPos</span> = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$currentWeight</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$services</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$services</span> <span class="keyword">as</span> <span class="variable">$ip</span> =&gt; <span class="variable">$weight</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;services[] = [</span><br><span class="line">                <span class="string">&#x27;ip&#x27;</span>     =&gt; <span class="variable">$ip</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> =&gt; <span class="variable">$weight</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;total = <span class="title function_ invoke__">count</span>(<span class="variable">$this</span>-&gt;services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$i</span> = <span class="variable language_">$this</span>-&gt;currentPos;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="variable">$i</span> = (<span class="variable">$i</span> + <span class="number">1</span>) % <span class="variable language_">$this</span>-&gt;total;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已全部被遍历完一次</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> === <span class="variable">$i</span>) &#123;</span><br><span class="line">                <span class="comment">// 减currentWeight</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;currentWeight -= <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getGcd</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 赋值currentWeight为0,回归到初始状态</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;currentWeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;currentWeight = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getMaxWeight</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直到当前遍历实例的weight大于或等于currentWeight</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;services[<span class="variable">$i</span>][<span class="string">&#x27;weight&#x27;</span>] &gt;= <span class="variable language_">$this</span>-&gt;currentWeight) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;currentPos = <span class="variable">$i</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;services[<span class="variable language_">$this</span>-&gt;currentPos][<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getMaxWeight()</code>为所有实例的最大权重值；<code>getGcd()</code>为所有实例权重的最大公约数，主要是通过<code>gcd()</code>方法（可用<code>gmp_gcd()</code>函数）求得 2 个数的最大公约数，然后求每一个实例的权重与当前最大公约数的最大公约数。实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getGcd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$gcd</span> = <span class="variable language_">$this</span>-&gt;services[<span class="number">0</span>][<span class="string">&#x27;weight&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;total; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$gcd</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">gcd</span>(<span class="variable">$gcd</span>, <span class="variable">$this</span>-&gt;services[<span class="variable">$i</span>][<span class="string">&#x27;weight&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$gcd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在配置<code>services</code>服务列表时，需要指定其权重：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$services</span> = [</span><br><span class="line">    <span class="string">&#x27;192.168.10.1:2202&#x27;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.2:2202&#x27;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.3:2202&#x27;</span> =&gt; <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.10.4:2202&#x27;</span> =&gt; <span class="number">4</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p><a href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2">加权轮询</a> 算法虽然通过配置实例权重，解决了 <a href="#%E7%AE%80%E5%8D%95%E8%BD%AE%E8%AF%A2">简单轮询</a> 的资源利用问题，但是它还是存在一个比较明显的 <strong>缺陷</strong>。例如：</p><p>服务实例 S =  {a, b, c}，权重 W = {5, 1, 1}，使用加权轮询调度生成的实例序列为 {a, a, a, a, a, b, c}，那么就会存在连续 5 个请求都被调度到实例 a。而实际中，这种不均匀的负载是不被允许的，因为连续请求会突然加重实例 a 的负载，可能会导致严重的事故。</p><p>为了解决加权轮询调度不均匀的缺陷，一些人提出了 <a href="#">平滑加权轮询</a> 调度算法，它会生成的更均匀的调度序列 {a, a, b, a, c, a, a}。对于神秘的平滑加权轮询算法，我将在后续文章中详细介绍它的原理和实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>轮询算法是最简单的调度算法，因为它无需记录当前所有连接的状态，所以它是一种  <a href="#">无状态</a> 的调度算法，这些特性使得它应用较广。</p><p>轮询调度算法并不能动态感知每个实例的负载，它完全依赖于我们的工程经验，人为配置权重来实现基本的负载均衡，并不能保证服务的高可用性。若服务的某些实例因其他原因负载突然加重，轮询调度还是会一如既往地分配请求给这个实例，因此可能会形成小面积的宕机，导致服务的局部不可用。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/11/load-balance-smooth-weighted-round-robin.html">负载均衡算法 — 平滑加权轮询</a> <span>（2018-11-30）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，为了实现负载均衡，必然会涉及到负载调度算法，如 Nginx 和 RPC 服务发现等场景。常见的负载均衡算法有  &lt;a href=&quot;#&quot;&gt;轮询&lt;/a&gt;、&lt;a href=&quot;#&quot;&gt;源地址 Hash&lt;/a&gt;、&lt;a href=&quot;#&quot;&gt;最少连接数&lt;/a&gt;，而 &lt;strong&gt;轮询&lt;/strong&gt; 是最简单且应用最广的算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/11/load-balance-round-robin/1e858872-6235-4131-98ba-433690eb32c1.jpg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/PHP/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用PHP玩转进程之二 — 多进程PHPServer</title>
    <link href="https://www.fanhaobai.com/2018/09/process-php-multiprocess-server.html"/>
    <id>https://www.fanhaobai.com/2018/09/process-php-multiprocess-server.html</id>
    <published>2018-09-02T08:10:53.000Z</published>
    <updated>2024-04-18T08:38:12.694Z</updated>
    
    <content type="html"><![CDATA[<p>经过 <a href="https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html">用 PHP 玩转进程之一 — 基础</a> 的回顾复习，我们已经掌握了进程的基础知识，现在可以尝试用 PHP 做一些简单的进程控制和管理，来加深我们对进程的理解。接下来，我将用多进程模型实现一个简单的 PHPServer，基于它你可以做任何事。</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/34f35d33-57b2-41d7-b738-f0c1c712102f.png" alt="预览图"><span id="more"></span></p><p>PHPServer 完整的源代码，可前往 <a href="https://github.com/fan-haobai/php-server">fan-haobai/php-server</a> 获取。</p><h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><p>该 PHPServer 的 Master 和 Worker 进程主要控制流程，如下图所示：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/e0e86073-3093-4e5f-be20-b64510e61575.png" alt="控制流程"></p><p>其中，主要涉及 <strong>3 个对象</strong>，分别为 <a href="#">入口脚本</a>、<a href="#">Master 进程</a>、<a href="#">Worker 进程</a>。它们扮演的角色如下：</p><ul><li><a href="#">入口脚本</a>：主要实现 PHPServer 的启动、停止、重载功能，即触发 Master 进程<code>start</code>、<code>stop</code>、<code>reload</code>流程；</li><li><a href="#">Master 进程</a>：负责创建并监控 Worker 进程。在启动阶段，会注册信号处理器，然后创建 Worker；在运行阶段，会持续监控 Worker 进程健康状态，并接受来自入口脚本的控制信号并作出响应；在停止阶段，会停止掉所有 Worker 进程；</li><li><a href="#">Worker 进程</a>：负责执行业务逻辑。在被 Master 进程创建后，就处于持续运行阶段，会监听到来自 Master 进程的信号，以实现自我的停止；</li></ul><p>整个过程，又包括 <strong>4 个流程</strong>：</p><ul><li><a href="#">流程 ①</a> ：以守护态启动 PHPServer 时的主要流程。入口脚本会进行 <a href="#">daemonize</a>，也就是实现进程的守护态，此时会<code>fork</code>出一个 Master 进程；Master 进程先经过 <a href="#">保存 PID</a>、<a href="#">注册信号处理器</a> 操作，然后 <a href="#">创建 Worker</a> 会<code>fork</code>出多个 Worker 进程；</li><li><a href="#">流程 ②</a> ：为 Master 进程持续监控的流程，过程中会捕获入口脚本发送来的信号。主要监控  Worker 进程健康状态，当 Worker 进程异常退出时，会尝试创建新的 Worker 进程以维持 Worker 进程数量；</li><li><a href="#">流程 ③</a> ：为 Worker 进程持续运行的流程，过程中会捕获 Master 进程发送来的信号。流程 ① 中 Worker 进程被创建后，就会持续执行业务逻辑，并阻塞于此；</li><li><a href="#">流程 ④</a> ：停止 PHPServer 的主要流程。入口脚本首先会向 Master 进程发送 SIGINT 信号，Master 进程捕获到该信号后，会向所有的 Worker 进程转发 SIGINT 信号（通知所有的 Worker 进程终止），等待所有 Worker 进程终止退出；</li></ul><blockquote><p>在流程 ② 中，Worker 进程被 Master 进程<code>fork</code>出来后，就会 <a href="#">持续运行</a> 并阻塞于此，只有 Master 进程才会继续后续的流程。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动流程见 <a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">流程 ①</a>，主要包括 <a href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>、<a href="#%E4%BF%9D%E5%AD%98PID">保存 PID</a>、<a href="#%E6%B3%A8%E5%86%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8">注册信号处理器</a>、<a href="%E5%88%9B%E5%BB%BA%E5%A4%9A%E8%BF%9B%E7%A8%8BWorker">创建多进程 Worker</a> 这 4 部分。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>首先，在入口脚本中<code>fork</code>一个子进程，然后该进程退出，并设置新的子进程为会话组长，此时的这个子进程就会脱离当前终端的控制。如下图所示：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/22ed9e46-971c-4983-8bf5-65d321585d42.png" alt="守护进程流程"></p><p>这里使用了 2 次<code>fork</code>，所以最后<code>fork</code>的一个子进程才是 Master 进程，其实一次<code>fork</code>也是可以的。代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">daemonize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="variable">$pid</span> = <span class="title function_ invoke__">pcntl_fork</span>();</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> === <span class="variable">$pid</span>) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;process fork fail\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (<span class="variable">$pid</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程提升为会话leader</span></span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> === <span class="title function_ invoke__">posix_setsid</span>()) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;process setsid fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次fork以避免SVR4这种系统终端再一次获取到进程控制</span></span><br><span class="line">    <span class="variable">$pid</span> = <span class="title function_ invoke__">pcntl_fork</span>();</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> === <span class="variable">$pid</span>) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;process fork fail\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (<span class="number">0</span> !== <span class="variable">$pid</span>) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常在启动时增加<code>-d</code>参数，表示进程将运行于守护态模式。</p></blockquote><p>当顺利成为一个守护进程后，Master 进程已经脱离了终端控制，所以有必要关闭标准输出和标准错误输出。如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">resetStdFd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$STDERR</span>, <span class="variable">$STDOUT</span>;</span><br><span class="line">    <span class="comment">//重定向标准输出和错误输出</span></span><br><span class="line">    @<span class="title function_ invoke__">fclose</span>(STDOUT);</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(STDERR);</span><br><span class="line">    <span class="variable">$STDOUT</span> = <span class="title function_ invoke__">fopen</span>(<span class="built_in">static</span>::<span class="variable">$stdoutFile</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="variable">$STDERR</span> = <span class="title function_ invoke__">fopen</span>(<span class="built_in">static</span>::<span class="variable">$stdoutFile</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="保存PID"><a href="#保存PID" class="headerlink" title="保存PID"></a>保存PID</h4><p>为了实现 PHPServer 的重载或停止，我们需要将 Master 进程的 PID 保存于 PID 文件中，如<code>php-server.pid</code>文件。代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">saveMasterPid</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保存pid以实现重载和停止</span></span><br><span class="line">    <span class="built_in">static</span>::<span class="variable">$_masterPid</span> = <span class="title function_ invoke__">posix_getpid</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> === <span class="title function_ invoke__">file_put_contents</span>(<span class="built_in">static</span>::<span class="variable">$pidFile</span>, <span class="built_in">static</span>::<span class="variable">$_masterPid</span>)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;can not save pid to&quot;</span> . <span class="built_in">static</span>::<span class="variable">$pidFile</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;PHPServer start\t \033[32m [OK] \033[0m\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册信号处理器"><a href="#注册信号处理器" class="headerlink" title="注册信号处理器"></a>注册信号处理器</h4><p>因为守护进程一旦脱离了终端控制，就犹如一匹脱缰的野马，任由其奔腾可能会为所欲为，所以我们需要去驯服它。</p><p>这里使用信号来实现进程间通信并控制进程的行为，注册信号处理器如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">installSignal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGINT, <span class="keyword">array</span>(<span class="string">&#x27;\PHPServer\Worker&#x27;</span>, <span class="string">&#x27;signalHandler&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGTERM, <span class="keyword">array</span>(<span class="string">&#x27;\PHPServer\Worker&#x27;</span>, <span class="string">&#x27;signalHandler&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGUSR1, <span class="keyword">array</span>(<span class="string">&#x27;\PHPServer\Worker&#x27;</span>, <span class="string">&#x27;signalHandler&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGQUIT, <span class="keyword">array</span>(<span class="string">&#x27;\PHPServer\Worker&#x27;</span>, <span class="string">&#x27;signalHandler&#x27;</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略信号</span></span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGUSR2, SIG_IGN, <span class="literal">false</span>);</span><br><span class="line">    <span class="title function_ invoke__">pcntl_signal</span>(SIGHUP,  SIG_IGN, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">signalHandler</span>(<span class="params"><span class="variable">$signal</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$signal</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGINT:</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            <span class="built_in">static</span>::<span class="title function_ invoke__">stop</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">        <span class="keyword">case</span> SIGUSR1:</span><br><span class="line">            <span class="built_in">static</span>::<span class="title function_ invoke__">reload</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，SIGINT 和 SIGTERM 信号会触发<code>stop</code>操作，即终止所有进程；SIGQUIT 和 SIGUSR1 信号会触发<code>reload</code>操作，即重新加载所有 Worker 进程；此处忽略了 SIGUSR2 和 SIGHUP 信号，但是并未忽略 SIGKILL 信号，即所有进程都可以被强制<code>kill</code>掉。</p><h4 id="创建多进程Worker"><a href="#创建多进程Worker" class="headerlink" title="创建多进程Worker"></a>创建多进程Worker</h4><p>Master 进程通过<code>fork</code>系统调用，就能创建多个 Worker 进程。实现代码，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">forkOneWorker</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$pid</span> = <span class="title function_ invoke__">pcntl_fork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$pid</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">static</span>::<span class="variable">$_workers</span>[] = <span class="variable">$pid</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$pid</span> === <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">static</span>::<span class="title function_ invoke__">setProcessTitle</span>(<span class="string">&#x27;PHPServer: worker&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程会阻塞在这里</span></span><br><span class="line">        <span class="built_in">static</span>::<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程退出</span></span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">\Exception</span>(<span class="string">&quot;fork one worker fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">forkWorkers</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="built_in">static</span>::<span class="variable">$_workers</span>) &lt; <span class="built_in">static</span>::<span class="variable">$workerCount</span>) &#123;</span><br><span class="line">        <span class="built_in">static</span>::<span class="title function_ invoke__">forkOneWorker</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker进程的持续运行"><a href="#Worker进程的持续运行" class="headerlink" title="Worker进程的持续运行"></a>Worker进程的持续运行</h3><p>Worker 进程的持续运行，见 <a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">流程 ③</a> 。其内部调度流程，如下图：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/ad804eb2-9300-4d34-ae63-3b820d81d4b1.png" alt="Worker进程的持续运行"></p><p>对于 Worker 进程，<code>run()</code>方法主要执行具体业务逻辑，当然 Worker 进程会被阻塞于此。对于 <a href="#">任务 ①</a> 这里简单地使用<code>while</code>来模拟调度，实际中应该使用事件（Select 等）驱动。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟调度,实际用event实现</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 捕获信号</span></span><br><span class="line">        <span class="title function_ invoke__">pcntl_signal_dispatch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">call_user_func</span>(function() &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="title function_ invoke__">usleep</span>(<span class="number">200</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>pcntl_signal_dispatch()</code>会在每次调度过程中，捕获信号并执行注册的信号处理器。</p><h3 id="Master进程的持续监控"><a href="#Master进程的持续监控" class="headerlink" title="Master进程的持续监控"></a>Master进程的持续监控</h3><h4 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h4><p>Master 进程的持续监控，见 <a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">流程 ②</a> 。其内部调度流程，如下图：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/8e65456f-8e08-4ae8-84f8-e6f2278410e4.png" alt="Master持续监控流程"></p><p>对于 Master 进程的调度，这里也使用了<code>while</code>，但是引入了<code>wait</code>的系统调用，它会挂起当前进程，直到一个子进程退出或接收到一个信号。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">monitor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 这两处捕获触发信号,很重要</span></span><br><span class="line">        <span class="title function_ invoke__">pcntl_signal_dispatch</span>();</span><br><span class="line">        <span class="comment">// 挂起当前进程的执行直到一个子进程退出或接收到一个信号</span></span><br><span class="line">        <span class="variable">$status</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$pid</span> = <span class="title function_ invoke__">pcntl_wait</span>(<span class="variable">$status</span>, WUNTRACED);</span><br><span class="line">        <span class="title function_ invoke__">pcntl_signal_dispatch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pid</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// worker健康检查</span></span><br><span class="line">            <span class="built_in">static</span>::<span class="title function_ invoke__">checkWorkerAlive</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他你想监控的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第两次的<code>pcntl_signal_dispatch()</code>捕获信号，是由于<code>wait</code>挂起时间可能会很长，而这段时间可能恰恰会有信号，所以需要再次进行捕获。</p></blockquote><p>其中，PHPServer 的 <a href="#%E5%81%9C%E6%AD%A2">停止</a> 和 <a href="#%E9%87%8D%E8%BD%BD">重载</a> 操作是由信号触发，在信号处理器中完成具体操作；<a href="#Worker%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">Worker 进程的健康检查</a> 会在每一次的调度过程中触发。</p><h4 id="Worker进程的健康检查"><a href="#Worker进程的健康检查" class="headerlink" title="Worker进程的健康检查"></a>Worker进程的健康检查</h4><p>由于 Worker 进程执行繁重的业务逻辑，所以可能会异常崩溃。因此 Master 进程需要监控 Worker 进程健康状态，并尝试维持一定数量的 Worker 进程。健康检查流程，如下图：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/db333298-5a10-4de3-b0b2-41088cafc77f.png" alt="健康检查流程"></p><p>代码实现，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkWorkerAlive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$allWorkerPid</span> = <span class="built_in">static</span>::<span class="title function_ invoke__">getAllWorkerPid</span>();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$allWorkerPid</span> <span class="keyword">as</span> <span class="variable">$index</span> =&gt; <span class="variable">$pid</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">static</span>::<span class="title function_ invoke__">isAlive</span>(<span class="variable">$pid</span>)) &#123;</span><br><span class="line">            <span class="keyword">unset</span>(<span class="built_in">static</span>::<span class="variable">$_workers</span>[<span class="variable">$index</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static</span>::<span class="title function_ invoke__">forkWorkers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>Master 进程的持续监控，见 <a href="#%E6%80%BB%E6%B5%81%E7%A8%8B">流程 ④</a> 。其详细流程，如下图：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/fc458e5f-fccc-477f-9e18-eada5d856289.png" alt="停止流程"></p><p>入口脚本给 Master 进程发送 SIGINT  信号，Master 进程捕获到该信号并执行 <a href="#%E6%B3%A8%E5%86%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8">信号处理器</a>，调用<code>stop()</code>方法。如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主进程给所有子进程发送退出信号</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static</span>::<span class="variable">$_masterPid</span> === <span class="title function_ invoke__">posix_getpid</span>()) &#123;</span><br><span class="line">        <span class="built_in">static</span>::<span class="title function_ invoke__">stopAllWorkers</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">is_file</span>(<span class="built_in">static</span>::<span class="variable">$pidFile</span>)) &#123;</span><br><span class="line">            @<span class="title function_ invoke__">unlink</span>(<span class="built_in">static</span>::<span class="variable">$pidFile</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程退出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出前可以做一些事</span></span><br><span class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是 Master 进程执行该方法，会先调用<code>stopAllWorkers()</code>方法，向所有的 Worker 进程发送 SIGINT 信号并等待所有 Worker  进程终止退出，再清除 PID 文件并退出。有一种特殊情况，Worker 进程退出超时时，Master 进程则会再次发送 SIGKILL 信号强制杀死所有 Worker 进程；</p><p>由于 Master 进程会发送 SIGINT 信号给 Worker 进程，所以 Worker 进程也会执行该方法，并会直接退出。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">stopAllWorkers</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$allWorkerPid</span> = <span class="built_in">static</span>::<span class="title function_ invoke__">getAllWorkerPid</span>();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$allWorkerPid</span> <span class="keyword">as</span> <span class="variable">$workerPid</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">posix_kill</span>(<span class="variable">$workerPid</span>, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程退出异常,强制kill</span></span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static</span>::<span class="title function_ invoke__">isAlive</span>(<span class="variable">$allWorkerPid</span>)) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$allWorkerPid</span> <span class="keyword">as</span> <span class="variable">$workerPid</span>) &#123;</span><br><span class="line">            <span class="built_in">static</span>::<span class="title function_ invoke__">forceKill</span>(<span class="variable">$workerPid</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空worker实例</span></span><br><span class="line">    <span class="built_in">static</span>::<span class="variable">$_workers</span> = <span class="keyword">array</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>代码发布后，往往都需要进行重新加载。其实，重载过程只需要重启所有 Worker 进程即可。流程如下图：</p><p><img src="//www.fanhaobai.com/2018/09/process-php-multiprocess-server/4c5ec8d3-e56e-4367-8856-beaf23ee7602.png" alt="重载流程"></p><p>整个过程共有 2 个流程，流程 ① 终止所有的 Worker 进程，流程 ② 为  <a href="#Worker%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">Worker 进程的健康检查</a> 。其中流程 ① ，入口脚本给 Master 进程发送 SIGUSR1 信号，Master 进程捕获到该信号，执行信号处理器调用<code>reload()</code>方法，<code>reload()</code>方法调用<code>stopAllWorkers()</code>方法。如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">reload</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 停止所有worker即可,master会自动fork新worker</span></span><br><span class="line">    <span class="built_in">static</span>::<span class="title function_ invoke__">stopAllWorkers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>reload()</code>方法只会在 Master 进程中执行，因为 SIGQUIT 和 SIGUSR1 信号不会发送给 Worker 进程。</p></blockquote><p>你可能会纳闷，为什么我们需要重启所有的 Worker 进程，而这里只是停止了所有的 Worker 进程？这是因为，在 Worker 进程终止退出后，由于 Master 进程对 <a href="#Worker%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">Worker 进程的健康检查</a> 作用，会自动重新创建所有 Worker 进程。</p><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>到这里，我们已经完成了一个多进程 PHPServer。我们来体验一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">php server.php</span> </span><br><span class="line">Usage: Commands [mode] </span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">startStart worker.</span><br><span class="line">stopStop worker.</span><br><span class="line">reloadReload codes.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-dto start in DAEMON mode.</span><br><span class="line"></span><br><span class="line">Use &quot;--help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>首先，我们启动它：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">php server.php start -d</span></span><br><span class="line">PHPServer start  [OK]</span><br></pre></td></tr></table></figure><p>其次，查看进程树，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -p</span></span><br><span class="line">init(1)-+-init(3)---bash(4)</span><br><span class="line">        |-php(1286)-+-php(1287)</span><br><span class="line">                    `-php(1288)</span><br></pre></td></tr></table></figure><p>最后，我们把它停止：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">php server.php stop</span></span><br><span class="line">PHPServer stopping ...</span><br><span class="line">PHPServer stop success</span><br></pre></td></tr></table></figure><p>现在，你是不是感觉进程控制其实很简单，并没有我们想象的那么复杂。(￣┰￣*)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经实现了一个简易的多进程 <a href="https://github.com/fan-haobai/php-server">PHPServer</a>，模拟了进程的管理与控制。需要说明的是，Master 进程可能偶尔也会异常地崩溃，为了避免这种情况的发生：</p><p>首先，我们不应该给 Master 进程分配繁重的任务，它更适合做一些类似于调度和管理性质的工作；<br>其次，可以使用 <a href="https://www.fanhaobai.com/2017/09/supervisor.html">Supervisor</a> 等工具来管理我们的程序，当 Master 进程异常崩溃时，可以再次尝试被拉起，避免 Master 进程异常退出的情况发生。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html">用PHP玩转进程之一 — 基础</a> <span>（2018-08-28）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过 &lt;a href=&quot;https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html&quot;&gt;用 PHP 玩转进程之一 — 基础&lt;/a&gt; 的回顾复习，我们已经掌握了进程的基础知识，现在可以尝试用 PHP 做一些简单的进程控制和管理，来加深我们对进程的理解。接下来，我将用多进程模型实现一个简单的 PHPServer，基于它你可以做任何事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/09/process-php-multiprocess-server/34f35d33-57b2-41d7-b738-f0c1c712102f.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>用PHP玩转进程之一 — 基础</title>
    <link href="https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html"/>
    <id>https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html</id>
    <published>2018-08-28T12:30:07.000Z</published>
    <updated>2024-04-18T08:38:12.693Z</updated>
    
    <content type="html"><![CDATA[<p>我们工作中接触最多的就是 <a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B">进程</a>，但是我们对它又比较陌生，因为它是业务不需要关心的地方，既有的公有组件和操作系统已经对我们屏蔽了它的复杂性。然后跟它的接触时间一长，我们难免会对它产生好奇：How it works?</p><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/f6eb7888-6de6-41a4-8d15-4d471825a24e.jpg" alt="预览图"><span id="more"></span> </p><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程是 <a href="#">程序的实体</a>，是系统进行 <a href="#">资源分配和调度的基本单位</a>，是操作系统结构的基础。每个进程都有自己唯一标识（PID），每个进程都有父进程，这些父进程也有父进程，所有进程都是<code>init</code>进程（PID 为 1）的子进程。</p><p>我们来直观感受下它的存在，可以说它是看不见又摸不着。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -p</span></span><br><span class="line">init(1)-+-init(3)---bash(4)</span><br><span class="line">        |-nginx(771)-+-nginx(773)</span><br><span class="line">        |            |-nginx(774)</span><br><span class="line">        |            |-nginx(776)</span><br><span class="line">        |            `-nginx(777)</span><br><span class="line">        |-php-fpm(702)-+-php-fpm(707)</span><br><span class="line">                       `-php-fpm(712)</span><br></pre></td></tr></table></figure><h2 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h2><h3 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程"></a>前台进程</h3><p>前台进程具有控制终端，会堵塞控制终端。它的特点是：</p><ul><li>可以同用户交互，但容易被意外终止；</li><li>有较高的响应速度，优先级别稍高；</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">php server.php start</span></span><br><span class="line">PHPServer start  [OK] </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">堵塞了/_ \</span></span><br></pre></td></tr></table></figure><p>通常，在控制终端使用<code>Ctrl+C</code>组合键，会导致前台进程终止退出。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程是一种运行在后台的特殊进程，<a href="#">因为它不属于任何一个终端，所以不会收到任何终端发来的任何信号</a>。它与前台进程显著的区别是：</p><ul><li>它没有控制终端，不能直接和用户交互，在后台运行；</li><li>它不受用户登录和注销的影响，只受开机或关机的影响，可以长期运行；</li></ul><p>通常我们编写的程序，都需要在 <a href="#">后台不终止的长期运行</a> ，此时就可以使用守护进程。当然，我们可以在代码中调用系统函数，或者直接在启动命令后追加<code>&amp;</code>操作符，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> php server.php start &amp;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&amp;使进程脱离控制终端运行</span></span><br></pre></td></tr></table></figure><blockquote><p>通常<code>&amp;</code>与 nohup 结合使用，忽略 SIGHUP 信号来实现一个守护进程。该方式对业务代码侵入最小，方便且成本低，常用于临时执行任务脚本的场景。</p></blockquote><h2 id="进程间通信（InterProcess-Communication）"><a href="#进程间通信（InterProcess-Communication）" class="headerlink" title="进程间通信（InterProcess Communication）"></a><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信</a>（InterProcess Communication）</h2><p>进程的用户空间是相互独立的，一般而言是不能相互访问。但很多情况下，进程间需要互相通信来进行数据传输、共享数据、通知事件、进程控制等，这就必须通过内核实现进程间通信。</p><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/dab56833-15dc-405e-b359-4a4fa0e305bc.jpg" alt="进程间通信模型"></p><p>进程间通信有管道、消息队列、信号、共享内存、套接字等方式，本文只介绍后 3 种。</p><h3 id="共享内存（Shared-Memory）"><a href="#共享内存（Shared-Memory）" class="headerlink" title="共享内存（Shared Memory）"></a><a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">共享内存</a>（Shared Memory）</h3><p>共享内存是一段被映射到多个进程地址空间的内存，虽然这段共享内存是由一个进程创建，但是多个进程都可以访问。如下图：</p><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/c18f0a31-dade-49e0-90b3-308b7ce63ef6.jpg" alt="共享内存模型"></p><p>共享内存是最快的进程间通信方式，但是可能会存在竞争，因此需要加锁。Linux 支持三种共享内存：mmap、Posix、以及 System V。</p><h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a><a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97">套接字</a>（Socket）</h3><p>套接字是一个通信链的句柄，可以用域、端口号、协议类型来表示一个套接字，其中域分为 Internet 网络（IP 地址）和 UNIX 文件（Sock 文件）两种。当域为 Internet 网络时，通信流程如下图：</p><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/f85ea400-6623-44ae-88c4-efc9ef1fa315.jpg" alt="套接字模型"></p><p>特别的是，当套接字域为 Internet 网络时，可以实现 <a href="#">跨主机的进程间通信</a>。因此，若要实现跨主机进行进程间通信，则须选用套接字。</p><h3 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a><a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7">信号</a>（Signal）</h3><p>信号受事件驱动，是一种异步且最复杂的通信方式，用于通知接受进程有某个事件已经发生，因此常用于事件处理。信号的处理机制，如下图：</p><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/0f31694b-b96f-48f2-92f4-56552bded7f4.jpg" alt="信号模型"></p><h4 id="常用的信号值"><a href="#常用的信号值" class="headerlink" title="常用的信号值"></a>常用的信号值</h4><p>在 Linux 系统中，可使用<code>kill -l</code>命令查看这 62 个信号值。其中常用值如下： </p><table><thead><tr><th>信号名称</th><th>值</th><th>说明</th><th><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">进程默认行为</a></th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>终端控制进程结束</td><td>Terminate</td></tr><tr><td>SIGINT</td><td>2</td><td>键盘Ctrl+C被按下</td><td>Terminate</td></tr><tr><td>SIGQUIT</td><td>3</td><td>键盘Ctrl+/被按下</td><td>Dump</td></tr><tr><td>SIGKILL</td><td>9</td><td>无条件结束进程</td><td>Terminate</td></tr><tr><td>SIGUSR1</td><td>10</td><td>用户保留</td><td>Terminate</td></tr><tr><td>SIGUSR2</td><td>12</td><td>用户保留</td><td>Terminate</td></tr><tr><td>SIGALRM</td><td>14</td><td>时钟定时信号</td><td>Terminate</td></tr><tr><td>SIGTERM</td><td>15</td><td>程序结束</td><td>Terminate</td></tr><tr><td>SIGCHLD</td><td>16</td><td>子进程结束</td><td>Ignore</td></tr></tbody></table><h4 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a>产生信号的方式</h4><p>实际中，硬件或者软件中断都会触发信号，但这里只列举两种信号产生方式。</p><ul><li>终端按键</li></ul><table><thead><tr><th>按键/命令</th><th>信号名称</th></tr></thead><tbody><tr><td>Ctrl+C</td><td>SIGINT</td></tr><tr><td>Ctrl+\</td><td>SIGQUIT</td></tr><tr><td>EXIT</td><td>SIGHUP</td></tr></tbody></table><ul><li>系统调用</li></ul><p>通过<code>kill</code>系统调用发送信号。例如，在 Shell 中使用<code>kill -9</code>发送 SIGKILL 信号。对于<code>kill</code>调用，需要注意以下两种特殊情况：</p><p>1、 特殊信号</p><p>可以发送编号为<code>0</code>的信号来 <a href="#">检测进程是否存活</a>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pid</span> = <span class="number">577</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">posix_kill</span>(<span class="variable">$pid</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;进程存在\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;进程不存在\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 特殊 PID</p><p>这里的参数<code>$pid</code>，根据取值范围不同，含义也不同。具体如下：</p><ul><li>$pid &gt; 0：向 PID 为 $pid 的进程发送信号；</li><li>$pid = 0：向当前进程组所有进程发送信号，比较常用；</li><li>$pid = -1：向所有进程（除 PID 为 1）发送信号（权限）；</li></ul><h3 id="进程的处理方式"><a href="#进程的处理方式" class="headerlink" title="进程的处理方式"></a>进程的处理方式</h3><p>进程共有 3 种处理信号的方式：</p><ul><li>默认行为；</li><li>忽略；</li><li>捕获并处理—注册信号处理器后，当捕获到信号时，执行对应的处理器；</li></ul><p>其中，默认行为进一步可以细分为以下几种：</p><table><thead><tr><th>默认处理类型</th><th>描述</th></tr></thead><tbody><tr><td>Terminate</td><td>进程被中止(杀死)</td></tr><tr><td>Dump</td><td>进程被中止(杀死)，并且输出 <a href="http://hutaow.com/blog/2013/10/25/linux-core-dump">dump</a> 文件</td></tr><tr><td>Ignore</td><td>信号被忽略</td></tr><tr><td>Stop</td><td>进程被停止</td></tr></tbody></table><p>信号的默认行为类型，见 <a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%80%BC">常用的信号值</a> 默认行为部分。</p><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><p>使用<code>ps -ajx</code>命令查看所有进程信息，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">父PID  PID  组ID 会话ID 终端      时间   名称</span></span><br><span class="line">PPID   PID  PGID   SID TTY      TIME COMMAND</span><br><span class="line">    0     1     1     1 ?       0:00 /init ro</span><br><span class="line">    1    43    43    43 ?       0:00 /usr/sbin/sshd</span><br><span class="line">   43 11134 11134 11134 ?       0:00 sshd: root@pts/1</span><br><span class="line">11134 11169 11169 11169 pts/1   0:00 -bash</span><br><span class="line">11169 11251 11251 11169 pts/1   0:00 PHPServer: master   </span><br><span class="line">11251 11252 11251 11169 pts/1   0:36 PHPServer: worker   </span><br><span class="line">11251 11253 11251 11169 pts/1   0:42 PHPServer: worker   </span><br></pre></td></tr></table></figure><h3 id="进程组（Process-Group）"><a href="#进程组（Process-Group）" class="headerlink" title="进程组（Process Group）"></a>进程组（Process Group）</h3><p>进程组是一个或多个进程的集合。每个进程除了有一个 PID 之外还有一个进程组 ID（GID），每个进程都属于一个进程组，每个进程都有一个组长进程。</p><p>如上图中，1 个<code>PHPServer: master</code>主进程和 2 个<code>PHPServer: worker</code>子进程，属于同一个进程组<code>11251</code>，可以看出主进程是组长进程。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>会话是一个或多个进程组的集合，一个会话有对应的控制终端。如上图中，4 个<code>PHPServer</code>进程和<code>-bash</code>进程同属于一个会话，因为他们在一个<code>pts/1</code>的控制终端。</p><p><a href="#">需要说明的是</a>，当用户退出（Logout）会话以后，系统默认对该会话下的进程进行如下操作：</p><ol><li>系统向该会话发出 SIGHUP 信号；</li><li>该会话将 SIGHUP 信号发给所有子进程；</li><li>子进程收到 SIGHUP 信号后，自动退出；</li></ol><p>而对于后台进程，用户在退出时系统默认不会发送 SIGHUP 信号，这是由 Shell 的<code>huponexit</code>参数（默认<code>off</code>）控制。可通过<code>shopt -s huponexit</code>设置成<code>on</code>（当前会话有效），此时后台进程会收到 SIGHUP 信号。</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>从进程层面来说，程序可以分为单进程和多进程模型。</p><ul><li>单进程</li></ul><p>单进程模型的程序，只有一个进程在运行。他是最基本的进程模型，实现起来比较简单，Redis 就是采用这种进程模型。</p><ul><li>多进程</li></ul><p><img src="//www.fanhaobai.com/2018/08/process-php-basic-knowledge/80e3b1cf-51d8-4342-a08a-976b3a7b3c8c.png" alt="信号模型"></p><p>为了提高程序的并发处理能力，程序由单进程慢慢演变成了多进程，一 个 Master 进程和多个 Worker 进程是多进程常见的构成形态。可以说，现在大部分程序都是多进程模型，其中 Nginx 是典型的代表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们已经对进程有了基础的认识，后续我将用 PHP 一步步实现一个 <a href="https://github.com/fan-haobai/php-server">PHPServer</a> 应用。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/09/process-php-multiprocess-server.html">用PHP玩转进程之二 — 多进程PHPServer</a> <span>（2018-09-02）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们工作中接触最多的就是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&quot;&gt;进程&lt;/a&gt;，但是我们对它又比较陌生，因为它是业务不需要关心的地方，既有的公有组件和操作系统已经对我们屏蔽了它的复杂性。然后跟它的接触时间一长，我们难免会对它产生好奇：How it works?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/08/process-php-basic-knowledge/f6eb7888-6de6-41a4-8d15-4d471825a24e.jpg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从北京回到成都的这3个月</title>
    <link href="https://www.fanhaobai.com/2018/06/beijing-to-chengdu.html"/>
    <id>https://www.fanhaobai.com/2018/06/beijing-to-chengdu.html</id>
    <published>2018-06-27T12:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.689Z</updated>
    
    <content type="html"><![CDATA[<p>今年 3 月从 <a href="http://www.ziroom.com/">自如</a> 离职，然后就回成都并加入了 <a href="http://www.jumei.com/">聚美</a>，我的北漂记忆也就定格在了自如。回来 3 个月，为了这个伟大的决定，一直想写篇文章，今天刚刚好，这篇文章将叙述自己回成都后经历的事和见闻，有想来成都发展的小伙伴可以以此为参考。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/234987d5-3dd2-4736-b32c-b843ff42505e.jpg" alt="成都"><span id="more"></span></p><h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p>说到成都，很多人（包括小马哥）都会扔出一句“少不入川，老不出川”。他们认为，成都生活安逸，适合养老，年轻人容易失去斗志，但是我并不认同，小马哥后面也改变看法了，因为 N 逼的天美工作室。</p><p>现在的成都，有很多互联网公司入驻，虽说条件比不上北上深，但是在工作和生活平衡点上，是可以安居乐业的；政府也在大力培育“独角兽”企业，未来就业前景也是可期的。至于待遇方面，普遍比北上深低 20~30% 左右，还是那句话：如果你真牛逼，也没有什么是不可能的。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/6054d4bf-b6fe-4dac-ab25-4f6653bc880f.jpg" alt="成都公司"></p><p>现在来说说聚美。目前我主要负责商品中心和库存中心系统，这两个系统作为核心的基础服务，日调用量最高且系统可靠性要求高。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/745d2ec3-6618-4fc0-9f30-4bee52496670.jpg" alt="聚美"></p><ul><li>从 <a href="#">行业</a> 上来看：</li></ul><p>聚美曾经辉煌过，所以大家对其一直有很高的期待，现在聚美正在崛起的路上。个人觉得公司的成功跟行业有很大关系，“风口上的猪”嘛，之前聚美正处风口上，现在自如正处于这个位置，这是我留恋自如的原因。</p><ul><li>从 <a href="#">技术</a> 上来看，PHP 维度：</li></ul><p>聚美 PHP 的生态是我见过做的最好的，这里也是 PHP 在国内大规模成熟应用的实例。毕竟作为电商，经历过业务顶峰，沉淀下来的，这是我来聚美的目的。</p><p>服务 Worker、连接池、RPC、服务调度、旁路、配置中心、消息中心、任务中心等解决方案，尽管目前我还未吃透这些设计，但是旁路的设计就能给我很赞的感觉。当然，这些都需要一个强大的架构团队来支持。一个互联网公司，只有有了一个好的技术生态，才能更好更快地响应业务需求。</p><h2 id="购房"><a href="#购房" class="headerlink" title="购房"></a>购房</h2><p>为了承载你的梦想，首先得有个家。而 2018 的楼市，可谓惨不忍睹。全民炒房，全国房价飞涨，多个城市先后出台了摇号政策，才将这一轮炒房热 Hold 住。整个过程，最受伤的就是刚需。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/4c7fd01e-91ce-48f5-a47b-5ee6500a5d5d.jpg" alt="楼盘售罄"></p><p>成都楼市，在限购限价的政策下，均价控制在 1.5W 左右，当然现在买房，不光得有钱，还得先摇号。攻略如下：</p><ol><li>先确认自己是否有购房资格，主要是户口社保，<a href="http://tool.ixiangzhu.net/limit/index">资格查询工具</a>；</li><li>通过 <a href="https://www.cdfangxie.com/">房协网</a> 、成都摇号助手（小程序）获取最新预售房源，并网上登记报名；</li><li>去往登记的售楼部提交纸质资格资料，等待资格审核通过；</li><li>等待摇号结果；</li><li>摇中后，准备好首付款（首付 3 成），进行按序选房，并办理购房手续；</li></ol><p>整个过程，只可意会，不可言传，只有经历了才知道是多么的惊悚。</p><ul><li>惊悚场景1：</li></ul><p>摇中就像中彩票一样，大部分的摇中概率为 1%。且自己买什么楼盘可选性不大，因为摇中什么才能买什么。</p><ul><li>惊悚场景2：</li></ul><p>原本以为摇中就好，可没有想到，按序选房是多么的恐怖。因为在仅仅只有一大排房号的数字面前，需要 2 分钟从剩余的房源中选定自己看中的房号，就跟去菜市场买白菜一样。当然，这就需要提前做好功课，比如实地踩点，按优先顺序排出多个中意房号。一切都准备好了，但是你运气不太好，摇中的号靠后就不太可能选上中意的房源。</p><p>就摇号买房来说，终于不用拼爹了，而是拼运气。在 5.15 新政之后，这种情况得到改善，但是大学生落户的人就失去了购房资格（所在区社保需满 1 年）。我只是运气刚刚好，赶上新政之前的末班车，摇的号还比较靠前。总之一句话，如果是刚需，就尽快下手，占个坑，因为政策会让你琢磨不透。</p><h2 id="未来之城"><a href="#未来之城" class="headerlink" title="未来之城"></a>未来之城</h2><p>成都未来的发展，就看这座未来之城——四川天府新区。至于为什么要花大量人力物力打造这座新城？简单的答案是：</p><ol><li>成都层面：中心城区“摊拼式”发展，导致中心城区越来越拥挤堵塞，亟需向外疏导人流；</li><li>四川层面：需要打造四川经济新的增长极，促进经济高速发展；</li></ol><p>接下来就介绍一下这个国家级新区。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>四川天府新区规划与 2010 年，2014 年正式成为国家级新区。天府新区建成后，将与成都中心城区形成“双核共兴”的局面。如下为天府新区产业规划图：</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/53bc46b9-b1eb-4c3d-88ff-68b44bce5429.jpg" alt="新区规划"></p><p>我在网上看过一句话，说高新区是民营资本的聚集地，而天府新区是国家队资本的聚集地。我觉得应该说，国家队只是起先导引流作用。</p><h3 id="地铁"><a href="#地铁" class="headerlink" title="地铁"></a>地铁</h3><p>规划这么美的天府新区，交通自然不能拖了后退。从成都地铁规划图中，可以看到新区地铁覆盖率较高，出行较方便。到 2020 年，开通的地铁有 1、5、6、15、18 号线。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/0f8ebfc5-3d54-489e-9dc3-ee74bd4d61d0.jpg" alt="新区地铁"></p><h3 id="代表建筑和景观"><a href="#代表建筑和景观" class="headerlink" title="代表建筑和景观"></a>代表建筑和景观</h3><h4 id="兴隆湖"><a href="#兴隆湖" class="headerlink" title="兴隆湖"></a>兴隆湖</h4><p>习大大说，“绿水青山，就是金山银山”。由于优越的地理位置，决定了天府新区一诞生就是一座“公园城市”。兴隆湖作为天府新区的发展起步区，很好地响应了公园城市理念。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/0149bcaf-f380-4ef3-b6e1-331b452d636a.jpg" alt="兴隆湖"></p><h4 id="一带一路大厦"><a href="#一带一路大厦" class="headerlink" title="一带一路大厦"></a>一带一路大厦</h4><p>曾用名为“熊猫大厦”的 676 米超高地标建筑，正式命名为“一带一路大厦”，这也让人们一直铭记住天府新区是“一带一路”战略的一个重要环节。待“一带一路大厦”旁依附的超高建筑群建成后，成都的天际线将进一步提高，也使得成都的天空具有较强的层次感。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/8111a4fc-7b66-11e8-adc0-fa7ae01bbebc.jpg" alt="一带一路大厦"></p><h4 id="独角兽岛"><a href="#独角兽岛" class="headerlink" title="独角兽岛"></a>独角兽岛</h4><p>独角兽岛当然是独角兽企业（10 亿美元以上创业公司）的聚集地，建设独角兽岛，体现了成都大力培育独角兽企业的决心。独角兽岛先后分两期建成，一期于 2019 年建成，二期 2019 年开建并于 2022 年建成。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/88d071da-7b6d-11e8-adc0-fa7ae01bbebc.jpg" alt="独角兽岛"></p><h4 id="天府国际机场"><a href="#天府国际机场" class="headerlink" title="天府国际机场"></a>天府国际机场</h4><p>天府国际机场造型为“太阳神鸟”，位于高新东区简阳芦葭镇，定位为国家级国际航空枢纽。预计到 2020 年建成使用，届时成都即迈入双机场时代，成为中国大陆地区第三个拥有双国际机场的城市。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/30121dc4-7b67-11e8-adc0-fa7ae01bbebc.jpg" alt="天府机场"></p><h4 id="西博城"><a href="#西博城" class="headerlink" title="西博城"></a>西博城</h4><p>中国西部博览城简称西博城，是我国中西部最大的国际会展中心。由于西博城有着铝制的金属外表，使其看起来很有科技感。</p><p><img src="//www.fanhaobai.com/2018/06/beijing-to-chengdu/de39aeb3-5481-4181-a45c-b503ec16cd0a.jpg" alt="西博城"></p><p>如今 4 年过去了，有的规划已初步建成，有的还在如火如荼的建设中，建设者正在一一将规划图变成一座座楼宇，呈现在人们面前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然成都不比北上广深，却是一个可以承载我梦想的地方。在这里，我可以安居乐业，重要的是能守护心中的她。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年 3 月从 &lt;a href=&quot;http://www.ziroom.com/&quot;&gt;自如&lt;/a&gt; 离职，然后就回成都并加入了 &lt;a href=&quot;http://www.jumei.com/&quot;&gt;聚美&lt;/a&gt;，我的北漂记忆也就定格在了自如。回来 3 个月，为了这个伟大的决定，一直想写篇文章，今天刚刚好，这篇文章将叙述自己回成都后经历的事和见闻，有想来成都发展的小伙伴可以以此为参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/06/beijing-to-chengdu/234987d5-3dd2-4736-b32c-b843ff42505e.jpg&quot; alt=&quot;成都&quot;&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://www.fanhaobai.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://www.fanhaobai.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>我的博客发布上线方案 — Hexo</title>
    <link href="https://www.fanhaobai.com/2018/03/hexo-deploy.html"/>
    <id>https://www.fanhaobai.com/2018/03/hexo-deploy.html</id>
    <published>2018-03-03T08:14:00.000Z</published>
    <updated>2024-04-18T08:38:12.687Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在使用 <a href="https://www.fanhaobai.com/2017/03/install-hexo.html#%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90">Hexo</a> 推荐的发布方案，缺点是本地依赖 Hexo 环境，无法随时随地地更新博客。为了摆脱 Hexo 环境约束进而高效写作，有了下述的发布方案。</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/082786eb-0903-4776-a345-e52d25de2e49.png" alt="预览图"><span id="more"></span></p><p>本文的发布方案中，Git 仓库只是托管 md 文件，通过 Webhook 通知服务器拉取 md 文件，然后执行构建静态文件操作，完成一个发布过程。</p><p>我的写作环境为 <a href="https://www.typora.io/">Typora</a>（Win10），博客发布在阿里云的 <a href="https://www.fanhaobai.com/">ECS</a>（CentOS）上，文章托管在 <a href="https://github.com/fan-haobai/blog">GitHub</a>。</p><h2 id="需求升级"><a href="#需求升级" class="headerlink" title="需求升级"></a>需求升级</h2><p>随着时间成本的增高，只能利用碎片时间来进行写作。因此，我的写作场景变成了这样：</p><ul><li>习惯使用 MarkDown 写原稿，有 MarkDown 编辑器就行；</li><li>写作场地不限定，有电脑就行；</li><li>写作时间不确定，有灵感就写；</li></ul><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>之前（包括 Hexo 推荐）的发布方案，都是先本地编写 MarkDown 源文件，然后本地构建静态文件，最后同步静态文件到服务器。发布流程图如下：</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/f2ec7449-ae8a-4f6a-8dfa-95d6abf4aaa6.png" alt="原来的发布流程"></p><p>显而易见，若继续使用之前的发布方案，那么每当更换写作场地时都需要安装 Hexo 环境，写作场地和时间都受到限制，不满足需求。</p><h2 id="新的方案"><a href="#新的方案" class="headerlink" title="新的方案"></a>新的方案</h2><p>问题主要是，本地受制于构建静态文件时需要的 Hexo 环境，那么是否可以将构建静态文件操作放到服务器端？</p><h3 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h3><p>首先，看下新方案的发布流程图：</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/bf3adf97-088b-47cd-b5ab-377a4f4acd44.png" alt="我的发布流程"></p><p>如流程图所示，整个发布系统共涉及到 3 个环境，分别为本地（写作）、Git 仓库（托管 md 源文件）、服务器（Web 服务）环境。在服务器环境构建静态文件，因此只需要在服务器端安装 Hexo 环境。 </p><p>一个完整的发布流程包含 3 个部分：</p><ul><li>流程 ① ：<a href="#%E5%86%99%E4%BD%9C%E6%B5%81%E7%A8%8B">写作流程</a>；</li><li>流程 ② ：<a href="#%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B">发布流程</a>；</li><li>流程 ③ ：<a href="#%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B">构建流程</a>；</li></ul><h4 id="写作流程"><a href="#写作流程" class="headerlink" title="写作流程"></a>写作流程</h4><p>采用按分支开发策略，当写作完成后，只需要 push 修改到对应分支即可。只要有 MarkDown 编辑器，以及任何文本编辑器，甚至 <a href="https://maxiang.io/">马克飞象</a> 都可以随时随地写作。</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/cd4f6674-aba5-4cbc-87e6-18c0c230585b.png" alt="写作流程"></p><p>当然，你可能说还需要 Git 环境呀？好吧，如果你是一名合格的 Coder，竟然没有 Git，你知道该干嘛了！再说没有 Git 环境，还可以通过 <a href="https://github.com/">GitHub</a> 来完成写作。 </p><h4 id="发布流程-1"><a href="#发布流程-1" class="headerlink" title="发布流程"></a>发布流程</h4><p>采用 master 发布策略，当需要发布时，需要将对应开发分支 merge 到 master 分支，然后 <code>push master</code> 分支，即可实现发布。</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/12b62d2e-7e26-4a3c-a770-e0d16d5c2254.png" alt="发布流程"></p><h4 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h4><p>这里使用到 Webhook 机制，触发代码更新并部署操作。</p><p>当流程 ① 和 ② 结束后，Git 仓库都会向服务器发起一次 HTTP 请求，记录如下：</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/9ee84981-7d79-47f5-98f8-e7500eff6e67.png" alt="Webhook请求"></p><p>当收到构建请求后，执行构建操作。构建流程图如下：</p><p><img src="//www.fanhaobai.com/2018/03/hexo-deploy/3b8f20b3-f3b2-498d-afa4-d60391c47db5.png" alt="构建流程图"></p><p>首先检查当前变更分支，只有为 master 分支时，执行 pull 操作拉取 md 文件更新，然后再执行 <code>hexo g</code> 完成静态文件的构建。 </p><h3 id="Webhook脚本"><a href="#Webhook脚本" class="headerlink" title="Webhook脚本"></a>Webhook脚本</h3><p>这里直接使用 <a href="https://github.com/sigoden/webhook">webhook-cli</a> 工具，只需简单配置即可使用。</p><p>新增 <code>hook.json</code> 配置文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;webhook-deploy-hexo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;execute-command&quot;</span>: <span class="string">&quot;/build_hexo.sh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;include-command-output-in-response&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;trigger-rule&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;and&quot;</span>:</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;match&quot;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;payload-hash-sha1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;secret&quot;</span>: <span class="string">&quot;88E7fe7aDf58d8a42108F0b7c2065d55dF3204D7&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameter&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;source&quot;</span>: <span class="string">&quot;header&quot;</span>,</span><br><span class="line">              <span class="string">&quot;name&quot;</span>: <span class="string">&quot;X-Hub-Signature&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;match&quot;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="string">&quot;refs/heads/master&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameter&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;source&quot;</span>: <span class="string">&quot;payload&quot;</span>,</span><br><span class="line">              <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ref&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，<code>execute-command</code> 为部署脚本路径，<code>secret</code> 为 webhook 参数加密密钥。</p><p>部署脚本 <code>execute-command</code> 的内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/www/blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新代码</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态资源</span></span><br><span class="line">npm install --force</span><br><span class="line"><span class="comment"># hexo clean</span></span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新发布方案与之前方案的区别是：前者只需本地编写 md 文件，博客服务器构建静态文件；后者本地编写 md 文件后，需要本地构建静态文件，然后博客服务器只同步静态文件。</p><p>当然，有很多办法可以解决当前问题，比如可以使用 <a href="https://formulahendry.github.io/2016/12/04/hexo-ci/">持续集成</a>。本文只是提供一个发布思路，在项目的生产环境中，我们也很容易应用上这种发布思路，开发出自己的发布系统。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/03/install-hexo.html">启用Hexo开源博客系统</a><span>（2017-03-01）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在使用 &lt;a href=&quot;https://www.fanhaobai.com/2017/03/install-hexo.html#%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90&quot;&gt;Hexo&lt;/a&gt; 推荐的发布方案，缺点是本地依赖 Hexo 环境，无法随时随地地更新博客。为了摆脱 Hexo 环境约束进而高效写作，有了下述的发布方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/03/hexo-deploy/082786eb-0903-4776-a345-e52d25de2e49.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="工具" scheme="https://www.fanhaobai.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux日常使用技巧集</title>
    <link href="https://www.fanhaobai.com/2018/02/linux-skill.html"/>
    <id>https://www.fanhaobai.com/2018/02/linux-skill.html</id>
    <published>2018-02-04T14:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.687Z</updated>
    
    <content type="html"><![CDATA[<p>作为技术人员，Linux 系统可以说是我们使用最多的操作系统，但我们可能并不是很了解它。在这里我将自己日常遇到的 Linux 使用技巧记录下来，方便以后查询使用。</p><p><img src="//www.fanhaobai.com/2018/02/linux-skill/2a82ad6b-ab25-409f-858c-22312826ac06.jpg" alt="预览图"><span id="more"></span></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>统计 IP 连接数</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -ntu | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d: -f1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -10</span></span><br></pre></td></tr></table></figure><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><p>在安装环境或者软件时，我们常常需要知道所在操作系统的版本信息，这里列举几种查看内核和发行版本信息的方法，更多见 <a href="https://www.fanhaobai.com/2016/07/linux-version.html">查看 Linux 系统版本</a>。</p><h4 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h4><ul><li>uname命令</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux fhb-6.6 2.6.32-642.13.1.el6.i686</span><br></pre></td></tr></table></figure><ul><li>/proc/version文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/version</span> </span><br><span class="line">Linux version 2.6.32-642.13.1.el6.i686</span><br></pre></td></tr></table></figure><h4 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h4><ul><li>lsb_release命令</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsb_release -a</span></span><br><span class="line">LSB Version::base-4.0-ia32:base-4.0-noarch:core-4.0-ia32</span><br><span class="line">Distributor ID:CentOS</span><br><span class="line">Release:6.8</span><br></pre></td></tr></table></figure><ul><li>/etc/issue文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/redhat-release</span></span><br><span class="line">CentOS release 6.8 (Final)</span><br></pre></td></tr></table></figure><h3 id="启用Swap分区"><a href="#启用Swap分区" class="headerlink" title="启用Swap分区"></a>启用Swap分区</h3><p>在遇到内存容量瓶颈时，我们就可以尝试启用 Swap 分区。使用文件（还可以磁盘分区）作为 Swap 分区时，具体步骤如下：</p><p>1、 创建 Swap 分区的文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bs*count为文件大小</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/root/swapfile bs=1M count=1024</span></span><br></pre></td></tr></table></figure><p>2、 格式化为交换分区文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkswap /root/swapfile</span></span><br></pre></td></tr></table></figure><p>3、 启用交换分区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapon /root/swapfile</span></span><br></pre></td></tr></table></figure><p>4、 开机自启用 Swap 分区</p><p>在<code>/etc/fstab</code>文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p>最后，查看系统的 Swap 分区信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -h</span></span><br><span class="line">       total   used    free   shared  buff/cache   available</span><br><span class="line">Mem:   1.7G    729M    252M   9.2M    714M         763M</span><br><span class="line">Swap:  1.0G    0B      1.0G</span><br></pre></td></tr></table></figure><h3 id="免密码使用sudo"><a href="#免密码使用sudo" class="headerlink" title="免密码使用sudo"></a>免密码使用sudo</h3><p>以下两种需求：</p><ol><li>开发中经常会使用到 sudo 命令，为了避免频繁输入密码的麻烦；</li><li>脚本中使用到 sudo 命令，怎么输入密码？；</li></ol><p>这些，都可以通过将用户加入 sudoers 来解决，当然情况 2 也可以使用<code>echo &quot;passwd&quot;|sudo -S cmd</code>，从标准输入读取密码。</p><p>sudoers 配置文件为<code>/etc/sudoers</code>，sudo 命令操作权限配置内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 授权用户/组    主机名=（允许转换至的用户）   NOPASSWD:命令动作</span></span><br><span class="line">root ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p><a href="#">授权格式</a> 说明：</p><ul><li>第一个字段为授权用户或组，例如 root；</li><li>第二个字段为来源，() 中为允许转换至的用户，= 左边为主机名；</li><li>第三个字段为命令动作，多个命令以<code>,</code>号分割；</li></ul><p>因此，我的用户为<code>fhb</code>，授权步骤如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 执行visudo命令，操作的文件就是/etc/sudoers</span></span><br><span class="line">$ sudo visudo</span><br><span class="line"><span class="comment"># 2. 追加内容</span></span><br><span class="line">fhb ALL=(root) NOPASSWD: /usr/sbin/service,/usr/local/php/bin/php,/usr/bin/vim</span><br><span class="line"><span class="comment"># 3. Ctrl+O保存并按Enter</span></span><br></pre></td></tr></table></figure><p>然后，使用<code>sudo service ssh restart</code>命令测试 OK。</p><h3 id="Yum更新排除指定软件"><a href="#Yum更新排除指定软件" class="headerlink" title="Yum更新排除指定软件"></a>Yum更新排除指定软件</h3><p>有时候我们使用 yum 安装的软件，由于配置向后兼容性等问题，我们并不希望这些软件（filebeat 和 logstash）在使用<code>update</code>时，被不经意间被自动更新。这时，可以使用如下方法解决：</p><ul><li>临时</li></ul><p>通过<code>-x</code>或<code>--exclude</code>参数指定需要排除的包名称，多个包名称使用空格分隔。例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--exclude同样</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum -x filebeat logstash update</span></span><br></pre></td></tr></table></figure><ul><li>永久</li></ul><p>在 yum 配置文件<code>/etc/yum.conf</code>中，追加<code>exclude</code>配置项。例如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需排序的包名称</span></span><br><span class="line"><span class="attr">exclude</span>=filebeat logstash</span><br></pre></td></tr></table></figure><p>再次使用<code>yum update</code>命令，就不会自动更新指定的软件包了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum update</span></span><br><span class="line">No Packages marked for Update</span><br></pre></td></tr></table></figure><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="设置禁PING"><a href="#设置禁PING" class="headerlink" title="设置禁PING"></a>设置禁PING</h3><p>攻击者可能会通过端口扫面工具，而得出目标服务器监听的端口号，从而进行攻击。通过关闭 Linux 服务器的 <a href="http://baike.baidu.com/link?url=ovep8ysxoVKDCFTCvBxTtWMan-U-99q5sr3PZOuLPfqkr_eiAvO-g10LlU0lmMTLu7d41JA0UMv87p7Y8KCgpK">ICMP</a> 协议服务或者防火墙拦截 ICMP 协议包，可以达到禁用 ping 的目的。</p><p>a. 关闭ICMP服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all</span></span><br></pre></td></tr></table></figure><p>b. 防火墙拦截</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -p icmp -j DROP</span></span><br></pre></td></tr></table></figure><p>检查禁 ping 是否成功：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ping www.fanhaobai.com</span></span><br><span class="line">请求超时。</span><br><span class="line">请求超时。</span><br></pre></td></tr></table></figure><h3 id="修改SSH监听端口"><a href="#修改SSH监听端口" class="headerlink" title="修改SSH监听端口"></a>修改SSH监听端口</h3><p>默认情况下，SSH 监听 <strong>22</strong> 端口，这也使得攻击者可以轻松扫描到目标服务器是否运行 SSH 服务。所以建议将 SSH 端口号更改为大于 1024。</p><p>在文件<code>/etc/ssh/sshd_config</code>中，增加如下配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Port 22                # 保留22默认端口，防止端口配置失败，无法连接SSH</span><br><span class="line">Port 10086</span><br></pre></td></tr></table></figure><p>重启 SSH 服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service sshd restart</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -tunpl | grep sshd</span></span><br><span class="line"></span><br><span class="line">Proto Recv-Q Send-Q Local Address  Foreign Address  State    PID/Program name</span><br><span class="line">tcp   0      0      0.0.0.0:10086  0.0.0.0:*        LISTEN   2462/sshd   </span><br><span class="line">tcp   0      0      0.0.0.0:22     0.0.0.0:*        LISTEN   2462/sshd</span><br></pre></td></tr></table></figure><p>通过新端口 10086 连接 SSH，如果连接成功再删除默认端口 22 配置。</p><p>如果查看发现 10086 已被 sshd 监听，而仍然无法连接 SSH，则需添加防火墙规则：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-dport指操作端口号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -p tcp --dport 10086 -j ACCEPT</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久保存iptables规则</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etc/rc.d/init.d/iptables save</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启iptables</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etc/rc.d/init.d/iptables restart</span></span><br></pre></td></tr></table></figure><h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>使用密码登录 SSH，每次登录都需要频繁输入密码，所以比较麻烦，使用 SSH 的公钥登录，可以免去输入密码的步骤。</p><p>1、在本地主机上生成自己的公钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen</span></span><br></pre></td></tr></table></figure><p>执行命令后出现一系列提示，直接回车即可。会在<code>$HOME/.ssh</code>目录生成公钥和私钥文件，其中<code>id_rsa.pub</code>为你的公钥，<code>id_rsa</code>为你的私钥。</p><p>2、配置公钥到远程主机</p><p>远程主机将用户的公钥保存在<code>$HOME/.ssh/authorized_keys文件</code>，所以这里需要将上步生成的 <strong>公钥</strong> 文件<code>id_rsa.pub</code>的内容 <strong>追加</strong> 到<code>authorized_keys</code>文件中。</p><p>如果<code>authorized_keys</code>文件不存在，创建即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure><p>配置 sshd 服务，配置文件为<code>/etc/ssh/sshd_config</code>，将下面内容关闭注释。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后，重启 sshd 服务。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service sshd restart</span></span><br></pre></td></tr></table></figure><p>3、免密登录测试</p><p>这里通过配置 <strong>识别名</strong> ，连接时只需指定连接识别名即可，简单方便。</p><p>在<code>$HOME/.ssh</code>目录下创建<code>config</code>文件，并作如下配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host fhb</span><br><span class="line">HostName www.fanhaobai.com</span><br><span class="line">Port 10086</span><br><span class="line">User fhb</span><br></pre></td></tr></table></figure><p>使用识别名连接 SSH 登录远程主机，出现如下内容表示公钥登录成功。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh fhb</span></span><br><span class="line">Last login: Mon Feb 20 17:09:00 2017 from 103.233.131.130</span><br><span class="line"></span><br><span class="line">Welcome to aliyun Elastic Compute Service!</span><br></pre></td></tr></table></figure><h3 id="强制踢出其他登录用户"><a href="#强制踢出其他登录用户" class="headerlink" title="强制踢出其他登录用户"></a>强制踢出其他登录用户</h3><p>在某些情况下，需要强制踢出系统其他登录用户，比如遇到非法用户登录。查询当前登陆用户：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前用户</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span></span></span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前所有用户</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep <span class="string">&#x27;pts&#x27;</span></span></span><br><span class="line">root      4752  4727  0 00:09 pts/0    00:00:00 su www</span><br><span class="line">www       4755  4752  0 00:09 pts/0    00:00:00 bash</span><br></pre></td></tr></table></figure><p>剔除非法登陆用户：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -9 4755</span></span><br></pre></td></tr></table></figure><p>更多详细说明，见 <a href="https://www.fanhaobai.com/2016/11/out-users.html">Linux 强制踢出其他登录用户</a>。</p><h3 id="建立隧道实现端口转发"><a href="#建立隧道实现端口转发" class="headerlink" title="建立隧道实现端口转发"></a>建立隧道实现端口转发</h3><p>在可以使用 ssh 情况下，为了能进行线上调试，我们可以使用 ssh 隧道建立端口映射。</p><p>例如，线上远程目标机器 ip：10.1.1.123、端口：3303；映射到本地 33031 端口。命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[主机ip]:[端口]:[主机ip]:[远程目标机器端口] [远程目标机器ip]</span></span><br><span class="line">ssh -L 127.0.0.1:33031:127.0.0.1:3303 10.1.1.123</span><br></pre></td></tr></table></figure><blockquote><p>该命令操作后，只能通过<code>127.0.0.1</code>访问。若想全网段访问，需要将第一个主机 ip 更改为<code>0.0.0.0</code>，同时需要在<code>/etc/ssh/sshd_config</code>增加<code>GatewayPorts yes</code>的配置项。</p></blockquote><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Strace调试"><a href="#Strace调试" class="headerlink" title="Strace调试"></a>Strace调试</h3><p>在调试程序时，我们会遇到一些系统层面的错误问题，一般都不易发现，这时可以使用 strace 来跟踪系统调用的过程，方便快速定位和解决问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ strace crontab.sh</span><br><span class="line"><span class="title function_">execve</span><span class="params">(<span class="string">&quot;./crontab.sh&quot;</span>, [<span class="string">&quot;./crontab.sh&quot;</span>], [<span class="comment">/* 29 vars */</span>])</span> = <span class="number">0</span></span><br><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x106a000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f0434160000</span></span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">open(<span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY)      = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">53434</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">53434</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7f0434152000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">open(<span class="string">&quot;/lib64/libc.so.6&quot;</span>, O_RDONLY)      = <span class="number">3</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>更多详细说明，见 <a href="https://www.fanhaobai.com/2017/07/php-cli-setting.html#%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95https://www.fanhaobai.com/2016/11/out-users.html">错误调试</a>。</p><h3 id="彩色的命令行"><a href="#彩色的命令行" class="headerlink" title="彩色的命令行"></a>彩色的命令行</h3><p>在脚本或者代码中，有时候需要在控制终端输出醒目的提示信息，以便引起我们的关注。其实，在 Linux 终端下很容易就能搞定，如下：</p><p><img src="//www.fanhaobai.com/2018/02/linux-skill/7bb99049-49bd-427b-a338-3afff4268fb3.jpg" alt="彩色的命令行"></p><p>实现的源代码，内容为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;30m Hello World. \033[0m [高亮]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0;31m Hello World. \033[0m [关闭属性]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[4;32m Hello World. \033[0m [下划线]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[5;33m Hello World. \033[0m [闪烁]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[7;34m Hello World. \033[0m [反显]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[8;35m Hello World. \033[0m [消隐]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0;36;40m Hello World.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0;37;41m Hello World.&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>\033</code>是 Esc 键对应的 ASCII 码（27=/033=0x1B），表示后面的内容具有特殊含义，类似表述有<code>^[</code>以及<code>/e</code>，而<code>\033[0m</code>表示清除格式控制。</p></blockquote><p>输出格式的规则，可表示为<code>\033[特殊格式;前景色;背景色m</code>，主要分为 <a href="#">颜色</a> 和 <a href="#">格式</a> 两类规则。</p><ul><li>颜色</li></ul><p>主要包括 <a href="#">前景色</a> 和 <a href="#">背景色</a>，前景色范围为<code>30~39</code>，背景色范围为<code>40~49</code>（前景色对应颜色值 +10）。前景色颜色代码表如下：</p><div><span style="color:black;">黑   = "\033[30m"</span><span style="color:red;">红   = "\033[31m"</span><span style="color:green;">绿   = "\033[32m"</span><span style="color:yellow;">黄   = "\033[33m"</span><span style="color:blue;">蓝   = "\033[34m"</span><span style="color:purple;">紫   = "\033[35m"</span><span style="color:cyan;">青 = "\033[36m"</span><span style="color:white;">白   = "\033[37m"</span></div><ul><li>格式</li></ul><table><thead><tr><th>表达式</th><th>格式</th></tr></thead><tbody><tr><td>\033[0m</td><td>关闭所有属性</td></tr><tr><td>\033[1m</td><td>高亮度</td></tr><tr><td>\033[4m</td><td>下划线</td></tr><tr><td>\033[5m</td><td>闪烁</td></tr><tr><td>\033[7m</td><td>反显</td></tr><tr><td>\033[8m</td><td>消隐</td></tr></tbody></table><p><strong>更新 <a href="#">»</a></strong></p><ul><li><a href="#%E5%85%8D%E5%AF%86%E7%A0%81%E4%BD%BF%E7%94%A8sudo">免密码使用 sudo</a>（2018-04-12）</li><li><a href="#%E5%BD%A9%E8%89%B2%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C">彩色的命令行</a>（2018-08-14）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为技术人员，Linux 系统可以说是我们使用最多的操作系统，但我们可能并不是很了解它。在这里我将自己日常遇到的 Linux 使用技巧记录下来，方便以后查询使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/02/linux-skill/2a82ad6b-ab25-409f-858c-22312826ac06.jpg&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.fanhaobai.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.fanhaobai.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>自如2018新年活动系统 — 抢红包</title>
    <link href="https://www.fanhaobai.com/2018/01/2018-new-year-activity.html"/>
    <id>https://www.fanhaobai.com/2018/01/2018-new-year-activity.html</id>
    <published>2018-01-30T00:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.685Z</updated>
    
    <content type="html"><![CDATA[<p>2017 年是自如快速增长的一年，自如客突破 100 万，管理资产达到 50 万间，在年底成功获得了 40 亿 A 轮融资，而这些都要感谢广大的自如客，公司为了回馈自如客，在六周年活动时就发放了 6000 万租住基金，当然年底散币活动也够疯狂。</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/a3f34d9b-55cd-4931-8557-63f9b6767a79.jpg" alt="2018口碑年"><span id="more"></span></p><h2 id="活动规模"><a href="#活动规模" class="headerlink" title="活动规模"></a>活动规模</h2><p>既然公司对自如客这么阔，那对我们员工也得够意思，所以年底我们共准备了 3 个活动。</p><p>1、针对 <a href="#">自如客</a> 的服务费减免活动；<br>2、针对 <a href="#">自如客</a> 的 1000 万现金礼包；<br>3、25 万的 <a href="#">员工</a> 红包活动；</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/b19eec7a-978b-4ddc-8c8b-13c643c27b48.png" alt="员工红包活动"></p><p>散币活动 2 和 3 是通过微信红包形式进行，想散币就散吧，可微信告诉我们，想散币还得交税（&gt;﹏&lt;）。员工红包来说，25 万要交掉 10 多万税，此时心疼我的钱。好了，下面开始说点正事。</p><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>说到红包，我们肯定会想到红包拆分和抢红包两个场景。红包拆分是指将指定金额拆分为指定数目红包的过程，即是用来确定每个红包的金额数；而抢红包就是典型的高并发场景，需要避免红包超发的情况。</p><h3 id="红包拆分"><a href="#红包拆分" class="headerlink" title="红包拆分"></a>红包拆分</h3><h4 id="可选的方案"><a href="#可选的方案" class="headerlink" title="可选的方案"></a>可选的方案</h4><p><strong>拆分方式</strong></p><p>1、<a href="#">实时拆分</a><br>实时拆分，指的是在抢红包时实时计算每个红包的金额，以实现红包的拆分过程，对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分红包的金额服从正态分布规律。</p><p>2、<a href="#">预先生成</a><br>预先生成，指的是在红包开抢之前已经完成了红包的拆分，抢红包时只是依次取出拆分好的红包金额，对拆分算法要求较低，可以拆分出随机性很好的红包金额，通常需要结合队列使用。</p><p><strong>拆分算法</strong></p><p>我并没有找到业界的通用算法，但红包拆分算法应该是拆分金额要看起来随机，最好能够服从正态分布，可以参考 <a href="https://www.zybuluo.com/yulin718/note/93148">微信</a> 和  <a href="https://www.fanhaobai.com/2017/02/reward.html">@lcode</a> 提供的红包拆分算法。</p><p>微信拆分算法的优点是算法较简单，拆分效率高，同时，由于该算法天然的特性，可以保证后续红包金额一定不为空，特别适合实时拆分场景，但缺点是会导致大额红包较大概率地在拆分的最后出现。 <a href="#">@lcode</a> 拆分算法的优点是拆分金额基本符合正态分布，适合随机性要求较高的拆分场景。</p><h4 id="我们的方案"><a href="#我们的方案" class="headerlink" title="我们的方案"></a>我们的方案</h4><p>我们这次的业务对红包金额的随机性要求不高，但是对系统可靠性要求较高，所以我们选用了预算生成方式，使用 <a href="#">二倍均值法</a> 的红包拆分算法，作为我们的红包拆分方案。</p><p>采用预算生成方式，我们预先生成红包并放入 Redis 的 List 中，当抢红包时只是 Pop List 即可，具体实现将在 <a href="#%E6%8A%A2%E7%BA%A2%E5%8C%85">抢红包</a> 部分介绍。</p><p>拆分算法可以描述为：假设剩余拆分金额为 M，剩余待拆分红包个数为 N，红包最小金额为 1 元，红包最小单位为元，那么定义当前红包的金额为：</p><p>$$m = rand(1, floor(M/N*2))$$</p><p>其中，floor 表示向下取整，rand(min, max) 表示从 [min, max] 区间随机一个值。$M/N \ast 2$ 表示剩余待拆分金额平均金额的 2 倍，因为 N &gt;= 2，所以 $M/N \ast 2 &lt;= M$，表示一定能保证后续红包能拆分到金额。</p><p>代码实现为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$N</span> - <span class="number">1</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$max</span> = (<span class="keyword">int</span>)<span class="title function_ invoke__">floor</span>(<span class="variable">$M</span> / (<span class="variable">$N</span> - <span class="variable">$i</span>)) * <span class="number">2</span>;</span><br><span class="line">    <span class="variable">$m</span>[<span class="variable">$i</span>] = <span class="variable">$max</span> ? <span class="title function_ invoke__">mt_rand</span>(<span class="number">1</span>, <span class="variable">$max</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$M</span> -= <span class="variable">$m</span>[<span class="variable">$i</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$m</span>[] = <span class="variable">$M</span>;</span><br></pre></td></tr></table></figure><p>值得一提的是，我们为了保证红包金额差异尽量小，先将总金额平均拆分成 N+1 份，将第 N+1 份红包按照上述的红包拆分算法拆分成 N 份，这 N 份红包加上之前的平均金额才作为最终的红包金额。</p><h3 id="抢红包"><a href="#抢红包" class="headerlink" title="抢红包"></a>抢红包</h3><h4 id="可选的方案-1"><a href="#可选的方案-1" class="headerlink" title="可选的方案"></a>可选的方案</h4><p><strong>限流</strong></p><p>1、<a href="#">前端限流</a><br>前端限制用户在 n 秒之内只能提交一次请求，虽然这种方式只能挡住小白，不过这是 99% 的用户哟，所以也必须得做。</p><p>2、<a href="#">后端限流</a><br>常用的后端限流方法有 <a href="https://www.cnblogs.com/shanyou/p/4280546.html">漏桶算法</a> 和 <a href="https://www.cnblogs.com/shanyou/p/4280546.html">令牌桶算法</a>。<a href="https://en.wikipedia.org/wiki/Leaky_bucket">漏桶算法</a> 主要目的是控制请求数据注入的速率，如果此时漏桶溢出，后续的请求数据会被丢弃。而 <a href="https://en.wikipedia.org/wiki/Token_bucket">令牌桶算法</a> 是以一个恒定的速度往桶里放入令牌，而如果请求数据需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌时，这些请求才被丢弃，令牌桶算法的一个好处是可以方便地改变应用接受请求的速率。</p><p><strong>防超发</strong></p><p>1、<a href="#">库存加锁</a><br>可以通过加锁的方式解决资源抢占问题，但是加锁会增加系统开销，大流量下更容易拖垮系统，不过可以尝试一下基于版本号的乐观锁。</p><p>2、<a href="#">通过高速队列串行化请求</a><br>之所会出现超发问题，是因为并发时会出现多个进程同时获取同一资源的现象，如果使用高速队列将并行请求串行化，那么问题就不存在了。高速队列可以使用 Redis 缓存服务器来实现，当然光使用队列还不够，必要保证整个流程调用链要短、要快，否则队列会积压严重，甚至会拖垮整个服务。</p><h4 id="我们的方案-1"><a href="#我们的方案-1" class="headerlink" title="我们的方案"></a>我们的方案</h4><p>在限流方面，由于我们预估的请求量还在系统承受范围，所以没有考虑引入后端限流方案。我们的抢红包系统流程图如下：</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/f405ee75-8e06-4f72-a8c5-60a155cc0ead.png" alt="抢红包流程图"></p><p>我们将抢红包拆分为 <a href="#">红包占有</a>（流程①，同步） 和 <a href="#">红包发放</a> （流程②，异步）这两个过程，首先采用高速队列串行化请求，红包发放逻辑由一组 Worker 异步去完成。高速队列只是完成红包占有的过程，实现库存的控制，Worker 则处理耗时较长的红包发放过程。</p><p>当然，在实际应用中，红包占用过程还需要加上一些前置规则校验，比如用户是否已经领取过，领取次数是否已经达到上限等？红包占有流程图如下：</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/3a9dff7a-71f1-4d9d-a576-a3dcbaf65c9b.png" alt="红包占有流程图"></p><p>其中，<code>red::list</code>为 List 结构，存放预先生成的红包金额（流程①中的红包队列）；<code>red::task</code> 也为 List 结构，红包异步发放队列（流程②中的任务队列）；<code>red::draw</code>为 Hash 结构，存放红包领取记录，<code>field</code>为用户的 openid，<code>value</code>为序列化的红包信息；<code>red::draw_count:u:openid</code>为 k-v 结构，用户领取红包计数器。</p><p>下面，我将以以下 3 个问题为中心，来说说我们设计出的抢红包系统。</p><p>1、<a href="#">怎么保证不超发</a><br>我们需要关注的是红包占有过程，从红包占有流程图可看出，这个过程是很多 Key 操作的组合，那怎么保证原子性？可以使用 Redis 事务，但我们选用了 Lua 方案，一方面是因为首先要保证性能，而 Lua 脚本嵌入 Redis 执行不存在性能瓶颈，另一方面 Lua 脚本执行时本身就是原子性的，满足需求。</p><p>红包占有的 Lua 脚本实现如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 领取人的openid为xxxxxxxxxxx</span></span><br><span class="line"><span class="keyword">local</span> openid = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span></span><br><span class="line"><span class="keyword">local</span> isDraw = redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, <span class="string">&#x27;red::draw&#x27;</span>, openid)</span><br><span class="line"><span class="comment">-- 已经领取</span></span><br><span class="line"><span class="keyword">if</span> isDraw ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 领取太多次了</span></span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">&#x27;INCR&#x27;</span>, <span class="string">&#x27;red::draw_count:u:&#x27;</span>..openid)</span><br><span class="line"><span class="keyword">if</span> times <span class="keyword">and</span> <span class="built_in">tonumber</span>(times) &gt; <span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> number = redis.call(<span class="string">&#x27;RPOP&#x27;</span>, <span class="string">&#x27;red::list&#x27;</span>)</span><br><span class="line"><span class="comment">-- 没有红包</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> number <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 领取人昵称为Fhb,头像为https://xxxxxxx</span></span><br><span class="line"><span class="keyword">local</span> red = &#123;money=number,name=<span class="string">&#x27;Fhb&#x27;</span>,pic=<span class="string">&#x27;https://xxxxxxx&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 领取记录</span></span><br><span class="line">redis.call(<span class="string">&#x27;HSET&#x27;</span>, <span class="string">&#x27;red::draw&#x27;</span>, openid, cjson.encode(red))</span><br><span class="line"><span class="comment">-- 处理队列</span></span><br><span class="line">red[<span class="string">&#x27;openid&#x27;</span>] = openid</span><br><span class="line">redis.call(<span class="string">&#x27;RPUSH&#x27;</span>, <span class="string">&#x27;red::task&#x27;</span>, cjson.encode(red))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意 Lua 脚本执行过程并不是事务的，脚本中的操作命令在执行时是有先后顺序的，当某个操作执行失败时不会回滚已经执行成功的操作，它的原子性是通过单线程模型实现。</p></blockquote><p>2、<a href="#">怎么提高系统响应速度</a><br>如红包占有流程图所示，当用户发起抢红包请求时，若有红包则直接完成红包占有操作，同步告知用户是否抢到红包，这个过程要求快速响应。</p><p>但由于微信红包支付属于第三方调用，若抢到红包后同步调用红包支付，系统调用链又长又慢，所以红包占有和红包发放异步拆分是必然。拆分后，红包占有只需操作 Redis，响应性能已不是问题。</p><p>3、<a href="#">怎么提高系统处理能力</a><br>从上述分析可知，目前系统的压力都会集中在红包发放这个环节，因为用户抢到红包时，我们只是同步告知用户已抢到红包，然后异步去发放红包，因此用户并不会立即收到红包（受红包发放 Worker 处理能力和微信服务压力制约）。若红包发放的 Worker 处理能力较弱，那么红包发放的延迟就会很高，体验较差。</p><p>如抢红包流程图中所示，我们采用一组 Worker 去消费任务队列，并调用红包支付 API，以及数据持久化操作（后续对账）。尽管红包发放调用链又长又慢，但是注意到这些 Worker 是 <a href="#">无状态</a> 的，所以可以通过增加 Worker 数量，以横向扩展提高系统的处理能力。</p><p>4、<a href="#">怎么保证数据一致性</a><br>其实，红包发放延时我们可以做到用户无感知，但是若红包发放（流程②）失败了，已经告知用户抢到红包，但是却木有发，估计他杀人的心都有了。根据 CAP 原理，我们无法同时满足数据一致性、数据可用性、分区耐受性，通常只需做到数据最终一致性。</p><p>为了达到数据最终一致性，我们就引入了重试机制，生成一个全局唯一的外部订单号，当某单红包发放失败，就会放回任务队列，使得有机会进行发放重试，当然这一切都需要 API 做幂等处理。</p><h3 id="Worker可靠性保障"><a href="#Worker可靠性保障" class="headerlink" title="Worker可靠性保障"></a>Worker可靠性保障</h3><p>这里必须将 Worker 可靠性单独说，因为它实在太重要了。Worker 的实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$maxTask</span> = <span class="number">1000</span>;</span><br><span class="line"><span class="variable">$sleepTime</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$red</span> = <span class="title class_">RedLogic</span>::<span class="title function_ invoke__">getTask</span>()) &#123;</span><br><span class="line">        <span class="title class_">RedLogic</span>::<span class="title function_ invoke__">doTask</span>(<span class="variable">$red</span>);</span><br><span class="line">        <span class="comment">//处理多少个任务主动退出</span></span><br><span class="line">        <span class="variable">$maxTask</span>--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$maxTask</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EXIT_CODE_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待任务</span></span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="variable">$sleepTime</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 LPOP 命令获取任务，所以使用了 while 结构，并且无任务时需要等待，可以用阻塞命令 BLPOP 来改进。</p></blockquote><p>由于 Worker 需要常驻内存运行，难免会出现异常退出的情况（也有主动退出）， 所以需要保持 Worker 一直处于运行状态。我们使用进程管理工具 <a href="https://www.fanhaobai.com/2017/09/supervisor.html">Supervisor</a> 来监控 Worker 的运行状态，同时管理 Worker 的数量，当任务队列出现堆积时，增加 Worker 数量即可。Supervisor 的监控后台如下：</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/9a15f5d1-0983-4155-80e4-ba55e5543672.png" alt="Supervisor进程管理"></p><h3 id="员工系统号散列"><a href="#员工系统号散列" class="headerlink" title="员工系统号散列"></a>员工系统号散列</h3><p>公司员工都用唯一一个系统号 emp_code（自增字段）标识，登录成功后返回 emp_code，系统后续所有交互流程都基于 emp_code，分享出去的红包也会携带 emp_code，为了保护员工敏感信息和防止恶意碰撞攻击，我们不能直接将 emp_code 暴露给前端，需要借助一个 token（无规律）的中间者来完成交互。</p><h4 id="可选的方案-2"><a href="#可选的方案-2" class="headerlink" title="可选的方案"></a>可选的方案</h4><p>1、<a href="#">储存映射关系，时时查询</a><br>预先生成一个随机串 token，然后跟 emp_code 绑定，每次请求都根据 token 时时查询 emp_code。优点是可以定期更新，相对安全，缺点是性能不高。</p><p>2、<a href="#">建立映射关系函数，实时计算</a><br>建立一个映射关系函数，如 hash 散列或者加密解密算法，能够根据 emp_code 生成一个无规律的字符串 token，并且要能够根据 token 反映射出 emp_code。优点是需要存储介质存储关系，性能较高，缺点是很难做到定期失效并更新。</p><h4 id="我们的方案-2"><a href="#我们的方案-2" class="headerlink" title="我们的方案"></a>我们的方案</h4><p>由于我们的红包活动只进行几天，所以我们选用了方案 2。对 emp_code 做了 <a href="http://hashids.org/php/">hashids</a> 散列算法，暴露的只是一串无规律的散列字符串。</p><p>hashids 是一个开源且轻量的唯一 id 生成器，支持 Java、PHP、C/C++、Python 等主流语言，PHP 想使用 hashids，只需<code>composer require hashids/hashids</code>命令安装即可。</p><p>然后，如下方式使用：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Hashids</span>\<span class="title">Hashids</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$hashids</span> = <span class="keyword">new</span> <span class="title class_">Hashids</span>(<span class="string">&#x27;salt&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;abcdefghijk1234567890&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$hashids</span>-&gt;<span class="title function_ invoke__">encode</span>(<span class="number">11002</span>);    <span class="comment">//994k2kk</span></span><br><span class="line"><span class="variable">$hashids</span>-&gt;<span class="title function_ invoke__">decode</span>(<span class="string">&#x27;994k2kk&#x27;</span>);  <span class="comment">//[11002]</span></span><br></pre></td></tr></table></figure><p>需要说明的是，其中<code>salt</code>是非常重要的散列加密盐串，<code>6</code>表示散列值最小长度，<code>abcde...7890</code>为散列字典，太长影响效率，太短不安全。由于默认的散列字典比较长，decode 效率并不高，所以这里移除了大写字母部分。</p><h3 id="语音点赞"><a href="#语音点赞" class="headerlink" title="语音点赞"></a>语音点赞</h3><p>语音点赞就是用户以语音的形式助力好友，核心技术其实是语音识别，而我们一般都会使用第三方语音识别服务。</p><h4 id="可选的方案-3"><a href="#可选的方案-3" class="headerlink" title="可选的方案"></a>可选的方案</h4><p>1、<a href="#">客户端调用第三方服务识别</a><br>客户端直接调用第三方语音识别服务，如微信提供了 JS-SDK 的语音识别 <a href="http://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3#.E8.AF.86.E5.88.AB.E9.9F.B3.E9.A2.91.E5.B9.B6.E8.BF.94.E5.9B.9E.E8.AF.86.E5.88.AB.E7.BB.93.E6.9E.9C.E6.8E.A5.E5.8F.A3">API</a> ，返回识别的语音文本的信息，并且已经经过语义化。优点是识别较快，且不许关注语音存储问题，缺点是不安全，识别结果提交到服务端之前可能被恶意篡改。</p><p>2、<a href="#">服务端调用第三方服务识别</a><br>先将录制的语音上传至存储平台，然后服务端调用第三方语音识别服务，第三方语音识别服务去获取语音信息并识别，返回识别的语音文本的信息。优点是识别结果较安全，缺点是系统交互较多，识别效率不高。</p><h4 id="我们的方案-3"><a href="#我们的方案-3" class="headerlink" title="我们的方案"></a>我们的方案</h4><p>我们业务场景的特殊性，存在用户可助力次数的限制，所以无需担心恶意刷赞的情况，因此可以选用方案 1，语音识别的交互流程如下：</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/de5070ca-fd29-493e-b433-28520a8aaa1a.png" alt="语音识别交互图"></p><p>此时，整个语音识别流程如下：</p><p><img src="//www.fanhaobai.com/2018/01/2018-new-year-activity/9cf63edb-315e-4951-9d7f-531953741e52.png" alt="语音点赞流程图"></p><p>当然中国文字博大精深，语音识别的文本在匹配时，需要考虑容错处理，可以将文本转化为拼音，然后匹配拼音，或者设置一个匹配百分比，达到匹配值则认为语音口令正确。</p><blockquote><p>需要注意的是，微信只提供 3 天的语音存储服务，若语音播放周期较长，则要考虑实现语音的存储。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="红包发放测试"><a href="#红包发放测试" class="headerlink" title="红包发放测试"></a>红包发放测试</h3><p>我们使用了线上公账号进行红包发放测试，为了让线上公众号能够授权到测试环境，在线上的微信授权回调地址新增一个参数，将带有<code>to=feature</code>参数的请求引流到测试环境，其他线上流量还是保持不变，匹配规则如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx不支持if嵌套，所以就这样变通实现</span></span><br><span class="line"><span class="attribute">set</span> <span class="variable">$auth_redirect</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$args</span> <span class="regexp">~* &quot;r=auth/redirect&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$auth_redirect</span> <span class="string">&quot;prod&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$args</span> <span class="regexp">~* &quot;to=feature&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$auth_redirect</span> <span class="string">&quot;feature&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$auth_redirect</span> <span class="regexp">~ &quot;feature&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> http://wx.t.ziroom.com/index.php <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$auth_redirect</span> <span class="regexp">~ &quot;prod&quot;)</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> http://wx.ziroom.com/index.php <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>由于本次活动力度较大，预估流量会比以往增加不少（不能再出现机房带宽打满的情况了，不然 &gt;﹏&lt;），静态页面占流量的很大一部分，所以静态页面在发布时都会放置一份在 CDN 上，这样回源的流量就很小了。</p><h3 id="灾备方案"><a href="#灾备方案" class="headerlink" title="灾备方案"></a>灾备方案</h3><p>尽管做了很多准备，还是无法确保万无一失，我们在每个关键节点都增加了开关，一点出现异常，通过配置中心可以人工介入做降级处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 年是自如快速增长的一年，自如客突破 100 万，管理资产达到 50 万间，在年底成功获得了 40 亿 A 轮融资，而这些都要感谢广大的自如客，公司为了回馈自如客，在六周年活动时就发放了 6000 万租住基金，当然年底散币活动也够疯狂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2018/01/2018-new-year-activity/a3f34d9b-55cd-4931-8557-63f9b6767a79.jpg&quot; alt=&quot;2018口碑年&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ELK集中式日志平台之三 —  进阶</title>
    <link href="https://www.fanhaobai.com/2017/12/elk-advanced.html"/>
    <id>https://www.fanhaobai.com/2017/12/elk-advanced.html</id>
    <published>2017-12-22T15:12:00.000Z</published>
    <updated>2024-04-18T08:38:12.680Z</updated>
    
    <content type="html"><![CDATA[<p>部署 <a href="https://www.fanhaobai.com/2017/12/elk-install.html">ELK</a> 后，日志平台就搭建完成了，基本上可以投入使用，但是其配置并不完善，也并未提供实时监控和流量分析功能，本文将对 ELK 部署后的一些常见使用问题给出解决办法。<br><img src="//www.fanhaobai.com/2017/12/elk-advanced/993155ac-718b-4e4b-9d36-d9d73357b162.png" alt="预览图"><span id="more"></span></p><h2 id="Elasticsearch证书"><a href="#Elasticsearch证书" class="headerlink" title="Elasticsearch证书"></a>Elasticsearch证书</h2><p>为了获得 Elasticsearch 更好的体验，我们需要获得 <a href="https://register.elastic.co/registration">Elastic</a> 的使用授权，安装颁发的永久 License 证书。</p><p>首先，前往 <a href="https://register.elastic.co/registration">registration</a> 地址注册，稍后我们会收到 License 的下载地址：</p><p><img src="https://www.fanhaobai.com/2017/12/elk-advanced/0f9b0271-108b-47d4-acc2-6fde4e4f9ff7.png" alt="邮件"></p><p>接着，点击邮件中的 <a href="http://license.elastic.co/registration/download/de804a8e-97e1-478b-a843-613aecac1a6e">地址</a> 下载 License 文件，并另存为<code>fan-haobai-dbc3f18c-f87e-40e4-9a1d-f496e58a591e-v5.json</code>：</p><p><img src="https://www.fanhaobai.com/2017/12/elk-advanced/c618f544-7093-4530-9bda-b63ab58832ea.png" alt="License文件"></p><p>然后，通过 Elasticsearch 的 API 更新 License：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名前有@符号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -XPOST http://127.0.0.1:9200/_xpack/license/start_basic?acknowledge=<span class="literal">true</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d @fan-haobai-dbc3f18c-f87e-40e4-9a1d-f496e58a591e-v5.json</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回如下信息则成功</span></span><br><span class="line">&#123;&quot;acknowledged&quot;:true,&quot;basic_was_started&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="http://elk.fanhaobai.com/app/kibana#/management/elasticsearch/license_management">Kibana</a> 查看新的证书信息：</p><p><img src="https://www.fanhaobai.com/2017/12/elk-advanced/575f23bd-f21a-4b53-a7f3-5581f9c25c01.png" alt="证书信息"></p><h2 id="Logstash管道进阶"><a href="#Logstash管道进阶" class="headerlink" title="Logstash管道进阶"></a>Logstash管道进阶</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a><a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input</a></h3><p>Input 插件指定了 Logstash 事件的输入源，已经支持 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-beats.html">beats</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html">kafka</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-redis.html">redis</a> 等源的输入。</p><p>例如，配置 Beats 源为输入，且端口为 5044：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123; port =&gt; 5044 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 插件主要功能是数据过滤和格式化，通过简洁的表达式就可以完成数据的处理。</p><p>以下这些配置信息，为插件共有配置：</p><table><thead><tr><th>配置项</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>add_field</td><td>hash</td><td>添加字段</td></tr><tr><td>add_tag</td><td>array</td><td>添加标签</td></tr><tr><td>remove_field</td><td>array</td><td>删除字段</td></tr><tr><td>remove_tag</td><td>array</td><td>删除标签</td></tr></tbody></table><h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-drop.html">Drop</a> 插件用来过滤掉无价值的数据，例如过滤掉静态文件日志信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [url] =~ <span class="string">&quot;\.(jpg|jpeg|gif|png|bmp|swf|fla|flv|mp3|ico|js|css|woff)&quot;</span> &#123;</span><br><span class="line">    drop &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>我们可以用 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html">Date</a> 插件来格式化时间字段。</p><p>例如，将 time 字段值格式化为<code>dd/MMM/YYYY:H:m:s Z</code>形式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> &#123; match =&gt; [ <span class="string">&quot;[time]&quot;</span>, <span class="string">&quot;dd/MMM/YYYY:H:m:s Z&quot;</span> ] &#125;</span><br></pre></td></tr></table></figure><h4 id="Mutate"><a href="#Mutate" class="headerlink" title="Mutate"></a>Mutate</h4><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html">Mutate</a> 插件用来对字段进行 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-rename">rename</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-replace">replace</a> 、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-merge">merge</a> 以及字段值 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-convert">convert</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-split">split</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-mutate.html#plugins-filters-mutate-join">join</a> 操作。</p><p>例如，将字段<code>@timestamp</code>重命名（rename 或 replace）为 read_timestamp：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123; rename =&gt; &#123; <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="string">&quot;read_timestamp&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>以下是对字段值的操作，使用频率较高。</p><ul><li>字段值类型转换（convert）</li></ul><p>例如，将 response_code 字段值转换为整型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123; convert =&gt; &#123; <span class="string">&quot;fieldname&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>字符串分割为数组（split）</li></ul><p>例如，将经纬度坐标用数组表示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123; <span class="built_in">split</span> =&gt; &#123; <span class="string">&quot;location&quot;</span> =&gt; <span class="string">&quot;,&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>数组合并为字符串（join）</li></ul><p>例如，将经纬度坐标合并：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123; <span class="built_in">join</span> =&gt; &#123; <span class="string">&quot;location&quot;</span> =&gt; <span class="string">&quot;,&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="Kv"><a href="#Kv" class="headerlink" title="Kv"></a>Kv</h4><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-kv.html">Kv</a> 插件能够对 key=value 格式的字符进行格式化或过滤处理，这里只对 field_split 项配置进行说明，更多配置见 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-kv.html#plugins-filters-kv-options">Kv Filter Configuration Options</a>。</p><p>例如，获取形如<code>?name=cat&amp;type=2</code>GET 请求的参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kv &#123; field_split =&gt; <span class="string">&quot;&amp;?&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>处理后，将会获取到以下 2 个参数：</p><ul><li><code>name: cat</code></li><li><code>type: 2</code></li></ul><h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h4><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json.html">Json</a> 插件当然是用来解析 Json 字符串，而 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json_encode.html">Json_encode</a> 插件是对字段编码为 Json 字符串。例如，Nginx 日志为 Json 格式，则：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">json &#123; <span class="built_in">source</span> =&gt; <span class="string">&quot;message&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="Grok"><a href="#Grok" class="headerlink" title="Grok"></a>Grok</h4><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html">Grok</a> 插件可以根据指定的表达式 <a href="#">结构化</a> 文本数据，表达式需形如<code>%&#123;SYNTAX:SEMANTIC&#125;</code>格式，SYNTAX 指定字段值类型，可以为 IP、WORD、DATA、NUMBER 等。</p><p>例如，形如<code>55.3.244.1 GET /index.html 15824 0.043</code>的请求日志，则对应的表达式应为<code>%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;WORD:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;</code>，配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grok &#123;</span><br><span class="line">    match =&gt; &#123; <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;WORD:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 Grok 过滤后，输出为：</p><ul><li><code>client: 55.3.244.1</code></li><li><code>method: GET</code></li><li><code>request: /index.html</code></li><li><code>bytes: 15824</code></li><li><code>duration: 0.043</code></li></ul><p>我们可以使用 <a href="http://grokdebug.herokuapp.com/">Grok Debug</a> 在线调试 Grok 表达式，常用 Nginx、MySQL、Redis 日志的 Grok 表达式见 <a href="https://www.elastic.co/guide/en/logstash/current/logstash-config-for-filebeat-modules.html">Configuration Examples</a> 部分。</p><blockquote><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-useragent.html">useragent</a> 插件用来解析用户客户端信息，<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-geoip.html">geoip</a> 插件可以根据 IP 地址解析出用户所在的地址位置，配置较简单，这里不做说明。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output 插件配置 Logstash 输出对象，可以为 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html">elasticsearch</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-email.html">email</a>、<a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-file.html">file</a> 等介质。</p><p>例如，配置过滤后存储在 Elasticsearch 中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">        manage_template =&gt; <span class="literal">false</span></span><br><span class="line">        index =&gt; <span class="string">&quot;%&#123;[@metadata][type]&#125;-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">        document_type =&gt; <span class="string">&quot;%&#123;[fields][env]&#125;&quot;</span></span><br><span class="line">        template_name =&gt; <span class="string">&quot;logstash&quot;</span></span><br><span class="line">        user =&gt; <span class="string">&quot;elastic&quot;</span></span><br><span class="line">        password =&gt; <span class="string">&quot;changeme&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Output 插件不只是可以将过滤数据输出到一种介质，还可以同时指定多种介质。 </p><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p>实现基于 Nginx 日志进行过滤处理，并且通过 useragent 和 geoip 插件获取用户客户端和地理位置信息。详细配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    beats &#123; port =&gt; 5044 &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    <span class="keyword">if</span> [fileset][module] == <span class="string">&quot;nginx&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> [fileset][name] == <span class="string">&quot;access&quot;</span> &#123;</span><br><span class="line">            grok &#123;</span><br><span class="line">                match =&gt; &#123; <span class="string">&quot;message&quot;</span> =&gt; [<span class="string">&quot;%&#123;IPORHOST:[@metadata][remote_ip]&#125; - %&#123;DATA:[user_name]&#125; \[%&#123;HTTPDATE:[time]&#125;\] \&quot;%&#123;WORD:[method]&#125; %&#123;DATA:[url]&#125; HTTP/%&#123;NUMBER:[http_version]&#125;\&quot; %&#123;NUMBER:[response_code]&#125; %&#123;NUMBER:[body_sent][bytes]&#125; \&quot;%&#123;DATA:[referrer]&#125;\&quot; \&quot;%&#123;DATA:[@metadata][agent]&#125;\&quot;&quot;</span>] &#125;</span><br><span class="line">                remove_field =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            grok &#123;</span><br><span class="line">                match =&gt; &#123; <span class="string">&quot;referrer&quot;</span> =&gt; <span class="string">&quot;%&#123;URIPROTO&#125;://%&#123;URIHOST:referrer_domain&#125;&quot;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> [url] =~ <span class="string">&quot;\.(jpg|jpeg|gif|png|bmp|swf|fla|flv|mp3|ico|js|css|woff)&quot;</span> &#123;</span><br><span class="line">                drop &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mutate &#123; add_field =&gt; &#123; <span class="string">&quot;read_timestamp&quot;</span> =&gt; <span class="string">&quot;%&#123;@timestamp&#125;&quot;</span> &#125; &#125;</span><br><span class="line">            <span class="built_in">date</span> &#123; match =&gt; [ <span class="string">&quot;[time]&quot;</span>, <span class="string">&quot;dd/MMM/YYYY:H:m:s Z&quot;</span> ] &#125;</span><br><span class="line">            useragent &#123;</span><br><span class="line">                <span class="built_in">source</span> =&gt; <span class="string">&quot;[@metadata][agent]&quot;</span></span><br><span class="line">                target =&gt; <span class="string">&quot;useragent&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            geoip &#123;</span><br><span class="line">                <span class="built_in">source</span> =&gt; <span class="string">&quot;[@metadata][remote_ip]&quot;</span></span><br><span class="line">                target =&gt; <span class="string">&quot;geoip&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> [fileset][name] == <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">            grok &#123;</span><br><span class="line">                match =&gt; &#123; <span class="string">&quot;message&quot;</span> =&gt; [<span class="string">&quot;%&#123;DATA:[time]&#125; \[%&#123;LOGLEVEL:[level]&#125;\] %&#123;POSINT:[pid]&#125;#%&#123;NUMBER:[tid]&#125;: %&#123;GREEDYDATA:[error_message]&#125;(?:, client: %&#123;IPORHOST:[ip]&#125;)(?:, server: %&#123;IPORHOST:[server]&#125;?)(?:, request: \&quot;%&#123;WORD:[method]&#125; %&#123;DATA:[url]&#125; HTTP/%&#123;NUMBER:[http_version]&#125;\&quot;)?(?:, upstream: %&#123;WORD:[upstream]&#125;)?(?:, host: %&#123;QS:[request_host]&#125;)?(?:, referrer: \&quot;%&#123;URI:[referrer]&#125;\&quot;)?&quot;</span>] &#125;</span><br><span class="line">                remove_field =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">date</span> &#123; match =&gt; [ <span class="string">&quot;[time]&quot;</span>, <span class="string">&quot;YYYY/MM/dd H:m:s&quot;</span> ] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">        manage_template =&gt; <span class="literal">false</span></span><br><span class="line">        index =&gt; <span class="string">&quot;%&#123;[@metadata][type]&#125;-%&#123;+YYYY.MM&#125;&quot;</span></span><br><span class="line">        document_type =&gt; <span class="string">&quot;%&#123;[fields][env]&#125;&quot;</span></span><br><span class="line">        template_name =&gt; <span class="string">&quot;logstash&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相对应的 Filebeat 的配置见 <a href="https://www.fanhaobai.com/2017/12/elk-install.html#Filebeat">filebeat.yml</a> 部分。</p></blockquote><h2 id="索引模板"><a href="#索引模板" class="headerlink" title="索引模板"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index-templates.html">索引模板</a></h2><p>Logstash 在推送数据至 Elasticsearch 时，默认会自动创建索引，但有时候我们需要定制化索引信息，Logstash 创建的索引就不符合我们的要求，此时就可以使用索引模板来解决。</p><p>创建一个名为<code>logstash</code>的索引模板，并指定该索引模板的匹配模式，作为 Logstash 推送日志时索引的模板。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT _template/logstash</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index_patterns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*access*&quot;</span><span class="punctuation">,</span> <span class="string">&quot;*error*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span>       </span><br><span class="line">            <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_default_&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;@version&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 <a href="#">index_patterns</a> 为匹配模式，表示含有 access 和 error 的索引才会使用该模板。<a href="#">mappings</a>  为字段映射规则，可以配置更多的字段映射规则，已配置字段根据索引模板规则映射，未配置字段则动态映射。</p><h2 id="指定数据存储类型"><a href="#指定数据存储类型" class="headerlink" title="指定数据存储类型"></a>指定数据存储类型</h2><p>Logstash 推送数据到 Elasticsearch 时，可以通过以下几种方式指定字段存储类型。</p><h3 id="grok"><a href="#grok" class="headerlink" title="grok"></a>grok</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grok &#123;</span><br><span class="line">    match =&gt; &#123; <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;WORD:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 IP、WORD、NUMBER 分别会映射为 Elasticsearch 的 IP、String、Number 类型。</p><h3 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h3><p>通过 Mutate 过滤插件的 convert 配置项，可以转换字段值类型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutate &#123; convert =&gt; &#123; <span class="string">&quot;fieldname&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="索引模板-1"><a href="#索引模板-1" class="headerlink" title="索引模板"></a>索引模板</h3><p>若想要根据用户 IP 地址解析后的地理位置信息，得出访问用户的地理分布情况，就需要在 Elasticsearch 中将用户地理坐标存储为 <a href="#">geo_point</a> 类型，而 Logstash 并不能自动完成这个步骤，我们可以在索引模板中指定 location 字段的类型为 geo_point。</p><p>Elasticsearch 待存储的地理位置数据，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;geoip&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">40.722</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">-73.989</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>索引模板的 <a href="#%E7%B4%A2%E5%BC%95%E6%A8%A1%E6%9D%BF">Mappings</a> 部分，应设置为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_default_&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;geoip&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;dynamic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="清理过期数据"><a href="#清理过期数据" class="headerlink" title="清理过期数据"></a>清理过期数据</h2><p>日志平台会产生大量的索引文件，这样不但会占用磁盘空间，而且还会导致检索性能降低，对于那些已经失效的日志文档，应该定期对其清理。</p><h3 id="设置索引过期时间"><a href="#设置索引过期时间" class="headerlink" title="设置索引过期时间"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/mapping-ttl-field.html">设置索引过期时间</a></h3><p>最简单的办法就是给每个索引设定 TTLs（过期时间），在索引模板中定义失效时间为 7 天：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /_template/logstash</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_default_&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;_ttl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7d&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>索引的 TTLs 特性已经从 Elasticsearch 5+ 版本移除，故不推荐使用该方式。</p></blockquote><h3 id="通过查询条件删除文档"><a href="#通过查询条件删除文档" class="headerlink" title="通过查询条件删除文档"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html">通过查询条件删除文档</a></h3><p>例如，日志中时间格式形如<code>&quot;2016-12-24T17:36:14.000Z</code>，则清理 7 天前日志的查询条件为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;lt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;now-7d&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date_time&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上述查询中，<code>@timestamp</code>指定查询字段，<code>format</code>指定时间的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/mapping-date-format.html">格式</a> 为<code>date_time</code>，<code>now-7d</code>表示当前时间往前推移 7 天的时间。</p><p>配置定期清理过期日志的任务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 0 * * * /usr/bin/curl -H&#x27;Content-Type:application/json&#x27; -d&#x27;query&#x27; -XPOST &quot;host/*/_delete_by_query?pretty&quot; &gt; path.log</span><br></pre></td></tr></table></figure><p>其中，<code>query</code>为待清理日志的查询条件，<code>path.log</code>为日志文件路径。</p><blockquote><p>该方式只是删除了过期的日志文档，并不会删除过期的索引信息，适用于对特定索引下的日志文档进行定期清理的场景。</p></blockquote><h3 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a><a href="https://github.com/fan-haobai/tools-shell/blob/master/elk/delete-index.sh">自定义脚本</a></h3><p>我们部署日志收集时，通常会以日、月的形式归档建立索引，所以清理过期日志，只需清理过期的索引。</p><p>这里通过<code>GET /_cat/indices</code>和<code>DELETE /index?pretty</code>这 2 个 API 完成过期索引的清理，清理脚本如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 待删除索引的正则表达式</span></span><br><span class="line">SEARCH_PREG=<span class="string">&quot;nginx-www-access-20[0-9][0-9](\.[0-9]&#123;2&#125;)+&quot;</span></span><br><span class="line"><span class="comment"># 保留索引的天数</span></span><br><span class="line">KEEP_DAYS=7</span><br><span class="line">URL=http://es.fanhaobai.com</span><br><span class="line">PORT=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">date2stamp</span></span> () &#123;</span><br><span class="line">    <span class="built_in">date</span> --utc --<span class="built_in">date</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> +%s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PORT</span> ]; <span class="keyword">then</span> elastic_url=<span class="string">&quot;<span class="variable">$URL</span>:<span class="variable">$&#123;PORT&#125;</span>&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">indices=`curl -u <span class="string">&quot;<span class="variable">$USER</span>:<span class="variable">$PASSWORD</span>&quot;</span> -s <span class="string">&quot;<span class="variable">$URL</span>/_cat/indices?v&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$SEARCH_PREG</span>&quot;</span> | awk <span class="string">&#x27;&#123; print $3 &#125;&#x27;</span>`</span><br><span class="line">endDate=`date2stamp <span class="string">&quot;<span class="variable">$KEEP_DAYS</span> day ago&quot;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="variable">$&#123;indices&#125;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">date</span>=`<span class="built_in">echo</span> <span class="variable">$index</span> | sed <span class="string">&quot;s/.*\([0-9]\&#123;4\&#125;\([.\-][0-9]\&#123;2\&#125;\)*\).*/\1/g&quot;</span> | sed <span class="string">&#x27;s/[.\-]/-/g&#x27;</span>`</span><br><span class="line">  <span class="keyword">if</span> [ `<span class="built_in">echo</span> <span class="variable">$date</span> | grep -o \- | <span class="built_in">wc</span> -l` = 1 ]; <span class="keyword">then</span> <span class="built_in">date</span>=<span class="string">&quot;<span class="variable">$date</span>-01&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  currentDate=`<span class="built_in">date</span> -u <span class="string">&quot;+%Y-%m-%d %T&quot;</span>`</span><br><span class="line">  logDate=`date2stamp <span class="variable">$date</span>`</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ $((<span class="variable">$endDate</span>-<span class="variable">$logDate</span>)) -ge 0 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;[<span class="variable">$&#123;currentDate&#125;</span>] - <span class="variable">$&#123;index&#125;</span> | DELETE&quot;</span>;</span><br><span class="line">      curl -u <span class="string">&quot;<span class="variable">$USER</span>:<span class="variable">$PASSWORD</span>&quot;</span> -XDELETE <span class="string">&quot;<span class="variable">$URL</span>/<span class="variable">$&#123;index&#125;</span>?pretty&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;[<span class="variable">$&#123;currentDate&#125;</span>] - <span class="variable">$&#123;index&#125;</span> | NO&quot;</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>配置定时任务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 * * * /usr/local/elk/elasticsearch/bin/delete-index.sh &gt;&gt; /usr/local/elk/elasticsearch/logs/delete-index.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>该方式通过自定义脚本方式，可以较灵活的配置所需清理的过期索引，使用起来简洁轻便，但若 Elasticsearch 采用集群方式部署，那么该方式就不是很灵活了。</p></blockquote><h3 id="Curator工具"><a href="#Curator工具" class="headerlink" title="Curator工具"></a><a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/about.html">Curator工具</a></h3><p>当遇到清理过期索引比较复杂的场景时，就可以使用官方提供的管理工具 Curator。其不仅可以进行复杂场景的索引管理，还可以进行快照管理，而实现这一切，只需要配置 YAML 格式的配置文件。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>这里使用 yum 安装，先配置 yum 源。在<code>/etc/yum.repos.d/</code>目录下创建名为<code>curator.repo</code>的文件，内容如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[curator-5]</span></span><br><span class="line"><span class="attr">name</span>=CentOS/RHEL <span class="number">6</span> repository for Elasticsearch Curator <span class="number">5</span>.x packages</span><br><span class="line"><span class="attr">baseurl</span>=https://packages.elastic.co/curator/<span class="number">5</span>/centos/<span class="number">6</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://packages.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 yum 命令安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y elasticsearch-curator</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有索引</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curator_cli --host es.fanhaobai.com --port 80 show_indices --verbose</span></span><br><span class="line"></span><br><span class="line">.kibana     open   15.7KB       3   1   0 2017-12-15T06:15:07Z</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/configfile.html">主配置文件</a></li></ul><p>创建名为<code>/etc/curator/curator.yml</code>的配置文件，主要用来配置 Elasticsearch 服务的相关信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">es.fanhaobai.com</span>         <span class="comment">#集群配置形如[&quot;10.0.0.1&quot;, &quot;10.0.0.2&quot;]</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">url_prefix:</span></span><br><span class="line">  <span class="attr">use_ssl:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">certificate:</span></span><br><span class="line">  <span class="attr">client_cert:</span></span><br><span class="line">  <span class="attr">client_key:</span></span><br><span class="line">  <span class="attr">ssl_no_validate:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">master_only:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">loglevel:</span> <span class="string">INFO</span></span><br><span class="line">  <span class="attr">logfile:</span> <span class="string">/usr/local/elk/elasticsearch/logs/elasticsearch-curator.log</span></span><br><span class="line">  <span class="attr">logformat:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">blacklist:</span> [<span class="string">&#x27;elasticsearch&#x27;</span>, <span class="string">&#x27;urllib3&#x27;</span>]</span><br></pre></td></tr></table></figure><p>其中，需要配置 hosts、port、http_auth 这 3 个配置项。</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/actionfile.html">任务配置文件</a></li></ul><p>例如，待清理索引的格式形如<code>test-2017.11.16</code>，需清理 7 天过期的索引。创建名为<code>delete-index.yml</code>的 <a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/ex_delete_indices.html">配置</a> 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions:</span></span><br><span class="line">  <span class="attr">1:</span>                                  <span class="comment">#任务1</span></span><br><span class="line">   <span class="attr">action:</span> <span class="string">delete_indices</span>             <span class="comment">#任务动作</span></span><br><span class="line">   <span class="attr">description:</span> <span class="string">&quot;Delete nginx index&quot;</span>  <span class="comment">#日志描述</span></span><br><span class="line">   <span class="attr">options:</span></span><br><span class="line">     <span class="attr">ignore_empty_list:</span> <span class="literal">false</span></span><br><span class="line">     <span class="attr">disable_action:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">filters:</span>                           <span class="comment">#管道</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">filtertype:</span> <span class="string">pattern</span>              <span class="comment">#模式过滤</span></span><br><span class="line">     <span class="attr">kind:</span> <span class="string">prefix</span>                     <span class="comment">#匹配索引前缀</span></span><br><span class="line">     <span class="attr">value:</span> <span class="string">test-</span>                     <span class="comment">#匹配值，索引前缀为test-</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">filtertype:</span> <span class="string">age</span>                  <span class="comment">#时间过滤</span></span><br><span class="line">     <span class="attr">source:</span> <span class="string">name</span>                     <span class="comment">#过滤形式</span></span><br><span class="line">     <span class="attr">direction:</span> <span class="string">older</span>                 <span class="comment">#往后推算</span></span><br><span class="line">     <span class="attr">timestring:</span> <span class="string">&#x27;%Y.%m.%d&#x27;</span>           <span class="comment">#时间格式，同索引时间格式</span></span><br><span class="line">     <span class="attr">unit:</span> <span class="string">days</span>                       <span class="comment">#时间单位</span></span><br><span class="line">     <span class="attr">unit_count:</span> <span class="number">7</span>                    <span class="comment">#时间间隔，7天内</span></span><br></pre></td></tr></table></figure><p>Curator 支持配置多个任务，其中 <a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/actions.html">action</a> 为任务动作，<a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/filters.html">filters</a> 为管道过滤器，<a href="https://www.elastic.co/guide/en/elasticsearch/client/curator/current/filtertype.html">filtertype</a> 为过滤器的过滤类型，支持多种过滤类型。</p><p>测试删除过期索引：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除前</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curator_cli --config /etc/curator/curator.yml show_indices --verbose | grep <span class="built_in">test</span>-</span></span><br><span class="line">test-2017.11.16      open   162.0B       0   3   0 2017-12-17T06:10:04Z</span><br><span class="line">test-2017.12.16      open   486.0B       0   3   0 2017-12-17T05:58:07Z</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curator --config /etc/curator/curator.yml /etc/curator/delete-index.yml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除过期索引后</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curator_cli --config /etc/curator/curator.yml show_indices --verbose | grep <span class="built_in">test</span>-</span></span><br><span class="line">test-2017.12.16      open   486.0B       0   3   0 2017-12-17T05:58:07Z</span><br></pre></td></tr></table></figure><p>配置每天执行任务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 0 * * * /usr/bin/curator --config /etc/curator/curator.yml /etc/curator/delete-index.yml</span><br></pre></td></tr></table></figure><blockquote><p>该方式不但直接通过配置即可方便实现过期索引的清理，而且可以在复杂场景轻松地管理索引、快照等，故推荐该方式。</p></blockquote><h2 id="数据报表"><a href="#数据报表" class="headerlink" title="数据报表"></a>数据报表</h2><p>上述一切准备步骤做好后，我们就可以利用 Kibana 对大量的日志数据进行报表分析，进而实现应用监控和流量分析。</p><h3 id="创建索引模式"><a href="#创建索引模式" class="headerlink" title="创建索引模式"></a>创建索引模式</h3><p>选择 Kibana 的 ”Managemant  &gt;&gt; Kibana &gt;&gt; Index Patterns” 项 ，创建一个名为<code>nginx-www-access*</code>的索引模式，并设为默认索引，如图：</p><p><img src="//www.fanhaobai.com/2017/12/elk-advanced/d82824ed-15eb-47c5-9ec6-925f2d3f7758.png"></p><h3 id="创建数据图表"><a href="#创建数据图表" class="headerlink" title="创建数据图表"></a>创建数据图表</h3><p>选择 Kibana 的 ”Visualize” 项，创建一个数据图表，Kibana 已经支持了丰富的图标类型，这里选择 Line 类型图表制作一个用户访问量的图表。</p><p>图表的 Metrics（指标） 和 Buckets（桶）属性，Metrics 用来表示 PV 和 UV，而 Buckets 则是时间维度，UV 需要根据 location 去重后统计。</p><p>图表的 Metrics 部分，如下图：</p><p><img src="//www.fanhaobai.com/2017/12/elk-advanced/f2c9321a-e7e4-11e7-80c1-9a214cf093ae.png"></p><p>图表的 Buckets 部分，如下图：</p><p><img src="//www.fanhaobai.com/2017/12/elk-advanced/3f97da38-e7e5-11e7-80c1-9a214cf093ae.png"></p><p>最后，生成的用户访问量图表如文章起始所示。</p><h3 id="创建实时监控面板"><a href="#创建实时监控面板" class="headerlink" title="创建实时监控面板"></a>创建实时监控面板</h3><p>当我们创建了各种指标的数据图表后，就可以将这些数据图表组合成一个实时监控面板。选择 Kibana 的 ”Dashboard” 项，创建一个监控面板，并添加所需监控指标的数据图表，拖拽调整各图表到合适位置并保存，一个实时监控面板就呈现在眼前了。</p><p>下面是我针对主站 <a href="https://www.fanhaobai.com/">Blog</a> 健康监控和流量分析做出的实时 <a href="http://elk.fanhaobai.com/">数据报表</a> 展示，基本上满足了实时监控要求。</p><p><img src="//www.fanhaobai.com/2017/12/elk-advanced/b27378ac-e7e8-11e7-80c1-9a214cf093ae.png"></p><h2 id="Logstash出现OutOfMemory异常"><a href="#Logstash出现OutOfMemory异常" class="headerlink" title="Logstash出现OutOfMemory异常"></a>Logstash出现OutOfMemory异常</h2><p>当 Logstash 运行一段时间后，你可能会发现日志中出现大量的 <a href="#">OutOfMemory 错误，并且服务器 CPU 处于 100% 状态</a>。产生原因是因为 Logstash 堆栈溢出，进而要频繁进行 GC 操作导致。</p><p>尽管在 <a href="https://www.fanhaobai.com/2017/12/elk-install.html#%E5%AE%89%E8%A3%85">安装</a> 过程中调整了 Logstash 内存大小，这个由于服务器硬件限制导致的问题还是没法根本解决，但是可以规避问题嘛。很简单，这种堆栈溢出只会长期运行出现，所以只需要定期重启 Logstash 即可。定时任务为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 */12 * * * /sbin/service logstash restart</span><br></pre></td></tr></table></figure><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/elk.html">ELK集中式日志平台之一 — 平台架构</a> <span>（2017-12-16）</span></li><li><a href="https://www.fanhaobai.com/2017/12/elk-install.html">ELK集中式日志平台之二 — 部署</a> <span>（2017-12-22）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部署 &lt;a href=&quot;https://www.fanhaobai.com/2017/12/elk-install.html&quot;&gt;ELK&lt;/a&gt; 后，日志平台就搭建完成了，基本上可以投入使用，但是其配置并不完善，也并未提供实时监控和流量分析功能，本文将对 ELK 部署后的一些常见使用问题给出解决办法。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/elk-advanced/993155ac-718b-4e4b-9d36-d9d73357b162.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="日志" scheme="https://www.fanhaobai.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ELK集中式日志平台之二 — 部署</title>
    <link href="https://www.fanhaobai.com/2017/12/elk-install.html"/>
    <id>https://www.fanhaobai.com/2017/12/elk-install.html</id>
    <published>2017-12-21T15:14:00.000Z</published>
    <updated>2024-04-18T08:38:12.681Z</updated>
    
    <content type="html"><![CDATA[<p>由于系统日志量还在可控范围，所以选择了 ELK+Beats 的方案，并未引入消息队列，当然后续需要可以对系统升级。鉴于此，只需要在日志平台部署 Elasticsearch 和 Logstash 集群，同时在应用服务器部署 Filebeat。</p><p><img src="//www.fanhaobai.com/2017/12/elk-install/0da3b439-5174-4aff-b9dc-f275ebbd9e1f.png"><span id="more"></span></p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><h3 id="JAVA环境"><a href="#JAVA环境" class="headerlink" title="JAVA环境"></a>JAVA环境</h3><p>ELK 需要 JAVA 8 以上的运行环境，若未安装则按如下步骤安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep java</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量卸载</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm -qa | grep java | xargs rpm -e --nodeps</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y java-1.8.0-openjdk*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line">openjdk version &quot;1.8.0_151&quot;</span><br></pre></td></tr></table></figure><p>在文件<code>/etc/profile</code>配置环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指向安装目录，其中1.8.0.151需与版本号保持一致</span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.151-1.b12.el6_9.x86_64</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">JAVACMD=/usr/bin/java</span><br><span class="line">export JAVA_HOME JAVACMD CLASSPATH PATH</span><br></pre></td></tr></table></figure><p>执行<code>source /etc/profile</code>命令，使配置环境生效。</p><h3 id="安装GPG-KEY"><a href="#安装GPG-KEY" class="headerlink" title="安装GPG-KEY"></a>安装GPG-KEY</h3><p>由于后续采用 yum 安装，所以需要下载并安装 GPG-KEY：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span></span><br></pre></td></tr></table></figure><blockquote><p>yum 命令会安装最新的版本，若需安装较旧的版本，请先从 <a href="https://www.elastic.co/downloads/past-releases">官方地址</a> 下载对应的旧版本 rpm 包，然后使用<code>rpm -ivh</code>命令安装。</p></blockquote><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过 <a href="https://www.elastic.co/downloads/past-releases">官方地址</a> 下载选择最新版本，然后解压：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.1.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/elk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf elasticsearch-6.1.1.tar.gz -C /usr/local/elk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /usr/local/elk/elasticsearch-6.1.1 /usr/local/elk/elasticsearch</span></span><br></pre></td></tr></table></figure><p>启动前，需要修改配置文件<code>jvm.options</code>中 JVM 大小，否则可能会内存溢出，导致启动失败。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim config/jvm.options</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据实际情况修改</span></span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure><p>由于 Elasticsearch 新版本不允许以 <a href="#">root</a> 身份启动，因此先创建 elk 用户。这里使用 <a href="https://github.com/fan-haobai/init-script/blob/master/elasticsearch/elasticsearch">service</a> 服务方式管理 Elasticsearch，修改启动用户和安装目录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">useradd elk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> -R elasticsearch /usr/local/elk/elasticsearch</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/init.d/elasticsearch</span></span><br><span class="line">ES_HOME=&quot;/usr/local/elk/elasticsearch&quot;</span><br><span class="line">MAX_OPEN_FILES=65536</span><br><span class="line">MAX_MAP_COUNT=262144</span><br><span class="line">LOG_DIR=&quot;$ES_HOME/logs&quot;</span><br><span class="line">DATA_DIR=&quot;$ES_HOME/data&quot;</span><br></pre></td></tr></table></figure><p>设置开机启动服务，启动 Elasticsearch，其默认监听 9200 端口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启服务</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --add elasticsearch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig elasticsearch on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service elasticsearch start</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -tunpl | grep <span class="string">&quot;9200&quot;</span></span></span><br><span class="line">tcp   0   0 127.0.0.1:9200   0.0.0.0:*    LISTEN    27029/java</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://127.0.0.1:9200</span></span><br></pre></td></tr></table></figure><p>最后，安装使用到的插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/elk/elasticsearch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ingest-geoip和ingest-user-agent分别为ip解析插件和agent解析插件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/elasticsearch-plugin install ingest-geoip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/elasticsearch-plugin install ingest-user-agent</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户管理和monitor管理</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/elasticsearch-plugin install x-pack</span></span><br></pre></td></tr></table></figure><blockquote><p>安装 x-pack 插件后，对 Elasticsearch 的操作都需要授权，默认用户名为 elastic，默认密码为 changeme。</p></blockquote><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a><a href="https://www.elastic.co/guide/en/kibana/current/install.html">Kibana</a></h2><p>首先，在<code>/etc/yum.repos.d</code>目录下创建名为<code>kibana.repo</code>的 yum 源文件：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[kibana-5.x]</span></span><br><span class="line"><span class="attr">name</span>=Kibana repository for <span class="number">5</span>.x packages</span><br><span class="line"><span class="attr">baseurl</span>=https://artifacts.elastic.co/packages/<span class="number">5</span>.x/yum</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">autorefresh</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">type</span>=rpm-md</span><br></pre></td></tr></table></figure><p>使用 yum 命令安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y kibana</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/elk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/share/kibana /usr/local/elk/kibana</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/elk/kibana</span></span><br></pre></td></tr></table></figure><p>修改配置文件<code>kibana.yml</code>以下配置项：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/elk/kibana/config</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /etc/kibana/kibana.yml /usr/local/elk/kibana/config</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim config/kibana.yml</span></span><br><span class="line"></span><br><span class="line">server.port: 5601                           # 监听端口</span><br><span class="line">server.name: &quot;elk.fanhaobai.com&quot;            # 域名</span><br></pre></td></tr></table></figure><p>安装常用插件，例如 x-pack：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kibana-plugin install x-pack</span></span><br></pre></td></tr></table></figure><p>Kibana 运行时 NodeJs 默认会最大分配 1G 内存，可以在启动时增加<code>max-old-space-size</code>参数，以限制其运行内存大小：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim bin/kibana</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加--max-old-space-size=140参数</span></span><br><span class="line">NODE_ENV=production exec &quot;$&#123;NODE&#125;&quot; $NODE_OPTIONS --max-old-space-size=140 --no-warnings &quot;$&#123;DIR&#125;/src/cli&quot; $&#123;@&#125;</span><br></pre></td></tr></table></figure><p>修改 <a href="#">init</a> 启动脚本，并启动 Kibana：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/init.d/kibana</span></span><br><span class="line"></span><br><span class="line">home=/usr/share/kibana</span><br><span class="line">program=$home/bin/kibana</span><br><span class="line">args=-c\\\ $home/config/kibana.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认以kibana运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> -R kibana:kibana /usr/local/elk/kibana/*</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --add kibana</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig kibana on</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service kibana start</span></span><br></pre></td></tr></table></figure><p>配置 Web 服务后，访问 <a href="http://elk.fanhaobai.com/">elk.fanhaobai.com</a> 就可以看到 Kibana 强大又绚丽的界面。</p><blockquote><p>安装 x-pack 插件后，访问 Kibana 同样需要授权，且任何 Elasticsearch 的用户名和密码对都可被认证通过。</p></blockquote><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><a href="https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#_yum">安装</a></h3><p>首先，在<code>/etc/yum.repos.d</code>目录下创建<code>logstash.repo</code>文件：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[logstash-5.x]</span></span><br><span class="line"><span class="attr">name</span>=Elastic repository for <span class="number">5</span>.x packages</span><br><span class="line"><span class="attr">baseurl</span>=https://artifacts.elastic.co/packages/<span class="number">5</span>.x/yum</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">autorefresh</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">type</span>=rpm-md</span><br></pre></td></tr></table></figure><p>使用 yum 安装 Logstash，并测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装logstash 5.x</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y logstash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认安装路径/usr/share</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/elk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/share/logstash /usr/local/elk/logstash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/elk/logstash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行测试</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line">The stdin plugin is now waiting for input:</span><br><span class="line">elk</span><br><span class="line">2017-11-21T22:25:07.264Z fhb elk</span><br></pre></td></tr></table></figure><p>修改配置文件路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /etc/logstash /usr/local/elk/logstash/config</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chown</span> -R logstash:logstash /usr/local/elk/logstash</span></span><br></pre></td></tr></table></figure><p>修改 JVM 内存大小，防止出现内存溢出异常：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim config/jvm.options</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据实际情况修改</span></span><br><span class="line">-Xms80m</span><br><span class="line">-Xmx150m</span><br></pre></td></tr></table></figure><p>生成并修改 <a href="#">init</a> 启动脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/system-install /etc/logstash/startup.options sysv</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/init.d/logstash</span></span><br><span class="line">home=/usr/share/logstash</span><br><span class="line">name=logstash</span><br><span class="line">program=$home/bin/logstash</span><br><span class="line">args=--path.settings\ $home/config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加启动</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --add logstash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig logstash on</span></span><br></pre></td></tr></table></figure><p>安装 x-pack 插件，基本状态信息的监控:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/logstash-plugin install x-pack</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h4><p>Logstash 主配置文件为<code>config/logstash.yml</code>，配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path.data:</span> <span class="string">/var/lib/logstash</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/usr/share/logstash/logs</span></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="attr">path.config:</span> <span class="string">/usr/share/logstash/config/conf.d</span></span><br></pre></td></tr></table></figure><h4 id="配置管道"><a href="#配置管道" class="headerlink" title="配置管道"></a><a href="https://www.elastic.co/guide/en/logstash/current/event-dependent-configuration.html">配置管道</a></h4><p>创建一个简单的管道（inputs → filters → outputs），配置文件为<code>conf.d/filebeat.conf</code>。日志过滤处理后，直接推送到 Elasticsearch，在 output 部分需配置 Elasticsearch 的用户名和密码。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">input</span> &#123;</span><br><span class="line">    <span class="section">beats</span> &#123;</span><br><span class="line">        <span class="attribute">port</span> =&gt; <span class="number">5044</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    <span class="attribute">if</span> [fileset][name] =<span class="regexp">~ &quot;access&quot;</span> &#123;</span><br><span class="line">        <span class="section">grok</span> &#123;</span><br><span class="line">            <span class="attribute">match</span> =&gt; &#123;&quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">date</span> &#123;</span><br><span class="line">            <span class="attribute">match</span> =&gt; [<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;dd/MMM/YYYY:H:m:s Z&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if [fileset][name] =<span class="regexp">~ &quot;error&quot;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="section">else</span> &#123;</span><br><span class="line">        <span class="section">drop</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">output</span> &#123;</span><br><span class="line">    <span class="section">elasticsearch</span> &#123;</span><br><span class="line">        <span class="attribute">hosts</span> =&gt; <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">        manage_template =&gt; <span class="literal">false</span></span><br><span class="line">        index =&gt; <span class="string">&quot;%&#123;[<span class="variable">@metadata</span>][type]&#125;-%&#123;+YYYY.MM&#125;&quot;</span>  <span class="comment">#索引名称</span></span><br><span class="line">        document_type =&gt; <span class="string">&quot;%&#123;[fields][env]&#125;&quot;</span>          <span class="comment">#文档类型</span></span><br><span class="line">        user =&gt; <span class="string">&quot;elastic&quot;</span>                            <span class="comment">#用户名     </span></span><br><span class="line">        password =&gt; <span class="string">&quot;changeme&quot;</span>                       <span class="comment">#密码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整配置见 <a href="https://www.fanhaobai.com/2017/12/elk-advanced.html#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">配置示例</a> 部分，更多配置示例见 <a href="https://www.elastic.co/guide/en/logstash/current/config-examples.html">Logstash Configuration Examples</a>。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service logstash start</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成监听</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -tnpl | grep 5044</span></span><br><span class="line">tcp   0      0 0.0.0.0:5044     0.0.0.0:*    LISTEN      10132/java</span><br></pre></td></tr></table></figure><h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><h3 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a><a href="https://www.elastic.co/downloads/beats/filebeat">安装</a></h4><p>由于同 Elasticsearch 使用一个源，所以直接使用 yum 安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装filebeat 5.6.6</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y filebeat</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/elk/beats</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/share/filebeat /usr/local/elk/beats/filebeat</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/elk/beats/filebeat</span></span><br></pre></td></tr></table></figure><p>修改 init 启动脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/init.d/filebeat</span></span><br><span class="line"></span><br><span class="line">home=/usr/share/filebeat</span><br><span class="line">pidfile=$&#123;PIDFILE-/var/run/filebeat.pid&#125;</span><br><span class="line">agent=$&#123;BEATS_AGENT-$home/bin/filebeat&#125;</span><br><span class="line">args=&quot;-c $home/filebeat.yml -path.home $home -path.config $home -path.data $home/data -path.logs $home/logs&quot;</span><br></pre></td></tr></table></figure><p>配置启动服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --add filebeat</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig filebeat on</span></span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>创建 Filebeat 配置文件<code>filebeat.yml</code>，开启 nginx 日志模块采集 access 日志信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.modules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">access:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">var.paths:</span> [<span class="string">&quot;/data/logs/fanhaobai.com.access.log&quot;</span>] <span class="comment">#日志路径</span></span><br><span class="line">    <span class="attr">prospector:</span></span><br><span class="line">      <span class="attr">document_type:</span> <span class="string">nginx-www-access</span>               <span class="comment">#Logstash的type字段</span></span><br><span class="line">  <span class="attr">error:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">var.paths:</span> [<span class="string">&quot;/data/logs/error.log&quot;</span>]</span><br><span class="line">    <span class="attr">prospector:</span></span><br><span class="line">      <span class="attr">document_type:</span> <span class="string">nginx-all-error</span></span><br><span class="line"><span class="attr">fields:</span>                                      <span class="comment">#自定义字段，Logstash的fields字段</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">prod</span>                                  <span class="comment">#添加环境标识</span></span><br><span class="line"><span class="attr">queue_size:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">bulk_queue_size:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span>                             <span class="comment">#输出到Logstash</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5044&quot;</span>]  </span><br><span class="line">  <span class="attr">worker:</span> <span class="number">1</span>  </span><br><span class="line">  <span class="attr">loadbalance:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">index:</span> <span class="string">&#x27;filebeat&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service filebeat start</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看推送日志</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tailf /usr/local/elk/beats/filebeat/bin/logs/filebeat</span></span><br><span class="line">2017-12-22T02:00:53+08:00 INFO Non-zero metrics in the last 30s: filebeat.harvester.open_files=1 filebeat.harvester.running=1</span><br><span class="line">libbeat.logstash.publish.read_bytes=6 libbeat.logstash.publish.write_bytes=460</span><br></pre></td></tr></table></figure><p>Filebeat 启动后，会侦测待采集文件内容是否有增加或更新，并实时推送数据到 Logstash。</p><blockquote><p>因为 Filebeat、Logstash 有些配置并不向后兼容，更新升级后可能导致服务不可用，所以这里在<code>/etc/yum.conf</code>增加<code>exclude=filebeat logstash</code>配置项，禁用<code>yum update</code>的自动更新。</p></blockquote><h2 id="数据呈现"><a href="#数据呈现" class="headerlink" title="数据呈现"></a>数据呈现</h2><p>Filebeat 推送到 Logstash 过滤后，Elasticsearch 存储的数据格式为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx-www-access-2017.12&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prod&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;response_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;106.11.152.143&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">81989257</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;log&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;read_timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2017-12-21T18:12:53.604Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/logs/fanhaobai.com.access.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fileset&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;access&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx-www-access&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/2017/11/qconf-deploy.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;referrer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2017-12-21T18:12:53.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;beat&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fhb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fhb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.6.5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fhb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body_sent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;bytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;44067&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prod&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 Kibana 中呈现效果为：</p><p><img src="//www.fanhaobai.com/2017/12/elk-install/a1ff2131-8dd8-4ad1-8ba3-c2d2ebeffc91.png"></p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/elk.html">ELK集中式日志平台之一 — 平台架构</a> <span>（2017-12-16）</span></li><li><a href="https://www.fanhaobai.com/2017/12/elk-advanced.html">ELK集中式日志平台之三 — 进阶</a> <span>（2017-12-22）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于系统日志量还在可控范围，所以选择了 ELK+Beats 的方案，并未引入消息队列，当然后续需要可以对系统升级。鉴于此，只需要在日志平台部署 Elasticsearch 和 Logstash 集群，同时在应用服务器部署 Filebeat。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/elk-install/0da3b439-5174-4aff-b9dc-f275ebbd9e1f.png&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="日志" scheme="https://www.fanhaobai.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ELK集中式日志平台之一 — 平台架构</title>
    <link href="https://www.fanhaobai.com/2017/12/elk.html"/>
    <id>https://www.fanhaobai.com/2017/12/elk.html</id>
    <published>2017-12-16T05:14:00.000Z</published>
    <updated>2024-04-18T08:38:12.682Z</updated>
    
    <content type="html"><![CDATA[<p>随着微服务化的推广，我们的应用都会采取分布式方式部署，这就会导致应用日志比较分散，应用监控和排查问题都比较困难，同时效率还低下，集中式日志平台就是为了解决这个问题。</p><p><img src="//www.fanhaobai.com/2017/12/elk/c0625948-b690-48ad-a178-63fc08b0cefb.png"><span id="more"></span></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很早前，我们的应用都已经接入了 <a href="https://github.com/dianping/cat">CAT</a>，能够在线实时查看应用访问量、异常的调用情况等应用性能指标，同时也打通了各平台的调用链路，基本满足应用的性能监控要求。</p><p><img src="//www.fanhaobai.com/2017/12/elk/b488220c-e24a-4eaf-8ee9-81cc6ae9484c.png"></p><p>由于我们应用业务日志并没有推送到 CAT，所以当线上出现问题时，传统方式查看业务日志，排查问题比较困难，搭建业务日志集中平台迫在眉睫。经过调研，我们选择了 <a href="https://www.elastic.co/">Elastic</a> 提供的 ELK 日志解决方案，查看 <a href="http://demo.elastic.co/app/kibana#/dashboard/b7be4700-6837-11e7-bd1c-eb5e5ad48f8b">在线演示</a>。</p><p>原因主要有两点：</p><ul><li>ELK 提供的功能满足我们的使用要求，并有较高的扩展性；</li><li>ELK 为一套开源项目，较低的维护成本；</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>ELK 指的是一套解决方案，是 <a href="https://www.elastic.co/cn/products/elasticsearch">Elasticsearch</a>、<a href="https://www.elastic.co/cn/products/logstash">Logstash</a> 和 <a href="https://www.elastic.co/cn/products/kibana">Kibana</a> 三种软件产品的首字母缩写，<a href="https://www.elastic.co/cn/products/beats">Beats</a> 是 ELK 协议栈的新成员。</p><ul><li>E：代表 Elasticsearch，负责日志的存储和检索； </li><li>L：代表 Logstash，负责日志的收集、过滤和格式化； </li><li>K：代表 Kibana，负责日志数据的可视化；</li><li>Beats：是一类轻量级数据采集器；</li></ul><p>其中，目前 Beats 家族根据功能划分，主要包括 4 种：</p><ul><li>Filebeat：负责收集文件数据； </li><li>Packetbeat：负责收集网络流量数据；</li><li>Metricbeat：负责收集系统级的 CPU 使用率、内存、文件系统、磁盘 IO 和网络 IO 统计数据；</li><li>Winlogbeat：负责收集 Windows 事件日志数据;</li></ul><p><img src="//www.fanhaobai.com/2017/12/elk/de986f14-1b7a-46f0-bf81-e477dda1e157.png"></p><p>在该日志平台系统中，就使用了 Filebeat 作为日志文件收集工具，Filebeat 可以很方便地收集 Nginx、Mysql、Redis、Syslog 等应用的日志文件。</p><h2 id="日志平台架构"><a href="#日志平台架构" class="headerlink" title="日志平台架构"></a>日志平台架构</h2><p>ELK 集中式日志平台，总体上来说，部署在应用服务器上的数据采集器，近实时收集日志数据推送到日志过滤节点的 Logstash，然后 Logstash 再推送格式化的日志数据到 Elasticsearch 存储，Kibana 通过 Elasticsearch 集中检索日志并可视化。</p><p>当然，ELK 集中日志平台也是经过一次次演变，才变成最终的样子。</p><h3 id="ES-Logstash-Kibana"><a href="#ES-Logstash-Kibana" class="headerlink" title="ES + Logstash + Kibana"></a>ES + Logstash + Kibana</h3><p><img src="//www.fanhaobai.com/2017/12/elk/b19f74ae-2be3-4aef-b390-246acbf3050f.png"></p><p>最开始的架构中，由 Logstash 承担数据采集器和过滤功能，并部署在应用服务器。由于 Logstash 对大量日志进行过滤操作，会消耗应用系统的部分性能，带来不合理的资源分配问题；另一方面，过滤日志的配置，分布在每台应用服务器，不便于集中式配置管理。</p><h3 id="引入Logstash-forwarder"><a href="#引入Logstash-forwarder" class="headerlink" title="引入Logstash-forwarder"></a>引入Logstash-forwarder</h3><p><img src="//www.fanhaobai.com/2017/12/elk/c2f50522-4a60-47b5-80b3-69f194745e19.png"></p><p>使用该架构，引入 Logstash-forwarder 作为数据采集，Logstash 和应用服务器分离，应用服务器只做数据采集，数据过滤统一在日志平台服务器，解决了之前存在的问题。但是 Logstash-forwarder 和 Logstash 间通信必须由 SSL 加密传输，部署麻烦且系统性能并没有显著提升；另一方面，Logstash-forwarder 的定位并不是数据采集插件，系统不易扩展。</p><h3 id="引入Beats"><a href="#引入Beats" class="headerlink" title="引入Beats"></a>引入Beats</h3><p><img src="//www.fanhaobai.com/2017/12/elk/c0625948-b690-48ad-a178-63fc08b0cefb.png"></p><p>该架构，基于 Logstash-forwarder 架构，将 Logstash-forwarder 替换为 Beats。由于 Beats 的系统性能开销更小，所以应用服务器性能开销可以忽略不计；另一方面，Beats 可以作为数据采集插件形式工作，可以按需启用 Beats 下不同功能的插件，更灵活，扩展性更强。例如，应用服务器只启用 Filebeat，则只收集日志文件数据，如果某天需要收集系统性能数据时，再启用 Metricbeat 即可，并不需要太多的修改和配置。</p><p>这种 ELK+Beats 的架构，已经满足大部分应用场景了，但当业务系统庞大，日志数据量较大、较实时时，业务系统就和日志系统耦合在一起了。</p><h3 id="引入队列"><a href="#引入队列" class="headerlink" title="引入队列"></a>引入队列</h3><p><img src="//www.fanhaobai.com/2017/12/elk/17b1a5c7-2897-46f2-becd-3f03f926bc0f.png"></p><p>该架构，引入消息队列，均衡了网络传输，从而降低了网络闭塞，尤其是丢失数据的可能性；另一方面，这样可以系统解耦，具有更好的灵活性和扩展性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较成熟的 ELK+Beats 架构，因其扩展性很强，是集中式日志平台的首选方案。在实际部署时，是否引入消息队列，根据业务系统量来确定，早期也可以不引入消息队列，简单部署，后续需要扩展再接入消息队列。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/elk-install.html">ELK集中式日志平台之二 — 部署</a> <span>（2017-12-21）</span></li><li><a href="https://www.fanhaobai.com/2017/12/elk-advanced.html">ELK集中式日志平台之三 — 进阶</a> <span>（2017-12-22）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着微服务化的推广，我们的应用都会采取分布式方式部署，这就会导致应用日志比较分散，应用监控和排查问题都比较困难，同时效率还低下，集中式日志平台就是为了解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/elk/c0625948-b690-48ad-a178-63fc08b0cefb.png&quot;&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="日志" scheme="https://www.fanhaobai.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>王者编程大赛之五 — 最短路径</title>
    <link href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html"/>
    <id>https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html</id>
    <published>2017-12-06T15:14:00.000Z</published>
    <updated>2024-04-18T08:38:12.679Z</updated>
    
    <content type="html"><![CDATA[<p>自如年底就会拥有 50W 间房子，大家知道每间房房子都是需要配置完才能出租给自如客的，整个房租的配置过程是很复杂的，每天都需要大量的物流师傅将家电、家具等物品从仓库送到需要配置的每个房间。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/40beff35-47fc-4427-8805-e183233b598b.png"><span id="more"></span></p><p>为了能在更多的时间配置更多的房子，我要不断的优化物流从仓库 A 到房间 G 的路径或者仓库 B 到房间 E 的距离，请写出一种算法给你任意图中两点，计算出两点之间的最短距离。<br>注：A B C D E F G H 都可能是仓库或者房间，点与点之间是距离。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/40beff35-47fc-4427-8805-e183233b598b.png"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是求解无向图单源点的最短路径，经常采用 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra</a> 算法求解，是按路径长度递增的次序产生最短路径。</p><h3 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h3><p>Dijkstra 算法是运用了最短路径的最优子结构性质，最优子结构性质描述为：P(i,j) = {$v_i$,…,$v_k$,…,$v_s$,$v_j$} 是从顶点 i 到 j 的最短路径，顶点 k 和 s 是这条路径上的一个中间顶点，那么 P(k,s) 必定也是从 k 到 s 的最短路径。</p><p>由于 P(i,j) = {$v_i$,…,$v_k$,…,$v_s$,$v_j$} 是从顶点 i 到 j 的最短路径，则有 P(i,j) = P(i,k) + P(k,s) + P(k,j)。若 P(k,s) 不是从顶点 k 到 s 的最短路径，那么必定存在另一条从顶点 k 到 s 的最短路径 P’(k,s)，故 P’(i,j) = P(i,k) + P’(k,s) + P(k,j) &lt; P(i,j)，与题目相矛盾，因此 P(k,s) 是从顶点 k 到 s 的最短路径。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>根据最短路径的最优子结构性质，Dijkstra 提出了以最短路径长度递增，逐次生成最短路径的算法。譬如对于源顶点 $v_0$，首先选择其直接相邻的顶点中最短路径的顶点$v_i$，那么可得从 $v_0$ 到达 $v_j$ 顶点的最短距离 $D[j]=min(D[j], D[j] + matrix[i][j])$（$matrix[i][j]$ 为从顶点 $v_i$ 到 $v_j$ 的直接距离）。</p><p>假设存在图 G={V,E}，V 为所有顶点集合，源顶点为 $v_0$，U={$v_0$} 表示求得终点路径的集合，D[i] 为顶点 $v_0$ 到 $v_i$ 的最短距离，P[i] 为顶点 $v_0$ 到 $v_i$ 最短路径上的顶点。</p><p>算法描述为：</p><p>1）从 V-U 中选择使 D[i] 值最小的顶点 $v_i$，将 $v_i$ 加入到 U 中；<br>2）更新 $v_i$ 与任一顶点 $v_j$ 的最短距离，即 $D[j]=min(D[j], D[i]+matrix[i][j])$；<br>3）直到 U=V，便求得从顶点  $v_0$ 到图中任一一点的最短路径；</p><p>例如，求 CG 最短路径，算法过程可图示为：</p><p>源顶点 $v_0$ = C，顶点与索引关系为 A→H = 0→7，初始时：</p><ul><li>U = {false, false, false, false, false, false, false, false}</li><li>D = {INF ,INF, <strong>0</strong>, INF, INF, INF, INF, INF}</li><li>P = { {}, {}, {C}, {}, {}, {}, {}, {} }</li></ul><p>将顶点 C 包含至 U 中：</p><ul><li>U = {false, false, <strong>true</strong>, false, false, false, false, false}</li></ul><p>更新顶点 C 至任一节点的距离：</p><ul><li>D = {<strong>6</strong>, <strong>9</strong>, <strong>0</strong>, <strong>11</strong>, INF, INF, INF, INF}</li><li>P = { {C,A}, {C,B}, {C}, {C,D}, {}, {}, {}, {} }</li></ul><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/b7724f85-3855-410c-9cc7-1cfcee5d29e4.png"></p><p>再选择不在 U 中的最短路径顶点 A，则将 A 包含至 U 中：</p><ul><li>U = {<strong>true</strong>, false, <strong>true</strong>, false, false, false, false, false}</li></ul><p>更新顶点 A 至任一节点的距离：</p><ul><li>D = {<strong>6</strong>, <strong>9</strong>, <strong>0</strong>, <strong>11</strong>, INF, <strong>25</strong>, INF, INF}</li><li>P = { {C,A}, {C,B}, {C}, {C,D}, {}, {C,A,F}, {}, {} }</li></ul><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/c5f725fc-f801-4e93-9f32-5adb8a76e1a0.png"></p><p>继续选择不在 U 中的最短路径顶点 B，则将 B 包含至 U 中：</p><ul><li>U = {<strong>true</strong>, <strong>true</strong>, <strong>true</strong>, false, false, false, false, false}</li></ul><p>更新顶点 B 至任一节点的距离：</p><ul><li>D = {<strong>6</strong>, <strong>9</strong>, <strong>0</strong>, <strong>11</strong>, <strong>16</strong>, <strong>25</strong>, INF, INF}</li><li>P = { {C,A}, {C,B}, {C}, {C,D}, {C,B,E}, {C,A,F}, {}, {} }</li></ul><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/45552677-bcd6-4d45-b627-a398f0cfe04d.png"></p><p>以此类推，直到遍历结束：</p><ul><li>U =  {<strong>true</strong>, <strong>true</strong>, <strong>true</strong>, <strong>true</strong>, <strong>true</strong>, <strong>true</strong>, <strong>true</strong>, <strong>true</strong>}</li><li>D = {<strong>6</strong>, <strong>9</strong>, <strong>0</strong>, <strong>11</strong>, <strong>16</strong>, <strong>21</strong>, <strong>33</strong>, <strong>16</strong>}</li><li>P = { {C,A}, {C,B}, {C}, {C,D}, {C,B,E}, {C,B,E,F}, {C,B,E,F,G}, {C,D,H} }</li></ul><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-5/7eeefcb6-6b96-4719-9819-c96b31309449.png"></p><p>因此，CG 的最短距离为 33，最短路径为 C-B-E-F-G。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a><a href="https://github.com/fan-haobai/2017-ziroom-king/blob/master/src/7.php">编码实现</a></h2><p>实现的代码如下，并将一一详细说明。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;MAX&#x27;</span>, <span class="number">9999999999</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//图对应索引数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$indexMatrix</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//顶点与索引映射关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$indexMap</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$startPoint</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$endPoint</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$len</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最短距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$D</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//已寻找集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$U</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//最短路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$P</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$matrix</span>, <span class="variable">$startPoint</span>, <span class="variable">$endPoint</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;indexMap = <span class="title function_ invoke__">array_keys</span>(<span class="variable">$matrix</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;len = <span class="title function_ invoke__">count</span>(<span class="variable">$matrix</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">array_walk</span>(<span class="variable">$matrix</span>, function(&amp;<span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$value</span> = <span class="title function_ invoke__">array_values</span>(<span class="variable">$value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;indexMatrix = <span class="title function_ invoke__">array_values</span>(<span class="variable">$matrix</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;startPoint = <span class="title function_ invoke__">array_search</span>(<span class="variable">$startPoint</span>, <span class="variable">$this</span>-&gt;indexMap);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;endPoint = <span class="title function_ invoke__">array_search</span>(<span class="variable">$endPoint</span>, <span class="variable">$this</span>-&gt;indexMap);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;len; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="comment">//初始化距离</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;D[<span class="variable">$i</span>] = <span class="variable language_">$this</span>-&gt;indexMatrix[<span class="variable language_">$this</span>-&gt;startPoint][<span class="variable">$i</span>] &gt; <span class="number">0</span> ? <span class="variable language_">$this</span>-&gt;indexMatrix[<span class="variable language_">$this</span>-&gt;startPoint][<span class="variable">$i</span>] : MAX;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;P[<span class="variable">$i</span>] = <span class="keyword">array</span>();</span><br><span class="line">            <span class="comment">//初始化已寻找集合</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$i</span> != <span class="variable language_">$this</span>-&gt;startPoint) &#123;</span><br><span class="line">                <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;P[<span class="variable">$i</span>], <span class="variable">$i</span>);</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;U[<span class="variable">$i</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;U[<span class="variable">$i</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDistance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;D[<span class="variable language_">$this</span>-&gt;endPoint];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPath</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="variable language_">$this</span>-&gt;P[<span class="variable language_">$this</span>-&gt;endPoint];</span><br><span class="line">        <span class="title function_ invoke__">array_unshift</span>(<span class="variable">$path</span>, <span class="variable">$this</span>-&gt;startPoint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$path</span> <span class="keyword">as</span> &amp;<span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;indexMap[<span class="variable">$value</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$path</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra 算法求解：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dijkstra</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$l</span> = <span class="number">1</span>; <span class="variable">$l</span> &lt; <span class="variable language_">$this</span>-&gt;len; <span class="variable">$l</span>++) &#123;</span><br><span class="line">        <span class="variable">$min</span> = MAX;</span><br><span class="line">        <span class="comment">//查找距离源点最近的节点&#123;v&#125;</span></span><br><span class="line">        <span class="variable">$v</span> = <span class="variable language_">$this</span>-&gt;startPoint;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;len; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;U[<span class="variable">$i</span>] &amp;&amp; <span class="variable language_">$this</span>-&gt;D[<span class="variable">$i</span>] &lt; <span class="variable">$min</span>) &#123;</span><br><span class="line">                <span class="variable">$min</span> = <span class="variable language_">$this</span>-&gt;D[<span class="variable">$i</span>];</span><br><span class="line">                <span class="variable">$v</span> = <span class="variable">$i</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;U[<span class="variable">$v</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;len; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;U[<span class="variable">$i</span>] &amp;&amp; (<span class="variable">$min</span> + <span class="variable language_">$this</span>-&gt;indexMatrix[<span class="variable">$v</span>][<span class="variable">$i</span>] &lt; <span class="variable language_">$this</span>-&gt;D[<span class="variable">$i</span>])) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;D[<span class="variable">$i</span>] = <span class="variable">$min</span> + <span class="variable language_">$this</span>-&gt;indexMatrix[<span class="variable">$v</span>][<span class="variable">$i</span>];</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;P[<span class="variable">$i</span>] = <span class="title function_ invoke__">array_merge</span>(<span class="variable">$this</span>-&gt;P[<span class="variable">$v</span>], <span class="keyword">array</span>(<span class="variable">$i</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收标准输入处理并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="variable">$matrix</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; <span class="number">15</span>, <span class="string">&#x27;C&#x27;</span> =&gt; <span class="number">6</span>, <span class="string">&#x27;D&#x27;</span> =&gt; MAX, <span class="string">&#x27;E&#x27;</span> =&gt; MAX, <span class="string">&#x27;F&#x27;</span> =&gt; <span class="number">25</span>, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; MAX),</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; <span class="number">15</span>, <span class="string">&#x27;B&#x27;</span> =&gt; MAX, <span class="string">&#x27;C&#x27;</span> =&gt; <span class="number">9</span>, <span class="string">&#x27;D&#x27;</span> =&gt; MAX, <span class="string">&#x27;E&#x27;</span> =&gt; <span class="number">7</span>, <span class="string">&#x27;F&#x27;</span> =&gt; MAX, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; MAX),</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; <span class="number">9</span>, <span class="string">&#x27;C&#x27;</span> =&gt; MAX, <span class="string">&#x27;D&#x27;</span> =&gt; <span class="number">11</span>, <span class="string">&#x27;E&#x27;</span> =&gt; MAX, <span class="string">&#x27;F&#x27;</span> =&gt; MAX, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; MAX),</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; MAX, <span class="string">&#x27;C&#x27;</span> =&gt; <span class="number">11</span>, <span class="string">&#x27;D&#x27;</span> =&gt; MAX, <span class="string">&#x27;E&#x27;</span> =&gt; <span class="number">12</span>, <span class="string">&#x27;F&#x27;</span> =&gt; MAX, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; <span class="number">5</span>),</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; <span class="number">7</span>, <span class="string">&#x27;C&#x27;</span> =&gt; <span class="number">6</span>, <span class="string">&#x27;D&#x27;</span> =&gt; <span class="number">12</span>, <span class="string">&#x27;E&#x27;</span> =&gt; MAX, <span class="string">&#x27;F&#x27;</span> =&gt; <span class="number">5</span>, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; <span class="number">7</span>),</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; <span class="number">25</span>, <span class="string">&#x27;B&#x27;</span> =&gt; MAX, <span class="string">&#x27;C&#x27;</span> =&gt; <span class="number">6</span>, <span class="string">&#x27;D&#x27;</span> =&gt; MAX, <span class="string">&#x27;E&#x27;</span> =&gt; <span class="number">5</span>, <span class="string">&#x27;F&#x27;</span> =&gt; MAX, <span class="string">&#x27;G&#x27;</span> =&gt; <span class="number">12</span>, <span class="string">&#x27;H&#x27;</span> =&gt; MAX),</span><br><span class="line">    <span class="string">&#x27;G&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; MAX, <span class="string">&#x27;C&#x27;</span> =&gt; MAX, <span class="string">&#x27;D&#x27;</span> =&gt; MAX, <span class="string">&#x27;E&#x27;</span> =&gt; MAX, <span class="string">&#x27;F&#x27;</span> =&gt; <span class="number">12</span>, <span class="string">&#x27;G&#x27;</span> =&gt; MAX, <span class="string">&#x27;H&#x27;</span> =&gt; <span class="number">17</span>),</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;A&#x27;</span> =&gt; MAX, <span class="string">&#x27;B&#x27;</span> =&gt; MAX, <span class="string">&#x27;C&#x27;</span> =&gt; MAX, <span class="string">&#x27;D&#x27;</span> =&gt; <span class="number">5</span>, <span class="string">&#x27;E&#x27;</span> =&gt; <span class="number">7</span>, <span class="string">&#x27;F&#x27;</span> =&gt; <span class="number">25</span>, <span class="string">&#x27;G&#x27;</span> =&gt; <span class="number">17</span>, <span class="string">&#x27;H&#x27;</span> =&gt; MAX),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CG</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="variable">$input</span> = <span class="title function_ invoke__">trim</span>(<span class="title function_ invoke__">fgets</span>(STDIN), <span class="string">&quot; \t\n\r\0\x0B[]&quot;</span>));</span><br><span class="line"><span class="variable">$path</span> = <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="variable">$matrix</span>, <span class="variable">$input</span>&#123;<span class="number">0</span>&#125;, <span class="variable">$input</span>&#123;<span class="number">1</span>&#125;);</span><br><span class="line"><span class="variable">$path</span>-&gt;<span class="title function_ invoke__">dijkstra</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$path</span>-&gt;<span class="title function_ invoke__">getDistance</span>(), <span class="string">&#x27; &#x27;</span>, <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;-&#x27;</span>, <span class="variable">$path</span>-&gt;<span class="title function_ invoke__">getPath</span>()), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本问题是求无向图源点的最短路径，时间复杂度为 $O(n^2)$，若求解有向图源点的最短路径，只需将相邻顶点的逆向路径置为 ∞，即修改初始图的矩阵。不得不说的是，比求单源点最短路径更加复杂的求某一对顶点的最短路径问题，也可以以每一个顶点为源点使用 Dijkstra 算法求解，但是有更加简洁的 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd</a> 算法。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html">王者编程大赛之一</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html">王者编程大赛之二 — 蓄水池</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html">王者编程大赛之三 — 01背包</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html">王者编程大赛之四 — 约瑟夫环</a> <span>（2017-12-06）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自如年底就会拥有 50W 间房子，大家知道每间房房子都是需要配置完才能出租给自如客的，整个房租的配置过程是很复杂的，每天都需要大量的物流师傅将家电、家具等物品从仓库送到需要配置的每个房间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/2017-ziroom-king-5/40beff35-47fc-4427-8805-e183233b598b.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>王者编程大赛之四 — 约瑟夫环</title>
    <link href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html"/>
    <id>https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html</id>
    <published>2017-12-06T05:12:00.000Z</published>
    <updated>2024-04-18T08:38:12.679Z</updated>
    
    <content type="html"><![CDATA[<p>每年夏季自如都会组织夏季夏令营活动，给来京参加夏令营的小朋友准备好多礼物，今年也是如此。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-4/3d9cf2e7-dfe6-4b6e-8526-991296c3ea51.png"><span id="more"></span></p><p>组委会准备了一些小游戏来获得这些礼物，其中有一个游戏是这样的：组委会让小朋友围成一个圈。然后随机制定一个数 e，让编号为 0 的小朋友开始报数。每次喊道 e-1 的小朋友直接出列，淘达出局。从本次喊道 e-1 的下一个小朋友开始，继续从 0 报数…e-1 淘汰出局…一直这样进行…最后进行到最后一个小朋友，这位可以拿到”熊帅”亲笔签名的”木木”毛绒玩具。（注：小朋友的编号是从 0 到 n-1 )</p><p>示例：<br>输入：n=1314 e=520<br>输出：796<br>输入：n=88888 e=1018<br>输出：69148</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是一个 <a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫环</a> 问题（猴子选大王），这里运用数学知识找出递推关系式。</p><p>假设，总共有 n 个人，数到 k（n &gt;= k）的人被杀掉，幸存者的位置为 $p_n$（为了便于理解，编号从 1 开始）。</p><p>易知，初始位置为 k 的人会被第一个杀掉。此时，经过重新排序之后，问题变成了 n-1 个人的情形。幸存者的位置为 $p_{n-1}$。如果能够找到从 $p_{n}$ 到 $p_{n-1}$ 的递推关系，那么问题就解决了。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-4/3d9cf2e7-dfe6-4b6e-8526-991296c3ea51.png"></p><p>重新编号后，上一轮相对这一轮每个人位置关系映射为：</p><p>1 -&gt; n-k+1<br>2 -&gt; n-k+2<br>…<br>k-1 -&gt; n-1<br>k+1 -&gt; 1<br>…<br>$p_n$ -&gt; $p_{n-1}$<br>…<br>n-1 -&gt; n-k+1<br>n -&gt; n-k</p><p>这样，我们就得到一个递推关系式：<a href="#">$p_n = (p_{n-1} + k)$ % $n$</a>，初始条件 $p_1 = 1$（1 个人时幸存者为自己），当然该提递推公式同样适用于 n &lt; k 的情况。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a><a href="https://github.com/fan-haobai/2017-ziroom-king/blob/master/src/6.php">编码实现</a></h2><p>约瑟夫环递推实现：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">josephus</span>(<span class="params"><span class="variable">$n</span>, <span class="variable">$e</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$idx</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">2</span>; <span class="variable">$i</span> &lt;= <span class="variable">$n</span>; <span class="variable">$i</span> ++) &#123;</span><br><span class="line">        <span class="variable">$idx</span> = (<span class="variable">$idx</span> + <span class="variable">$e</span>) % <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$idx</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收标准输入处理并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$input</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="variable">$input</span>);</span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$input</span>, <span class="variable">$arr</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">josephus</span>(<span class="variable">$arr</span>[<span class="string">&#x27;n&#x27;</span>], <span class="variable">$arr</span>[<span class="string">&#x27;e&#x27;</span>]), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于本题只是需要求出最终的幸存者编号，所以可以直接使用递推公式求解，算法时间复杂度为 $O(n)$。若需要模拟整个游戏过程，则需要使用 <a href="http://blog.csdn.net/sxhelijian/article/details/9052891">链表</a> 模拟实现。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html">王者编程大赛之一</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html">王者编程大赛之二 — 蓄水池</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html">王者编程大赛之三 — 01背包</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html">王者编程大赛之五 — 最短路径</a> <span>（2017-12-06）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每年夏季自如都会组织夏季夏令营活动，给来京参加夏令营的小朋友准备好多礼物，今年也是如此。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/2017-ziroom-king-4/3d9cf2e7-dfe6-4b6e-8526-991296c3ea51.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>王者编程大赛之三 — 01背包</title>
    <link href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html"/>
    <id>https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html</id>
    <published>2017-12-05T15:12:00.000Z</published>
    <updated>2024-04-18T08:38:12.678Z</updated>
    
    <content type="html"><![CDATA[<p>服务目前每月会对搬家师傅进行评级，根据师傅的评级排名结果，我们将优先保证最优师傅的全天订单。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-3/9f4a2cb2-ab32-4b28-b054-b479c04270e5.png"><span id="more"></span></p><p>假设师傅每天工作 8 个小时，给定一天 n 个订单，每个订单其占用时间长为 $T_i$，挣取价值为 $V_i$，现请您为师傅安排订单，并保证师傅挣取价值最大。</p><p>输入格式<br>输入 n 组数据，每组以逗号分隔，并且每一个订单的编号、时长、挣取价值以空格分隔<br>输出格式<br>输出争取价值和订单编号，订单编号按照价值由大到小排序，争取价值相同，则按照每小时平均争取价值由大到小排序</p><p>示例：<br>输入：[MV10001 2 100,MV10008 2 30,MV10003 1 200,MV10009 6 500,MV10010 3 400]<br>输出：730 MV10010 MV10003 MV10001 MV10008<br>输入：[M10001 2 100,M10002 3 210,M10003 3 300,M10004 2 150,M10005 1 70,M10006 2 220,M10007 1 10,M10008 3 30,M10009 3 200,M10010 2 400]<br>输出：990 M10010 M10003 M10006 M10005</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于本题每个订单每天只被安排一次，是典型地采用 <a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a> 求解的 01 背包问题。</p><h3 id="动态规划概念"><a href="#动态规划概念" class="headerlink" title="动态规划概念"></a>动态规划概念</h3><p><a href="#">动态规划过程</a>：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><p><a href="#">动态规划原理</a>：动态规划与分治法类似，都是把原问题拆分成不同规模相同特征的小问题，通过寻找特定的递推关系，先解决一个个小问题，最终达到解决原问题的效果。</p><h3 id="建立动态方程"><a href="#建立动态方程" class="headerlink" title="建立动态方程"></a>建立动态方程</h3><p>假设，师傅挣取价值最大时的订单为 $x_1$,$x_2$,$x_3$,…,$x_i$（其中 $x_i$ 取 1 或 0，表示第 i 个订单被安排或者不安排），$v_i$ 表示第 i 个订单的价值，$w_i$ 表示第 i 个订单的耗时时长，$wv(i,j)$ 表示安排了第 i 个订单，师傅总耗时为 j 时的最大价值。</p><p>可得订单价值和耗时的关系图：</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>w(i)</td><td>2</td><td>2</td><td>1</td><td>6</td><td>3</td></tr><tr><td>v(i)</td><td>100</td><td>30</td><td>200</td><td>500</td><td>400</td></tr></tbody></table><p>因此，可得 <a href="#">动态方程</a>：</p><p>$$wv(i,j) = \begin{cases}<br>wv(i-1,j)(j &lt; w(i)) \<br>max(wx(i-1,j),wv(i-1,j-w(i))+v(i))(j \geq w(i))<br>\end{cases}$$</p><p>说明：$j&lt;w(i)$ 表示订单不被安排，$j \geq w(i)$ 表示订单被安排。</p><h3 id="确定边界"><a href="#确定边界" class="headerlink" title="确定边界"></a>确定边界</h3><p>可以确定边界条件 $wx(0,j) = wx(i, 0) = 0$，$wx(0,j)$ 表示一个订单都没安排，再怎么耗时价值都为 0，$wx(i,0)$ 表示没有耗时，安排多少订单价值都为 0。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-3/18359c82-3ff9-48c7-825e-77fe17419621.png"></p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>求解过程，可以填表来进行模拟：</p><ol><li>如 i=1,j=1 时，有 $j&lt;w(i)$，故 $wx(1,1) = wx(1-1,1) = 0$；</li><li>又如 i=1,j=2 时，有 $j=w(i)$，故 $wx(1,2) = max(wx(1-1,1), wx(1-1,2-w(1)) + v(1) = 100$；</li><li>如此下去，直至填到最后一个，i=5,j=8 时，有 $j&lt;w(i)$，故 $wx(5,8) = max(wx(5-1,8), wx(5-1,8-w(5)) + v(5) = 730$；</li><li>在耗时没有超过 8 小时的前提下，当前 5 个订单都被安排过时，$wx(5,8) = 730$ 即为所求的最大价值；</li></ol><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-3/366c6f00-35a1-46c6-ba98-76e3c7b3bae4.png"></p><h3 id="解的组成"><a href="#解的组成" class="headerlink" title="解的组成"></a>解的组成</h3><p>尽管 <a href="#%E6%B1%82%E8%A7%A3">求解</a> 过程已经求出了最大价值，但是并没有得出哪些订单被安排了，也就是没有得出解的组成部分。</p><p>但是在求解的过程中不难发现，寻解方程满足如下定义：</p><p>$$x(i) = \begin{cases}<br>wv(i,j) = wv(i-1,j) \<br>wv(i,j) \neq wv(i-1,j)<br>\end{cases}$$</p><p>从表格右下到左上为寻解方向，寻解过程如下：</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-3/9f4a2cb2-ab32-4b28-b054-b479c04270e5.png"></p><ol><li>i=5,j=8 时，有 $wv(5,8) != wv(4,8)$，故 $x(5) = 1$，此时 $j -= w(5)$，$j = 5$；</li><li>i=4 时，无论 j 取何值，都有 $wv(4,j) == wv(3,j)$，故 $x(5) = 0$，此时 $j = 5$；</li><li>i=3,j=5 时，有 $wv(3,5) != wv(2,5)$，故 $x(3) = 1$，此时 $j -= w(3)$，$j = 4$；</li><li>i=2,j=4时，有 $wv(2,4) != wv(1,4)$，故 $x(2) = 1$，此时 $j -= w(2)$，$j = 2$；</li><li>i=1,j=2时，有 $wv(1,2) != wv(1,2)$，故 $x(1) = 1$，此时 $j -= w(1)$，$j = 0$，寻解结束；</li></ol><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a><a href="https://github.com/fan-haobai/2017-ziroom-king/blob/master/src/5.php">编码实现</a></h2><p>实现的代码如下，并将一一详细说明。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//物品重量,index从1开始表示第1个物品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$w</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//物品价值,index从1开始表示第1个物品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//最大价值,$wv[$i][$w]表示前i个物品重量为w时的最大价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$wv</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//物品总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$n</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//物品总重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$W</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//背包中的物品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$goods</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Knapsack constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $goods 物品信息,格式如下:</span></span><br><span class="line"><span class="comment">     * [</span></span><br><span class="line"><span class="comment">     *   [index, w, v]   //good1</span></span><br><span class="line"><span class="comment">     *   ...</span></span><br><span class="line"><span class="comment">     * ]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$goods</span>, <span class="variable">$c</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;goods = <span class="variable">$goods</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;W = <span class="variable">$c</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;n = <span class="title function_ invoke__">count</span>(<span class="variable">$goods</span>);</span><br><span class="line">        <span class="comment">//初始化物品价值</span></span><br><span class="line">        <span class="variable">$v</span> = <span class="title function_ invoke__">array_column</span>(<span class="variable">$goods</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="title function_ invoke__">array_unshift</span>(<span class="variable">$v</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;v = <span class="variable">$v</span>;</span><br><span class="line">        <span class="comment">//初始化物品重量</span></span><br><span class="line">        <span class="variable">$w</span> = <span class="title function_ invoke__">array_column</span>(<span class="variable">$goods</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="title function_ invoke__">array_unshift</span>(<span class="variable">$w</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;w = <span class="variable">$w</span>;</span><br><span class="line">        <span class="comment">//初始化最大价值</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;wv = <span class="title function_ invoke__">array_fill</span>(<span class="number">0</span>, <span class="variable">$this</span>-&gt;n + <span class="number">1</span>, <span class="title function_ invoke__">array_fill</span>(<span class="number">0</span>, <span class="variable">$this</span>-&gt;W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">pd</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">canPut</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getMaxPrice</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;wv[<span class="variable language_">$this</span>-&gt;n][<span class="variable language_">$this</span>-&gt;W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态求解过程：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="variable language_">$this</span>-&gt;W; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt;= <span class="variable language_">$this</span>-&gt;n; <span class="variable">$j</span>++) &#123;</span><br><span class="line">            <span class="comment">//未放入物品和重量为空时,价值为0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$i</span> == <span class="number">0</span> || <span class="variable">$j</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//决策</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;w[<span class="variable">$j</span>]) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;wv[<span class="variable">$j</span>][<span class="variable">$i</span>] = <span class="variable language_">$this</span>-&gt;wv[<span class="variable">$j</span> - <span class="number">1</span>][<span class="variable">$i</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;wv[<span class="variable">$j</span>][<span class="variable">$i</span>] = <span class="title function_ invoke__">max</span>(<span class="variable">$this</span>-&gt;wv[<span class="variable">$j</span> - <span class="number">1</span>][<span class="variable">$i</span>], <span class="variable">$this</span>-&gt;wv[<span class="variable">$j</span> - <span class="number">1</span>][<span class="variable">$i</span> - <span class="variable">$this</span>-&gt;w[<span class="variable">$j</span>]] + <span class="variable">$this</span>-&gt;v[<span class="variable">$j</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻解过程：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">canPut</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$c</span> = <span class="variable language_">$this</span>-&gt;W;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable language_">$this</span>-&gt;n; <span class="variable">$i</span> &gt; <span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//背包质量为c时,前i-1个和前i-1个物品价值不变,表示第1个物品未放入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;wv[<span class="variable">$i</span>][<span class="variable">$c</span>] == <span class="variable language_">$this</span>-&gt;wv[<span class="variable">$i</span> - <span class="number">1</span>][<span class="variable">$c</span>]) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;goods[<span class="variable">$i</span> - <span class="number">1</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;goods[<span class="variable">$i</span> - <span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="variable">$c</span> = <span class="variable">$c</span> - <span class="variable language_">$this</span>-&gt;w[<span class="variable">$i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照订单价值降序获取订单信息（若订单价值相同则按单位时间平均价值降序排列）：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getGoods</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$filter</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$value</span>[<span class="number">3</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable">$goods</span> = <span class="title function_ invoke__">array_filter</span>(<span class="variable">$this</span>-&gt;goods, <span class="variable">$filter</span>);</span><br><span class="line">    <span class="title function_ invoke__">usort</span>(<span class="variable">$goods</span>, function(<span class="variable">$a</span>, <span class="variable">$b</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span>[<span class="number">2</span>] == <span class="variable">$b</span>[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$a</span>[<span class="number">2</span>] / <span class="variable">$a</span>[<span class="number">1</span>] &lt; <span class="variable">$b</span>[<span class="number">2</span>] / <span class="variable">$b</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$a</span>[<span class="number">2</span>] &lt; <span class="variable">$b</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$goods</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收标准输入处理并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$input</span>);</span><br><span class="line"><span class="variable">$filter</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">explode</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$knapsack</span> = <span class="keyword">new</span> <span class="title class_">Knapsack</span>(<span class="title function_ invoke__">array_map</span>(<span class="variable">$filter</span>, <span class="variable">$arr</span>), <span class="number">8</span>);</span><br><span class="line"><span class="variable">$goods</span> = <span class="variable">$knapsack</span>-&gt;<span class="title function_ invoke__">getGoods</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$knapsack</span>-&gt;<span class="title function_ invoke__">getMaxPrice</span>(), <span class="string">&#x27; &#x27;</span>, <span class="title function_ invoke__">implode</span>(<span class="string">&#x27; &#x27;</span>, <span class="title function_ invoke__">array_column</span>(<span class="variable">$goods</span>, <span class="number">0</span>)), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该题使用动态规划求解，算法的时间复杂度为 $O(nc)$，当然也可以采用其他方式求解。例如先将订单按照价值排序，然后依次尝试进行安排订单，直至剩余耗时不能再被安排订单。</p><p>有关动态规划的其他典型应用，请参考 <a href="https://www.cnblogs.com/wuyuegb2312/p/3281264.html">常见的动态规划问题分析与求解</a> 一文。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html">王者编程大赛之一</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html">王者编程大赛之二 — 蓄水池</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html">王者编程大赛之四 — 约瑟夫环</a> <span>（2017-12-06）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html">王者编程大赛之五 — 最短路径</a> <span>（2017-12-06）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务目前每月会对搬家师傅进行评级，根据师傅的评级排名结果，我们将优先保证最优师傅的全天订单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/2017-ziroom-king-3/9f4a2cb2-ab32-4b28-b054-b479c04270e5.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>王者编程大赛之二 — 蓄水池</title>
    <link href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html"/>
    <id>https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html</id>
    <published>2017-12-05T14:12:06.000Z</published>
    <updated>2024-04-18T08:38:12.677Z</updated>
    
    <content type="html"><![CDATA[<p>自如寓打算门口用砖头围立一个蓄水池子，从上面看凹凸不平，凹的地方会有积水。那如果用数字代表每个砖头的高度，就形成一个二维数据（如示例），请问这个池子能存储多少单位的水？<br><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-2/53afcc7a-ff51-4191-aab0-5c9cc6850566.png"><span id="more"></span></p><p>例如二维数组为：</p><p>9 9 9 9<br>3 0 0 9<br>7 8 2 6<br>时，答案是中间的 0,0 位置可以存储 2（因为其外面最低是 2）个单位的水，因此答案为 2 + 2 = 4。</p><p>示例：<br>输入：[1 1 1 1,1 0 0 1,1 1 1 1]<br>输出：2<br>输入：[12 11 12 0 13,12 9 8 12 12,13 10 0 3 15,19 4 4 7 15,19 4 3 0 15,12 13 10 15 13]<br>输出：58</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题是所有题中困惑我时间最长的题，一开始思维禁锢在想直接通过找到每块砖的四周有效最低砖高度 $H_{min}$，然后这块砖所剩的水为 $w[i][j] = H_{min}+h[i][j]$($h[i][j]$ 为砖的高度，i 和 j 为砖的位置坐标)，因此蓄水池能蓄下的水为 $\sum_{i=1}^n\sum_{j=1}^n w[i][j]$。经过一番尝试，发现寻找某块砖四周最低有效砖逻辑比较复杂，且不易理解，又尝试过使用回溯算法寻找出池子中的所有连通图，但是也未有果。</p><p>最后，发现基础平台一位同学的实现思路很清晰，我认为他的实现是最合适的，所以研究了一下。该实现中机智地采用逆向思维，<a href="#">首先往池子注满水（最高砖的高度），然后再通过条件判定每块砖是否需要进行漏水，一直到没有砖需要进行漏水操作</a>。</p><p>实现思路如下：</p><ol><li>找出高度最高的砖，高度记为 $H_{max}$；</li><li>对除去边界的砖进行注水操作，每块砖加水量为 $w[i][j] = H_{max} - h[i][j]$（$h[i][j]$ 为砖的高度）；</li><li>对某块砖进行漏水操作，只要这块砖有盛水且上下左右相邻的 4 块砖高度和盛水量之和小于这块砖高度和盛水量之和，则需要进行一次漏水，漏水条件可以描述为 $w[i][j] &gt; 0$ &amp;&amp; $h[i][j-1] + w[i][j-1] &lt; h[i][j] + w[i][j]$（该条件为砖左侧相邻的漏水条件，右、上、下同理可得）；</li><li>持续漏水操作，一直重复步骤 3 直至没有砖需要进行漏水操作；</li><li>求和砖的盛水量，$\sum_{i=1}^n\sum_{j=1}^n w[i][j]$ 即为水池的蓄水量；</li></ol><p>算法流程图示如下：</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-2/53afcc7a-ff51-4191-aab0-5c9cc6850566.png"></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a><a href="https://github.com/fan-haobai/2017-ziroom-king/blob/master/src/4.php">编码实现</a></h2><p>实现的代码如下，并将一一详细说明。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$gridArray</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$maxHeight</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$row</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$col</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;row = <span class="title function_ invoke__">count</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;col = <span class="title function_ invoke__">count</span>(<span class="variable">$data</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$row</span> =&gt; <span class="variable">$rowArray</span>) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$rowArray</span> <span class="keyword">as</span> <span class="variable">$col</span> =&gt; <span class="variable">$height</span>) &#123;</span><br><span class="line">                <span class="variable">$height</span> = (<span class="keyword">int</span>)<span class="variable">$height</span>;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>] = <span class="variable">$height</span>;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取最高砖的高度</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;maxHeight &lt; <span class="variable">$height</span>) &#123;</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;maxHeight = <span class="variable">$height</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否是水池边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isBorder</span>(<span class="params"><span class="variable">$row</span>, <span class="variable">$col</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$row</span> == <span class="number">0</span></span><br><span class="line">            || <span class="variable">$row</span> == <span class="variable language_">$this</span>-&gt;row - <span class="number">1</span></span><br><span class="line">            || <span class="variable">$col</span> == <span class="number">0</span></span><br><span class="line">            || <span class="variable">$col</span> == <span class="variable language_">$this</span>-&gt;col - <span class="number">1</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">addWater</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">removeWater</span>()) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注水操作：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addWater</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;gridArray <span class="keyword">as</span> <span class="variable">$row</span> =&gt; <span class="variable">$rowArray</span>) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$rowArray</span> <span class="keyword">as</span> <span class="variable">$col</span> =&gt; <span class="variable">$grid</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isBorder</span>(<span class="variable">$row</span>, <span class="variable">$col</span>)) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="variable language_">$this</span>-&gt;maxHeight - <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏水操作：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeWater</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;gridArray <span class="keyword">as</span> <span class="variable">$row</span> =&gt; <span class="variable">$rowArray</span>) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$rowArray</span> <span class="keyword">as</span> <span class="variable">$col</span> =&gt; <span class="variable">$grid</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">canRemove</span>(<span class="variable">$row</span>, <span class="variable">$col</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏水条件实现如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">canRemove</span>(<span class="params"><span class="variable">$row</span>, <span class="variable">$col</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$can</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>] &gt;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> - <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> - <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] =</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> - <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> - <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">                - <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$can</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>] &gt;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> + <span class="number">1</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> + <span class="number">1</span>][<span class="string">&#x27;height&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] =</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> + <span class="number">1</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> + <span class="number">1</span>][<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">                - <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$can</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>] &gt;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> + <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> + <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] =</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> + <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span> + <span class="number">1</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">                - <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$can</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>] &gt;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> - <span class="number">1</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> - <span class="number">1</span>][<span class="string">&#x27;height&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] =</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> - <span class="number">1</span>][<span class="string">&#x27;water&#x27;</span>] + <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span> - <span class="number">1</span>][<span class="string">&#x27;height&#x27;</span>]</span><br><span class="line">                - <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;gridArray[<span class="variable">$row</span>][<span class="variable">$col</span>][<span class="string">&#x27;water&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$can</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$can</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续漏水操作：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">removeWater</span>()) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求和砖的盛水量：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;gridArray <span class="keyword">as</span> <span class="variable">$row</span> =&gt; <span class="variable">$rowArray</span>) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$rowArray</span> <span class="keyword">as</span> <span class="variable">$col</span> =&gt; <span class="variable">$grid</span>) &#123;</span><br><span class="line">            <span class="variable">$sum</span> += <span class="variable">$grid</span>[<span class="string">&#x27;water&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收标准输入处理并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$filter</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">explode</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$pool</span> = <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="title function_ invoke__">array_map</span>(<span class="variable">$filter</span>, <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$input</span>)));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$pool</span>-&gt;<span class="title function_ invoke__">run</span>(), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><p>Twitter 之前曾经出过类似蓄水池的笔试题，只不过本题是立体水池（二维数组），Twitter 蓄水池笔试题是平面水池（一维数组），解题复杂度也就降低了，当然 Twitter 蓄水池笔试题也可以采用本题的思想来实现，但是时间复杂度为 $O(n^2)$，采用 <a href="http://blog.jobbole.com/50705/">我的Twitter技术面试失败了</a> 的实现时间复杂度为 $O(n)$。<br><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-2/b2f137ff-b91b-4036-b7d8-fc86f82fb980.png"></p><p>实现思路如下：</p><ol><li>首先，用两个指针（left 和 right）分别指向数组的第一个元素和最后一个元素，左指针从左向右遍历，右指针从右向左遍历；</li><li>初始化数组中一个元素（a[0]）为左边遍历得到的最大值（max_left），最后一个元素（a[a.length-1]）为从右边遍历得到的最大值（max_right）；</li><li>开始遍历，遍历结束条件为 <a href="#">左指针不小于右指针</a>；</li><li>如果左边遍历的最大值小于右边遍历的最大值，说明只要有水沟（即小于左边最大值 max_left 的元素）就会有积水，因为右边的最大值可以保证左边水沟的积水不会流失掉；同样，如果左边遍历的最大值不小于右边遍历的最大值，只要右边有水沟（即小于右边最大值 max_right 的元素）就会有积水；</li></ol><p>具体实现，请直接参考 <a href="https://github.com/CuGBabyBeaR/Interview-questions/blob/master/twitter-puddle/puddle.py">CuGBabyBeaR</a> 文章。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题的蓄水池问题，如果理解了问题本质并逆向思维，将寻找某块砖四周最低有效砖高度（寻找有效砖涉及到边界扩散）转化为判断某块砖是否需要漏水条件，那么问题就简化很多了，那后续编码也就很容易实现了，本文算法的时间复杂度为 $O(n^3)$。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html">王者编程大赛之一</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html">王者编程大赛之三 — 01背包</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html">王者编程大赛之四 — 约瑟夫环</a> <span>（2017-12-06）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html">王者编程大赛之五 — 最短路径</a> <span>（2017-12-06）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自如寓打算门口用砖头围立一个蓄水池子，从上面看凹凸不平，凹的地方会有积水。那如果用数字代表每个砖头的高度，就形成一个二维数据（如示例），请问这个池子能存储多少单位的水？&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/2017-ziroom-king-2/53afcc7a-ff51-4191-aab0-5c9cc6850566.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>王者编程大赛之一</title>
    <link href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html"/>
    <id>https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html</id>
    <published>2017-12-04T21:12:06.000Z</published>
    <updated>2024-04-18T08:38:12.676Z</updated>
    
    <content type="html"><![CDATA[<p>本次王者编程大赛分为 3 个组别，分别为研发、测试、移动战场。这里只讨论研发战场所考的 <a href="https://github.com/fan-haobai/2017-ziroom-king">题目</a>，本次大赛共有 7 道题，主要考查点为基础算法，解题所用语言不做限制，但是需要在 <a href="http://www.anycodes.cn/zh/">在线验证平台</a> 使用标准输入并验证通过，最后成绩以正确性和答题时间为评定依据。<br><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/f9829b13-af2e-4c7b-b214-40bc78223c18.png"><span id="more"></span></p><p>所有题目中第 4 题蓄水池问题，是困惑我时间比较长的，其他题目比较容易看出考察点，这里我给出了 7 道题目自己的 <a href="https://github.com/fan-haobai/2017-ziroom-king/tree/master/src">实现方式</a>，仅作为解题参考，若你有更好的思路欢迎讨论交流。</p><p>本章只叙述前 3 道相对简单的题目，后续题目及解题思路将在 <a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html">王者编程大赛系列</a> 中列出。</p><h2 id="标准输入过滤"><a href="#标准输入过滤" class="headerlink" title="标准输入过滤"></a>标准输入过滤</h2><p>由于采用标准输入进行输入，为了防止输入多余的字符，影响程序执行结果，所以有必要对输入进行过滤处理。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待输入并过滤</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="variable">$input</span> = <span class="title function_ invoke__">trim</span>(<span class="title function_ invoke__">fgets</span>(STDIN), <span class="string">&quot; \t\n\r\0\x0B[]&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>活动“司庆大放送，一元即租房”，司庆当日，对于签约入住的客户，住满 30 天，返还（首月租金 -1 元）额度的租金卡。租金卡的面额遵循了类似人民币的固定面额（1000 元、500 元、100 元、50 元、20 元、10 元、5 元、1 元），请实现一个算法，给客户返还的租金卡张数是最少的。</p><p>示例：<br>输入（租金卡金额）：54<br>输出：5<br>输入（租金卡金额）：9879<br>输出：20</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题其实就是，对租金卡的金额对题目中所列出的租金卡面额按照从大到小的顺序做商，一直到余数为 0。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCards</span>(<span class="params"><span class="variable">$rent</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$cardMoney</span> = <span class="keyword">array</span>(<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="variable">$cardNumber</span> = <span class="title function_ invoke__">array_fill</span>(<span class="number">0</span>, <span class="title function_ invoke__">count</span>(<span class="variable">$cardMoney</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="variable">$cardNumber</span>[<span class="variable">$i</span>] = <span class="title function_ invoke__">intval</span>(<span class="variable">$rent</span> / <span class="variable">$cardMoney</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="variable">$rent</span> = <span class="variable">$rent</span> % <span class="variable">$cardMoney</span>[<span class="variable">$i</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rent</span> &lt; <span class="variable">$cardMoney</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">            <span class="comment">//移动到下一个面额</span></span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="variable">$rent</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$cardNumber</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入:54</span></span><br><span class="line"><span class="variable">$card</span> = <span class="title function_ invoke__">getCards</span>((<span class="keyword">int</span>)<span class="variable">$input</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">array_sum</span>(<span class="variable">$card</span>), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><h3 id="题目（排列组合）"><a href="#题目（排列组合）" class="headerlink" title="题目（排列组合）"></a>题目（排列组合）</h3><p>2016 年自如将品质管理中心升级为安全与品质管理中心，并开通了自如举报邮箱。请看下边的算式</p><p>1 2 3 4 5 6 7 8 9 = 110（举报邮箱前缀数字）;</p><p>为了使等式成立，需要在数字间填入加号或者减号（可以不填，但不能填入其它符号）。之间没有填入符号的数字组合成一个数，例如：12 + 34 + 56 + 7 - 8 + 9 就是一种合格的填法。</p><p>请大家帮忙计算出多少个可能组合吧，至少 3 个以上算有效。</p><p>示例：<br>输入：[1 2 3 4 5 6 7 8 9]<br>输出：12 + 34 + 56 + 7 - 8 + 9</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题考查点是排列组合问题，待连接的数字已经有序，所以只需要确定相邻两个数字的连接符即可。假设待连接数字的长度为 n，那么问题可以描述为，将空格、+、- 这 3 种连接符插入到 n-1 个相邻待连接数字之间的位置，所以共有 3^n-1 种情况，然后判断每种情况的计算结果是否为等式右边的数字。</p><p>为了获取 3 种连接符组成的 3^n-1 种组合情况，这里巧妙地运用 <a href="#">3 进制运算</a> 来实现。</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/25fc16ed-ebdd-4094-84a4-150ad9a31b1f.png"></p><p>算法执行流程：</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/d4724b85-8491-451a-8b3c-d6c06842ec69.png"></p><h2 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h2><p>实现代码如下，并将一一详细说明。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$operate</span> = <span class="keyword">array</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$originLen</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span>, <span class="variable">$sum</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;originLen = <span class="title function_ invoke__">count</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;sum = <span class="variable">$sum</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;data[<span class="variable">$k</span>*<span class="number">2</span>] = <span class="variable">$value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 进制运算的实现，注意需要对高位进行补 0 的操作，其中 number 为 3^n-1（组合情况）。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ternary</span>(<span class="params"><span class="variable">$number</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$pos</span> = <span class="number">2</span> * <span class="variable language_">$this</span>-&gt;originLen - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="variable">$mod</span> = <span class="variable">$number</span> % <span class="number">3</span>;</span><br><span class="line">        <span class="variable">$number</span> = (<span class="keyword">int</span>)(<span class="variable">$number</span> / <span class="number">3</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;data[<span class="variable">$pos</span>] = <span class="variable language_">$this</span>-&gt;operate[<span class="variable">$mod</span>];</span><br><span class="line">        <span class="variable">$pos</span> -= <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="variable">$number</span>);</span><br><span class="line">    <span class="comment">//高位补0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$pos</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;data[<span class="variable">$pos</span>] = <span class="variable language_">$this</span>-&gt;operate[<span class="number">0</span>];</span><br><span class="line">        <span class="variable">$pos</span> -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">ksort</span>(<span class="variable">$this</span>-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 3 种连接符组成 3^n-1 种组合，根据等式成立情况进行取舍：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$result</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="variable">$times</span> = <span class="title function_ invoke__">pow</span>(<span class="number">3</span>, <span class="variable">$this</span>-&gt;originLen - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$times</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="comment">//模拟3进制的运算</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ternary</span>(<span class="variable">$i</span>);</span><br><span class="line">        <span class="comment">//决策</span></span><br><span class="line">        <span class="variable">$str</span> = <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, <span class="variable">$this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">eval</span>(<span class="string">&quot;return <span class="subst">$str</span>;&quot;</span>) == <span class="variable language_">$this</span>-&gt;sum) &#123;</span><br><span class="line">            <span class="variable">$result</span>[] = <span class="variable">$str</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收标准输入并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入:[1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="variable">$rank</span> = <span class="keyword">new</span> <span class="title class_">Rank</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27; &#x27;</span>, <span class="variable">$input</span>), <span class="number">110</span>);</span><br><span class="line"><span class="title function_ invoke__">array_walk</span>(<span class="variable">$rank</span>-&gt;<span class="title function_ invoke__">run</span>(), function(<span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$value</span>, PHP_EOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><h3 id="题目（排序）"><a href="#题目（排序）" class="headerlink" title="题目（排序）"></a>题目（排序）</h3><p>给定一个所有元素为非负的数组，将数组中的所有数字连接起来，求最大的那个数。</p><p>示例：<br>输入：4,94,9,14,1<br>输出：9944141<br>输入：121,89,98,15,4,3451<br>输出：98894345115121</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题是我司的笔试题目之一，我之前写的<a href="https://www.fanhaobai.com/2017/04/array-form-max-string.html">《求非负数组元素组成的最大字符串》</a>文章，已经有过实现过程的描述。当然这道题可能有很多种实现方式，但是我认为最合适的实现还是采用排序的方式，容易理解，实现也简洁。</p><ul><li>比较规则：分析 a 和 b 的排列，因为这 2 个数存在 2 种排列情况，既 <a href="#"><em>a_b</em></a> 和 <a href="#"><em>b_a</em></a>，若 <a href="#"><em>a_b</em></a> 组合值大于 <a href="#"><em>b_a</em></a> 组合，那么认为 a “大于” b，则 a 需要排列在 b 前面，反之则需要交换 a 和 b 的位置。同我们熟悉的排序算法唯一不同的是，这里不是直接通过比较 2 个元素值大小，而是需要通过排列后的 2 个新值进行大小比较。</li><li>排序算法：由于只是比较规则的不同，所以常用的排序算法（冒泡、快速、堆）一样适用。</li></ul><p>这里使用冒泡排序来进行说明，每一趟找出待排序元素的最小值，算法执行流程如下：</p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/a1cb7d2c-7fb6-4dbd-a363-3cd9e300743d.png"></p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/d0955aea-2787-4e6b-adea-8fe1f61236de.png"></p><p><img src="//www.fanhaobai.com/2017/12/2017-ziroom-king-1/03a07a80-8bc3-46d1-bcab-17e2a057d951.png"></p><h3 id="编码实现-2"><a href="#编码实现-2" class="headerlink" title="编码实现"></a>编码实现</h3><p>定义比较规则，ab 和 ba 组合后的数字进行值大小的比较：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$a</span> == <span class="variable">$b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span> . <span class="variable">$b</span> &gt; <span class="variable">$b</span> . <span class="variable">$a</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收输入并输出结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_form_max_str</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$Arr</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$Arr</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$value</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">usort</span>(<span class="variable">$Arr</span>, <span class="string">&quot;cmp&quot;</span>);</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, <span class="variable">$Arr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入:4,94,9,14,1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">array_form_max_str</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$input</span>)), PHP_EOL;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这 3 道题算是热身吧，第 2 题巧妙运用 3 进制运算来模拟排列情况，都相对较容易，只是实现方式你是否会在意优雅而已。虽然简单，但是也不建议一上来就开始编码，首先要想清楚解题思路，然后编码实现即可。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-2.html">王者编程大赛之二 — 蓄水池</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-3.html">王者编程大赛之三 — 01背包</a> <span>（2017-12-05）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-4.html">王者编程大赛之四 — 约瑟夫环</a> <span>（2017-12-06）</span></li><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-5.html">王者编程大赛之五 — 最短路径</a> <span>（2017-12-06）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次王者编程大赛分为 3 个组别，分别为研发、测试、移动战场。这里只讨论研发战场所考的 &lt;a href=&quot;https://github.com/fan-haobai/2017-ziroom-king&quot;&gt;题目&lt;/a&gt;，本次大赛共有 7 道题，主要考查点为基础算法，解题所用语言不做限制，但是需要在 &lt;a href=&quot;http://www.anycodes.cn/zh/&quot;&gt;在线验证平台&lt;/a&gt; 使用标准输入并验证通过，最后成绩以正确性和答题时间为评定依据。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/12/2017-ziroom-king-1/f9829b13-af2e-4c7b-b214-40bc78223c18.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>异步、并发、协程原理</title>
    <link href="https://www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine.html"/>
    <id>https://www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine.html</id>
    <published>2017-11-13T02:45:30.000Z</published>
    <updated>2024-04-18T08:38:12.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://wiki.phpboy.net/doku.php?id=2017-07:55-%E5%BC%82%E6%AD%A5_%E5%B9%B6%E5%8F%91_%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86.md">http://wiki.phpboy.net/doku.php?id=2017-07:55-异步_并发_协程原理.md</a></p></blockquote><p>Linux 操作系统在设计上将虚拟空间划分为用户空间和内核空间，两者做了隔离是相互独立的，用户空间给应用程序使用，内核空间给内核使用。<br><img src="//www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine/a89c6e5b-facd-47a1-a26b-c8fb747e9650.jpg"><span id="more"></span></p><h2 id="一、异步"><a href="#一、异步" class="headerlink" title="一、异步"></a>一、异步</h2><h2 id="应用程序和内核"><a href="#应用程序和内核" class="headerlink" title="应用程序和内核"></a>应用程序和内核</h2><p>内核具有最高权限，可以访问受保护的内存空间，可以访问底层的硬件设备。而这些是应用程序所不具备的，但应用程序可以通过调用内核提供的接口来间接访问或操作。所谓的常见的 IO 模型就是基于应用程序和内核之间的交互所提出来的。以一次网络 IO 请求过程中的 read 操作为例，请求数据会先拷贝到系统内核的缓冲区（内核空间），再从操作系统的内核缓冲区拷贝到应用程序的地址空间（用户空间）。而从内核空间将数据拷贝到用户空间过程中，就会经历两个阶段： </p><ul><li>等待数据准备</li><li>拷贝数据</li></ul><p>也正因为有了这两个阶段，才提出了各种网络 I/O 模型。</p><h3 id="Unix-Linux的体系架构"><a href="#Unix-Linux的体系架构" class="headerlink" title="Unix/Linux的体系架构"></a>Unix/Linux的体系架构</h3><p><img src="//www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine/88bb24ee-b443-407d-ad14-fdae5a7113d6.png"></p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步（Synchronised）和异步（Asynchronized）的概念描述的是应用程序与内核的交互方式，同步是指应用程序发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；而异步是指应用程序发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知应用程序，或者调用应用程序注册的回调函数。</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞的概念描述的是应用程序调用内核 IO 操作的方式，阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；而非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</p><p><strong>常见的网络I/O模型大概有四种：</strong></p><ol><li>同步阻塞IO（Blocking IO）</li><li>同步非阻塞IO（Non-blocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>异步IO（Asynchronous IO）</li></ol><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。** IO 多路复用是异步阻塞的。**</p><h2 id="二、并发"><a href="#二、并发" class="headerlink" title="二、并发"></a>二、并发</h2><p>并发，在操作系统中，是指 <strong>一个时间段</strong> 中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p><p><strong>并发和并行的区别：</strong></p><ul><li>并发（concurrency）：逻辑上具备同时处理多个任务的能力。</li><li>并行（parallesim）：物理上在同一时刻执行多个并发任务，依赖多核处理器等物理设备。</li></ul><p>多线程或多进程是并行的基本条件，但单线程也可用协程做到并发。通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。现代系统中，多核 CPU 可以同时运行多个不同的进程或者线程。所以并发程序可以是并行的，也可以不是。</p><h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>在了解协程前先了解一些概念：</p><h3 id="1、线程模型"><a href="#1、线程模型" class="headerlink" title="1、线程模型"></a>1、线程模型</h3><p>在现代计算机结构中，先后提出过两种线程模型：用户级线程（user-level threads）和内核级线程（kernel-level threads）。所谓用户级线程是指，应用程序在操作系统提供的单个控制流的基础上，通过在某些控制点（比如系统调用）上分离出一些虚拟的控制流，从而模拟多个控制流的行为。由于应用程序对指令流的控制能力相对较弱，所以，用户级线程之间的切换往往受线程本身行为以及线程控制点选择的影响，线程是否能公平地获得处理器时间取决于这些线程的代码特征。而且，支持用户级线程的应用程序代码很难做到跨平台移植，以及对于多线程模型的透明。用户级线程模型的优势是线程切换效率高，因为它不涉及系统内核模式和用户模式之间的切换；另一个好处是应用程序可以采用适合自己特点的线程选择算法，可以根据应用程序的逻辑来定义线程的优先级，当线程数量很大时，这一优势尤为明显。但是，这同样会增加应用程序代码的复杂性。有一些软件包（如 POSIXThreads 或 Pthreads 库）可以减轻程序员的负担。</p><p>内核级线程往往指操作系统提供的线程语义，由于操作系统对指令流有完全的控制能力，甚至可以通过硬件中断来强迫一个进程或线程暂停执行，以便把处理器时间移交给其他的进程或线程，所以，内核级线程有可能应用各种算法来分配处理器时间。线程可以有优先级，高优先级的线程被优先执行，它们可以抢占正在执行的低优先级线程。在支持线程语义的操作系统中，处理器的时间通常是按线程而非进程来分配，因此，系统有必要维护一个全局的线程表，在线程表中记录每个线程的寄存器、状态以及其他一些信息。然后，系统在适当的时候挂起一个正在执行的线程，选择一个新的线程在当前处理器上继续执行。这里“适当的时候”可以有多种可能，比如：当一个线程执行某些系统调用时，例如像 sleep 这样的放弃执行权的系统函数，或者像 wait 或 select 这样的阻塞函数；硬中断（interrupt）或异常（exception）；线程终止时，等等。由于这些时间点的执行代码可能分布在操作系统的不同位置，所以，在现代操作系统中，线程调度（thread scheduling）往往比较复杂，其代码通常分布在内核模块的各处。</p><p>内核级线程的好处是，应用程序无须考虑是否要在适当的时候把控制权交给其他的线程，不必担心自己霸占处理器而导致其他线程得不到处理器时间。应用线程只要按照正常的指令流来实现自己的逻辑即可，内核会妥善地处理好线程之间共享处理器的资源分配问题。然而，这种对应用程序的便利也是有代价的，即，所有的线程切换都是在内核模式下完成的，因此，对于在用户模式下运行的线程来说，一个线程被切换出去，以及下次轮到它的时候再被切换进来，要涉及两次模式切换：从用户模式切换到内核模式，再从内核模式切换回用户模式。在 Intel 的处理器上，这种模式切换大致需要几百个甚至上千个处理器指令周期。但是，随着处理器的硬件速度不断加快，模式切换的开销相对于现代操作系统的线程调度周期（通常几十毫秒）的比例正在减小，所以，这部分开销是完全可以接受的。</p><p>除了线程切换的开销是一个考虑因素以外，线程的创建和删除也是一个重要的考虑指标。当线程的数量较多时，这部分开销是相当可观的。虽然线程的创建和删除比起进程要轻量得多，但是，在一个进程内建立起一个线程的执行环境，例如，分配线程本身的数据结构和它的调用栈，完成这些数据结构的初始化工作，以及完成与系统环境相关的一些初始化工作，这些负担是不可避免的。另外，当线程数量较多时，伴随而来的线程切换开销也必然随之增加。所以，当应用程序或系统进程需要的线程数量可能比较多时，通常可采用线程池技术作为一种优化措施，以降低创建和删除线程以及线程频繁切换而带来的开销。</p><p>在支持内核级线程的系统环境中，进程可以容纳多个线程，这导致了多线程程序设计（multithreaded programming）模型。由于多个线程在同一个进程环境中，它们共享了几乎所有的资源，所以，线程之间的通信要方便和高效得多，这往往是进程间通信（IPC，Inter-Process Communication）所无法比拟的，但是，这种便利性也很容易使线程之间因同步不正确而导致数据被破坏，而且，这种错误存在不确定性，因而相对来说难以发现和调试。</p><h3 id="2、什么是协同式和抢占式？"><a href="#2、什么是协同式和抢占式？" class="headerlink" title="2、什么是协同式和抢占式？"></a>2、什么是协同式和抢占式？</h3><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如 Windows 3.2， Mac OS 9 等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年 Windows 95 刚刚推出的时候，抢占式多任务就被作为一大买点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等等对运行时间有保障的系统。  </p><p>另外，抢占式系统依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能。x86 系统从 80386 处理器开始引入 Ring 机制支持执行权限，这也是为何 Windows 95 和 Linux 其实只能运行在 80386 之后的 x86 处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包含资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现一个多任务的系统。我们见到的许多智能设备，如运动手环，基于硬件限制，都是采用协同调度的架构。</p><h3 id="协程基本概念"><a href="#协程基本概念" class="headerlink" title="协程基本概念"></a>协程基本概念</h3><p>“协程”（Coroutine）概念最早由 Melvin Conway 于 1958 年提出。协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。总的来说，协程为协同任务提供了一种运行时抽象，这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。</p><p>从编程角度上看，协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制，迭代器常被用来实现协程，所以大部分的语言实现的协程中都有 yield 关键字，比如 Python、PHP、Lua。但也有特殊比如 Go 就使用的是通道来通信。</p><p>有趣的是协程的历史其实要早于线程。</p><p>WIKI 的解释：</p><blockquote><p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as <strong>cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.</strong>  </p></blockquote><h3 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h3><h4 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h4><ul><li>进程是资源分配的最小单位</li><li>进程间不共享内存，每个进程拥有自己独立的内存</li><li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li><li>新开进程开销大，并且 CPU 切换进程成本也大</li><li>进程由操作系统调度</li><li>多进程方式比多线程更加稳定</li></ul><h4 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h4><ul><li>线程是程序执行流的最小单位</li><li>线程是来自于进程的，一个进程下面可以开多个线程</li><li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li><li>线程因为是在同一个进程内的，可以共享内存</li><li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li><li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li><li>某个线程发生致命错误会导致整个进程崩溃</li><li>线程间读写变量存在锁的问题处理起来相对麻烦</li></ul><h4 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h4><ul><li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li><li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li><li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li><li>协程比线程更轻量级</li></ul><p>** 不同模型下用户空间与内核空间的关系：**</p><p><img src="//www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine/a89c6e5b-facd-47a1-a26b-c8fb747e9650.jpg"></p><p>注：协程可以理解为上图中的用户级线程模型。</p><h4 id="支持协程的语言"><a href="#支持协程的语言" class="headerlink" title="支持协程的语言"></a>支持协程的语言</h4><ul><li> Simula</li><li> Modula-2</li><li> C#</li><li> Lua</li><li> Go</li><li> JavaScript(ECMA-262 6th Edition) </li><li> Python</li><li> Ruby</li><li> Erlang</li><li> PHP（PHP5.5+）</li><li> …</li></ul><h5 id="C协程"><a href="#C协程" class="headerlink" title="C协程"></a>C协程</h5><p>C 标准库里的函数 setjmp 和 longjmp 可以用来实现一种协程。</p><h5 id="Go协程"><a href="#Go协程" class="headerlink" title="Go协程"></a>Go协程</h5><p>Go 语言是原生支持语言级并发的，这个并发的最小逻辑单元就是 goroutine。goroutine 就是 Go 语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的 goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个 <strong>调度器</strong>（scheduler）来维护这些 goroutine，确保所有的 goroutine 都使用 CPU，并且是尽可能公平的使用 CPU 资源。Go 的 scheduler 比较复杂，它实现了 M:N 的模式。M:N 模式指的是多个 goroutine 在多个内核线程上跑，<a href="http://morsmachine.dk/go-scheduler">Go 的 scheduler 可参考&gt;&gt;</a>。goroutine 让 Go 低成本地具有了高并发运算能力。另外 Go 协程是通过通道（channel）来通信的。  </p><p>注意：goroutine 的实现并不完全是传统意义上的协程。在协程阻塞的时候（CPU 计算或者文件 IO 等），多个 goroutine 会变成多线程的方式执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动一个goroutine</span></span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python协程"><a href="#Python协程" class="headerlink" title="Python协程"></a>Python协程</h5><p>Python 协程基于 Generator。Python 实现的 grep 例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">             <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line">search = grep(<span class="string">&#x27;coroutine&#x27;</span>)</span><br><span class="line"><span class="built_in">next</span>(search) <span class="comment"># 启动一个协程</span></span><br><span class="line">search.send(<span class="string">&quot;send sha ne&quot;</span>)               </span><br></pre></td></tr></table></figure><h5 id="Lua协程"><a href="#Lua协程" class="headerlink" title="Lua协程"></a>Lua协程</h5><p>Lua 中的协同是一协作的多线程，每一个协同等同于一个线程，yield-resume 可以实现在线程中切换。然而与真正的多线程不同的是，协同是非抢占式的。当程序运行到 yield 的时候，使用协程将上下文环境记录住，然后将程序操作权归还到主函数，当主函数调用 resume 的时候，会重新唤起协程，读取 yield 记录的上下文。这样形成了程序语言级别的多协程操作。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(  <span class="comment">-- 创建coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>)  <span class="comment">-- 唤醒coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co))  <span class="comment">-- 查看coroutine的状态</span></span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">co(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">co2 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co2)) </span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">running</span>()) <span class="comment">-- 返回正在跑的coroutine</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">coroutine</span>.<span class="built_in">yield</span>() <span class="comment">-- 挂起coroutine</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="PHP协程"><a href="#PHP协程" class="headerlink" title="PHP协程"></a>PHP协程</h5><p>PHP 5.5 一个比较好的新功能是加入了对迭代生成器和协程的支持。PHP 协程也是基于 Generator，Generator 可以视为一种“可中断”的函数，而 yield 构成了一系列的“中断点”。PHP 协程没有 resume 关键字，而是“在使用的时候唤起”协程。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span>(<span class="params"><span class="variable">$start</span>, <span class="variable">$end</span>, <span class="variable">$step</span> = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$start</span>; <span class="variable">$i</span> &lt;= <span class="variable">$end</span>; <span class="variable">$i</span> += <span class="variable">$step</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">xrange</span>(<span class="number">1</span>, <span class="number">1000000</span>) <span class="keyword">as</span> <span class="variable">$num</span>) &#123; <span class="comment">// xrange返回的是一个Generator对象</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$num</span>, <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swoole 在 2.0 开始内置协程（Coroutine）的能力，提供了具备协程能力 IO 接口（统一在命名空间Swoole\Coroutine*）。基于 setjmp、longjmp 实现，在进行协程切换时会自动保存 Zend VM 的内存状态（主要是 EG 全局内存和 vm stack）。</p><p>由于 Swoole 是在底层封装了协程，所以对比传统的 PHP 层协程框架，开发者不需要使用 yield 关键词来标识一个协程 IO 操作，所以不再需要对 yield 的语义进行深入理解以及对每一级的调用都修改为 yield。</p><h4 id="适合使用协程的场景"><a href="#适合使用协程的场景" class="headerlink" title="适合使用协程的场景"></a>适合使用协程的场景</h4><ol><li>协程适合于 IO 密集型场景，这样能提高并发性，比如请求接口、Mysql、Redis 等的操作；</li><li>PHP 中利用协程还可以低成本处理处理大数据集合。<a href="http://www.laruence.com/2015/05/28/3038.html">参考&gt;&gt;</a>；</li><li>替代异步回调的代码风格；（协程令开发者可以无感知的用同步的代码编写方式达到异步 IO 的效果和性能，避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护。但相比普通的异步回调程序，协程写法会多增加额外的内存占用和一些 CPU 开销。 ）</li></ol><h2 id="四、协程与异步和并发的联系"><a href="#四、协程与异步和并发的联系" class="headerlink" title="四、协程与异步和并发的联系"></a>四、协程与异步和并发的联系</h2><p><a href="#">协程与异步</a>：协程并不是说替换异步，协程一样可以利用异步实现高并发。 </p><p><a href="#">协程与并发</a>：协程要利用多核优势就需要比如通过调度器来实现多协程在多线程上运行，这时也就具有了并行的特性。如果多协程运行在单线程或单进程上也就只能说具有并发特性。</p><h2 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h2><ul><li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000">协程 - 廖雪峰的官方网站</a></li><li><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">http://www.dabeaz.com/coroutines/Coroutines.pdf</a></li><li><a href="http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/">http://blog.rainy.im/2016/04/07/python-thread-and-coroutine/</a></li><li><a href="https://www.zhihu.com/question/30133749">https://www.zhihu.com/question/30133749</a> </li><li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/">http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/</a></li><li><a href="https://gocn.io/question/2">https://gocn.io/question/2</a></li><li><a href="http://morsmachine.dk/go-scheduler">http://morsmachine.dk/go-scheduler</a></li><li><a href="https://book.douban.com/annotation/28878170/">https://book.douban.com/annotation/28878170/</a></li><li><a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html">http://www.cnblogs.com/fanzhidongyzby/p/4098546.html</a></li><li><a href="http://blog.tingyun.com/web/article/detail/621">http://blog.tingyun.com/web/article/detail/621</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">http://www.ruanyifeng.com/blog/2015/04/generator.html</a></li><li><a href="http://callbackhell.com/">http://callbackhell.com/</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html">http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html</a></li></ul><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/08/process-php-basic-knowledge.html">用PHP玩转进程之一 — 基础</a> <span>（2018-08-28）</span></li><li><a href="https://www.fanhaobai.com/2018/09/process-php-multiprocess-server.html">用PHP玩转进程之二 — 多进程PHPServer</a> <span>（2018-09-02）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://wiki.phpboy.net/doku.php?id=2017-07:55-%E5%BC%82%E6%AD%A5_%E5%B9%B6%E5%8F%91_%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86.md&quot;&gt;http://wiki.phpboy.net/doku.php?id=2017-07:55-异步_并发_协程原理.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux 操作系统在设计上将虚拟空间划分为用户空间和内核空间，两者做了隔离是相互独立的，用户空间给应用程序使用，内核空间给内核使用。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/11/synchronised-asynchronized-coroutine/a89c6e5b-facd-47a1-a26b-c8fb747e9650.jpg&quot;&gt;
    
    </summary>
    
      <category term="系统原理" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="系统原理" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>分布式配置管理Qconf</title>
    <link href="https://www.fanhaobai.com/2017/11/qconf.html"/>
    <id>https://www.fanhaobai.com/2017/11/qconf.html</id>
    <published>2017-11-03T09:32:27.000Z</published>
    <updated>2024-04-18T08:38:12.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://catkang.github.io/2015/06/23/qconf.html">从配置文件到分布式配置管理QConf</a></p></blockquote><p>QConf 是奇虎 360 广泛使用的配置管理服务，现已开源 <a href="https://github.com/Qihoo360/QConf">QConf Source Code</a>，欢迎大家关注使用。本文从设计初衷，架构实现，使用情况及相关产品比较四个方面进行介绍。</p><p><img src="//www.fanhaobai.com/2017/11/qconf/d7fec4ae-e55a-11e7-80c1-9a214cf093ae.jpg"><span id="more"></span></p><h2 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h2><p>在分布式环境中，出于负载、容错等种种原因，几乎所有的服务都需要在不同的机器节点上部署多个实例。同时，业务项目中总少不了各种类型的配置文件。这种情况下，有时仅仅是一个配置内容的修改，便需要重新进行代码提交 git，打包，分发上线的流程。当部署的机器有很多时，分发上线本身也是一个很繁杂的工作。而配置文件的修改频率又远远大于代码本身。追本溯源，我们认为所有的这些麻烦是由于我们对配置和代码在管理和发布过程中不加区分造成的。配置本身源于代码，是为了提高代码的灵活性而提取出来的一些经常变化的或需要定制的内容，而正是配置的这种天生的变化特征给我们带了很大的麻烦。因此，我们开发了分布式配置管理系统 QConf，并依托 QConf 在 360 内部提供了一整套配置管理服务，QConf 致力于将配置内容从代码中完全分离出来，及时可靠高效地提供配置访问和更新服务。</p><h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>为了让大家对之后的内容有个直观的认识，先来介绍一下如果需要在自己的项目中使用 QConf 应该怎么做：</p><ul><li>首先，<strong>部署 QConf</strong>，QConf 采用 cmake 构建，依次执行如下命令。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">..</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ul><li>之后，通过 Zookeeper 客户端或 <strong>QConf 管理界面</strong> 在 Zookeeper 上建立自己的节点结构，节点完整路径作为 QConf 的 key 值，以 360 公司内部 QConf 管理界面为例：</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/8bb7c9c6-c0e9-40d5-96c8-81b40613e9bc.jpg"></p><ul><li>最后，选择所需语言版本的 QConf 库，并在需要获得配置内容的代码位置，直接调用 Qconf 客户端接口，并放心每次取得的都是最新鲜出炉的配置内容。</li></ul><p>需要说明的是，使用 QConf 后已经没有所谓的配置文件的概念，你要做的就是在需要的地方获取正确的内容，QConf 认为，这才是你真正想要的。</p><h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>了解了 QConf 的设计初衷和使用方式，相信大家已经对 QConf 有一个整体的认识并且对其实现有了大概的猜想。在介绍架构之前，还需要申明一下 QConf 对配置信息的定位，因为这个定位直接决定了其结构设计和组件选择。</p><ul><li>单条数据量小</li><li>更新频繁（较代码而言）</li><li>配置总数可能巨大，但单台机器关心配置数有限</li><li>读多写少</li></ul><p>进入主题，开始介绍 QConf 的架构实现：</p><p><img src="//www.fanhaobai.com/2017/11/qconf/d29ccf16-e559-11e7-80c1-9a214cf093ae.png"></p><p>上图展示的是 QConf 的基本结构，从角色上划分主要包括 QConf 客户端，QConf 服务端和 QConf 管理端。</p><h3 id="QConf服务端"><a href="#QConf服务端" class="headerlink" title="QConf服务端"></a>QConf服务端</h3><p>QConf 使用 ZooKeeper 集群作为服务端提供服务。众所周知，ZooKeeper 是一套分布式应用程序协调服务，根据上面提到的对配置内容的定位，我们认为可以将单条配置内容直接存储在 ZooKeeper 的一个 ZNode 上，并利用 ZooKeeper 的 Watch 监听功能实现配置变化时对客户端的及时通知。按照 ZooKeeper 的设计目标，其只提供最基础的功能，包括顺序一致，原子性，单一系统镜像，可靠性和及时性。另外 Zookeeper 还有如下特点：</p><ul><li>类文件系统的节点组织</li><li>稳定，无单点问题</li><li>订阅通知机制</li></ul><p>关于 Zookeeper，更多见 <a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><h3 id="QConf客户端"><a href="#QConf客户端" class="headerlink" title="QConf客户端"></a>QConf客户端</h3><p>但在接口方面，ZooKeeper 本身只提供了非常基本的操作，并且其客户端接口原始，所以我们需要在 QConf 的客户端部分 <strong>解决如下问题</strong>：</p><ul><li>降低与 ZooKeeper 的链接数原生的 ZooKeeper 客户端中，所有需要获取配置的进程都需要与 ZooKeeper 保持长连接，在生产环境中每个客户端机器可能都会有上百个进程需要访问数据，这对 ZooKeeper 的压力非常大而且也是不必要的。</li><li>本地缓存当然我们不希望客户端进程每次需要数据都走网络获取，所以需要维护一份客户端缓存，仅在配置变化时更新。</li><li>容错当进程退出、网络中断、机器重启等异常情况发生时，我们希望能尽可能的提供可靠的配置获取服务</li><li>多语言版本接口目前提供的语言版本包括：c，php，java，python，go，lua，shell</li><li>配置更新及时，可以秒级同步到所有客户端机器</li><li>高效的配置读取，内存级的访问速度</li></ul><p>下面来看下 QConf 客户端的架构：</p><p><img src="//www.fanhaobai.com/2017/11/qconf/1a2c6f9e-e55a-11e7-80c1-9a214cf093ae.png"></p><p>可以看到 QConf 客户端主要有：agent、各种语言接口、连接他们的消息队列和共享内存。在 QConf 中，配置以 key-value 的形式存在，业务进程给出 key 获得对应 value，这与传统的配置文件方式是一致的。</p><p>下面通过两个主要场景的数据流动来说明他们各自的功能和角色：</p><ul><li>业务进程请求数据</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/31cbf598-e55a-11e7-80c1-9a214cf093ae.png"></p><ol><li>业务进程调用某一种语言的 QConf <strong>接口</strong>，从 <strong>共享内存</strong> 中查找需要的配置信息；</li><li>如果存在，直接获取，否则会向 <strong>消息队列</strong> 中加入该配置 key；</li><li><strong>agent</strong> 从 <strong>消息队列</strong> 中感知需要获取的配置 key；</li><li><strong>agent</strong> 向 <strong>ZooKeeper</strong> 查询数据并注册监听；</li><li><strong>agent</strong> 将获得的配置 value 序列化后放入 <strong>共享内存</strong>；</li><li>业务进程从 <strong>共享内存</strong> 中获得最新值。    </li></ol><ul><li>配置信息更新</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/5aade6d8-e55a-11e7-80c1-9a214cf093ae.png"></p><ol><li><strong>ZooKeeper **通知 **agent</strong> 某配置项发生变化；</li><li>**agent **从 **ZooKeeper **查询新值并更新 watcher；</li><li>**agent **用新值更新 **共享内存 **中的该配置项。</li></ol><p>通过上面的说明，可以看出 QConf 的整体结构和流程非常简单。QConf 中各个组件或线程之间仅通过有限的中间数据结构通信，耦合性非常小，各自只负责自己的本职工作和一亩三分地，而不感知整体结构。下面通过几个点来详细介绍：</p><ul><li>无锁根据上文提到的配置信息的特征，我们认为在 QConf 客户端进行的是多进程并行读取的过程，对配置数据来说读操作远多于写操作。为了尽可能的提高读效率，整个 QConf 客户端在操作共享内存时采用的是无锁的操作，同时为了保证数据的正确，采取了如下两个措施：</li><li>单点写，将写操作集中到单一线程，其他线程通过中间数据结构与之通信，写操作排队，用这种方法牺牲掉一些写效率。在 QConf 客户端，需要对共享内存进行写操作的场景有：    </li></ul><ol><li>用户进程通过消息队列发送的需获取 key；</li><li>ZooKeeper 配置修改删除等触发 Watcher 通知，需更新；</li><li>为了消除 watcher 丢失造成的不一致，需要定时对共享内存中的所有配置重新注册 watcher，此时可能会需要更新；</li><li>发生 agent 重启、网络中断、ZooKeeper 会话过期等异常情况之后，需重新拉数据，此时可能需要更新。</li></ol><ul><li>读验证，无锁的读写方式，会存在读到未写入完全数据的危险，但考虑到在绝对的读多写少环境中这种情况发生的概率较低，所以我们允许其发生，通过读操作时的验证来发现。共享内存数据在序列化时会带其 md5 值，业务进程从共享内存中读取时，利用预存的 md5 值验证是否正确读取。</li><li>异常处理 QConf 中采取了一些处理来应对不可避免的异常情况</li><li>采用父子进程 keepalive 的方式，应对 agent 进程异常退出的情况；</li><li>维护一份落盘数据，应对断网情况下共享内存又被清空的状况；</li><li>网络中断恢复后，对共享内存中所有数据进行检查，并重新注册 watcher；</li><li>定时扫描共享内存；</li><li>数据序列化 QConf 客户端中有多处需要将数据序列化通信或存储，包括共享内存，消息队列，落盘数据中的内容。采取如下协议：</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/b809d666-e55a-11e7-80c1-9a214cf093ae.jpg"></p><ul><li>agent 任务通过上面的描述，大家应该大概了解了 agent 所做的一些事情，下面从 agent 的内部的线程分工的角度整理一下，如下图：</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/d7fec4ae-e55a-11e7-80c1-9a214cf093ae.jpg"></p><ul><li>Send 线程：ZooKeeper 线程，处理网络数据包，进行协议包的解析与封装，并将 Zookeeper 的事件加入 WaitingEvent 队列等待处理；</li><li>Event 线程：ZooKeeper 线程，依次获取 WaitingEvent 队列中的事件，并进行相应处理，这里我们关注节点删除、节点值修改、子节点变化、会话过期等事件。对特定的事件会进行相应的操作，以节点值修改为例，agent 会按上边提到的方式序列化该节点 key，并将其加入到 WaitingWriting 队列，等待 Main 线程处理；</li><li>Msq 线程：之前讲数据流动场景的时候有提到，用户进程从共享内存中找不到对应配置后，会向消息队列中加入该配置，Msq 线程便是负责从消息队列中获取业务进程的取配置需求，并同样通过 WaitingWriting 队列发送给 Main 进程；</li><li>Scan 线程：扫描共享内存中的所有配置，发现与 Zookeeper 不一致的情况时，将key值加入 WaitingWriting 队列。Scan 线程会在 ZooKeeper 重连或轮询期到达时进行上述操作；</li><li>Main 线程：共享内存的唯一写入线程，从 Zookeeper 获得数据写入共享内存，维护共享内存中的内容；</li><li>Trigger 线程：该线程负责一些周边逻辑的调用，包括：    </li></ul><ol><li>dump 操作：将共享内存的内容同步一份到本地，QConf 采用的 gdbm；</li><li>feedback 操作：QConf 支持更新反馈的功能，可向用户指定 web 服务以一定的格式发送反馈；</li><li>script 操作：在某些情况下，业务希望当配置变化时，做一些自定义的操作，QConf 支持配置变化时调用用户脚本，agent 按一种固定的约定在配置发生变化时调用对应的脚本。</li></ol><h3 id="QConf管理端"><a href="#QConf管理端" class="headerlink" title="QConf管理端"></a>QConf管理端</h3><p>管理端是业务修改配置的页面入口，利用数据库提供一些如批量导入，权限管理，版本控制等上层功能。由于公司内的一些业务耦合和需求定制，当前开源的 QConf 管理端这边提供了一个简易的页面，和一套下层的 c++ 接口，如下图：</p><p><img src="//www.fanhaobai.com/2017/11/qconf/0cc54ae6-e55b-11e7-80c1-9a214cf093ae.jpg"></p><p>之后计划进一步完善以及跟社区合作提供更友好的界面。</p><p>QConf 的结构及实现大概就介绍到这，接下来…</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>QConf 除了存储配置的基本功能外，还在公司内提供了一套简单的服务发现功能，该功能允许业务在 QConf 上配置一组服务，QConf 会监控其服务的存活。当业务进程调用获取服务的接口时，会根据用户需求，返回全部可用服务，或某一可用服务。不同于普通配置：</p><ul><li>结构上多一个 Monitor 的角色，来监控所有服务的存活, 如下图：</li></ul><p><img src="//www.fanhaobai.com/2017/11/qconf/2d146c96-e55b-11e7-80c1-9a214cf093ae.png"></p><ul><li>提供对应的客户端接口，get_host 获取某一可用服务，get_allhost 获取所有可用服务</li><li>管理端页面对应的展示方式及操作，尤其是对指定服务的添加删除，上线下线</li></ul><p>需要明确的是，目前 Monitor 事实上仅仅是通过查看服务端口的存活来判断的，在实际生产环境中，该功能多与实际服务提供者的监控结合，由服务提供者的监控调用 QConf 的相应接口实现服务的上下线。</p><h2 id="使用方式及使用场景"><a href="#使用方式及使用场景" class="headerlink" title="使用方式及使用场景"></a>使用方式及使用场景</h2><p>目前 360 内部已经广泛的使用 QConf。覆盖云盘、大流程、系统部、dba、图搜、影视、地图、硬件、手机卫士、广告、好搜等大部分业务。部署国内外共 51 几个机房，客户端机器超两万台，稳定运行两年。</p><p>使用的方式主要包括：</p><ul><li>简单配置公司内使用最广泛的用法，QConf 非常适合经常需要变动的配置使用，如开关信息、版本信息、推荐信息、超时时间等。</li><li>服务方式这种方式多被服务提供者采用，如 dba，系统部等，采用上述的服务配置的方式，通过 QConf 向公司的所有业务提供存储，计算及 web 服务。</li></ul><p>QConf 因为其对配置信息的定位，使得整个结构非常简单，容易部署和使用。在 Github 可以找到完整代码，<a href="https://github.com/Qihoo360/QConf">QConf Source Code</a> 欢迎关注。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="http://www.cnblogs.com/zhangxh20/p/5464103.html">配置管理服务横向对比 </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://catkang.github.io/2015/06/23/qconf.html&quot;&gt;从配置文件到分布式配置管理QConf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QConf 是奇虎 360 广泛使用的配置管理服务，现已开源 &lt;a href=&quot;https://github.com/Qihoo360/QConf&quot;&gt;QConf Source Code&lt;/a&gt;，欢迎大家关注使用。本文从设计初衷，架构实现，使用情况及相关产品比较四个方面进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/11/qconf/d7fec4ae-e55a-11e7-80c1-9a214cf093ae.jpg&quot;&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://www.fanhaobai.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://www.fanhaobai.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Supervisor管理进程</title>
    <link href="https://www.fanhaobai.com/2017/09/supervisor.html"/>
    <id>https://www.fanhaobai.com/2017/09/supervisor.html</id>
    <published>2017-09-23T09:56:57.000Z</published>
    <updated>2024-04-18T08:38:12.672Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://supervisord.org/">Supervisor</a> 是一款使用 Python 开发的非常优秀的进程管理工具。它可以在类 UNIX 系统上让用户精确地监视与控制多组指定数量的服务进程。当监控的服务进程意外退出时，会尝试自动重启这些服务，以保持服务可用状态。</p><p><img src="//www.fanhaobai.com/2017/09/supervisor/d42decd3-2342-4e8f-a34f-48b47fc6e557.png"><span id="more"></span></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor <a href="http://www.supervisord.org/installing.html">官方</a> 提供的安装方式较多，这里采用 pip 方式安装。</p><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install python-pip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级pip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install --upgrade pip</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip -V</span></span><br><span class="line">pip 9.0.1</span><br></pre></td></tr></table></figure><h3 id="安装Supervisor"><a href="#安装Supervisor" class="headerlink" title="安装Supervisor"></a>安装Supervisor</h3><p>通过 pip 安装 Supervisor：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install supervisor</span></span><br><span class="line">Successfully installed supervisor-3.3.3</span><br></pre></td></tr></table></figure><p>安装 Supervisor 后，会出现 supervisorctl 和 supervisord 两个程序，其中 supervisorctl 为服务监控终端，而 supervisord 才是所有监控服务的大脑。查看 supervisord 是否安装成功：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">supervisord -v</span></span><br><span class="line">3.3.3</span><br></pre></td></tr></table></figure><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p>将 supervisord 配置成开机启动服务，下载官方 <a href="https://github.com/Supervisor/initscripts/blob/master/redhat-init-mingalevme">init 脚本</a>。</p><p>修改关键路径配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PIDFILE=/var/run/supervisord.pid</span><br><span class="line">LOCKFILE=/var/lock/subsys/supervisord</span><br><span class="line">OPTIONS=&quot;-c /etc/supervisord.conf&quot;</span><br></pre></td></tr></table></figure><p>移到该文件到<code>/etc/init.d</code>目录下，并重命名为 supervisor，添加可执行权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 777 /etc/init.d/supervisor</span></span><br></pre></td></tr></table></figure><p>配置成开机启动服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --add supervisor</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig supervisor on</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chkconfig --list | grep <span class="string">&quot;supervisor&quot;</span></span></span><br><span class="line">supervisor  0:off 1:off 2:on 3:on 4:on 5:on 6:off</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><p>Supervisord 安装后，需要使用如下命令生成配置文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /etc/supervisor</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span></span><br></pre></td></tr></table></figure><h3 id="主配置部分"><a href="#主配置部分" class="headerlink" title="主配置部分"></a>主配置部分</h3><p><code>supervisord.conf</code>的主配置部分说明：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   <span class="comment">; socket文件的路径</span></span><br><span class="line"><span class="comment">;chmod=0700                 ; socket文件权限</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup       ; socket文件用户和用户组</span></span><br><span class="line"><span class="comment">;username=user              ; 连接时认证的用户名</span></span><br><span class="line"><span class="comment">;password=123               ; 连接时认证的密码</span></span><br><span class="line"></span><br><span class="line"><span class="section">[inet_http_server]</span>          <span class="comment">; 监听TCP</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span>         <span class="comment">; 监听ip和端口</span></span><br><span class="line"><span class="attr">username</span>=user               <span class="comment">; 连接时认证的用户名</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>                <span class="comment">; 连接时认证的密码</span></span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/var/log/supervisord.log <span class="comment">; log目录</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">; log文件最大空间</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">; log文件保持的数量</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">; log级别</span></span><br><span class="line"><span class="attr">pidfile</span>=/var/run/supervisord.pid</span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">; 是否非守护进程态运行</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  <span class="comment">; 系统空闲的最少文件描述符</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 <span class="comment">; 可用的最小进程描述符</span></span><br><span class="line"><span class="comment">;umask=022                   ; 进程创建文件的掩码</span></span><br><span class="line"><span class="comment">;identifier=supervisor       ; supervisord标识符</span></span><br><span class="line"><span class="comment">;directory=/tmp              ; 启动前切换到的目录</span></span><br><span class="line"><span class="comment">;nocleanup=true              ; 启动前是否清除子进程的日志文件</span></span><br><span class="line"><span class="comment">;childlogdir=/tmp            ; AUTO模式，子进程日志路径</span></span><br><span class="line"><span class="comment">;environment=KEY=&quot;value&quot;     ; 设置环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span>    <span class="comment">; XML_RPC配置</span></span><br><span class="line"><span class="attr">supervisor.rpcinterface_factory</span> = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock <span class="comment">; 连接的socket路径</span></span><br><span class="line"><span class="comment">;username=chris               ; 用户名</span></span><br><span class="line"><span class="comment">;password=123                 ; 密码</span></span><br><span class="line"><span class="attr">prompt</span>=mysupervisor           <span class="comment">; 输入用户名和密码时的提示符</span></span><br><span class="line"><span class="comment">;history_file=~/.sc_history   ; 历史操作记录存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span>                     <span class="comment">; 包含文件，将每个进程配置为一个文件并包含</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/*.ini <span class="comment">; 多个进程的配置文件</span></span><br></pre></td></tr></table></figure><p>这部分我们不需要做太多的配置修改，如果需要开启 WEB 终端监控，则需要配置并开启 inet_http_server 项。</p><h3 id="进程配置部分"><a href="#进程配置部分" class="headerlink" title="进程配置部分"></a>进程配置部分</h3><p>Supervisor 需管理的进程服务配置，示例如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:work]</span>                      <span class="comment">; 服务名，例如work</span></span><br><span class="line"><span class="attr">command</span>=php -r <span class="string">&quot;sleep(10);exit(1);&quot;</span> <span class="comment">; 带有参数的可执行命令</span></span><br><span class="line"><span class="attr">process_name</span>=%(process_num)s        <span class="comment">; 进程名，当numprocs&gt;1时，需包含%(process_num)s</span></span><br><span class="line"><span class="attr">numprocs</span>=<span class="number">2</span>                          <span class="comment">; 启动进程的数目数</span></span><br><span class="line"><span class="comment">;directory=/tmp                     ; 运行前切换到该目录</span></span><br><span class="line"><span class="comment">;umask=022                          ; 进程掩码</span></span><br><span class="line"><span class="comment">;priority=999                       ; 子进程启动关闭优先级</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span>                      <span class="comment">; 子进程是否被自动启动</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">1</span>                         <span class="comment">; 成功启动几秒后则认为成功启动</span></span><br><span class="line"><span class="comment">;startretries=3                     ; 子进程启动失败后，最大尝试启动的次数</span></span><br><span class="line"><span class="attr">autorestart</span>=unexpected            <span class="comment">; 子进程意外退出后自动重启的选项，false, unexpected, true。unexpected表示不在exitcodes列表时重启</span></span><br><span class="line"><span class="attr">exitcodes</span>=<span class="number">0</span>,<span class="number">2</span>                     <span class="comment">; 期待的子程序退出码</span></span><br><span class="line"><span class="comment">;stopsignal=QUIT                  ; 进程停止信号，可以为TERM,HUP,INT,QUIT,KILL,USR1,or USR2等信号，默认为TERM</span></span><br><span class="line"><span class="comment">;stopwaitsecs=10                  ; 发送停止信号后等待的最大时间</span></span><br><span class="line"><span class="comment">;stopasgroup=false                ; 是否向子进程组发送停止信号</span></span><br><span class="line"><span class="comment">;killasgroup=false                ; 是否向子进程组发送kill信号</span></span><br><span class="line"><span class="comment">;redirect_stderr=true             ; 是否重定向日志到标准输出</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/logs/work.log <span class="comment">; 进程的stdout的日志路径</span></span><br><span class="line"><span class="comment">;stdout_logfile_maxbytes=1MB      ; 日志文件最大大小</span></span><br><span class="line"><span class="comment">;stdout_logfile_backups=10</span></span><br><span class="line"><span class="comment">;stdout_capture_maxbytes=1MB</span></span><br><span class="line"><span class="comment">;stderr_logfile=/a/path           ; stderr的日志路径</span></span><br><span class="line"><span class="comment">;stderr_logfile_maxbytes=1MB</span></span><br><span class="line"><span class="comment">;stderr_logfile_backups=10</span></span><br><span class="line"><span class="comment">;stderr_capture_maxbytes=1MB</span></span><br><span class="line"><span class="comment">;environment=A=&quot;1&quot;,B=&quot;2&quot;          ; 子进程的环境变量</span></span><br><span class="line"><span class="comment">;serverurl=AUTO                   ; 子进程的环境变量SUPERVISOR_SERVER_URL </span></span><br></pre></td></tr></table></figure><blockquote><p>通常将每个进程的配置信息配置成独立文件，并通过 include 模块包含，这样方便修改和管理配置文件。</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>配置完成后，启动 supervisord 守护服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">supervisord -c /etc/supervisor/supervisord.conf</span></span><br></pre></td></tr></table></figure><p>常用的命令参数说明：</p><ul><li>-c：指定配置文件路径</li><li>-n：是否非守护态运行</li><li>-l：日志文件目录</li><li>-i：唯一标识</li></ul><p>查看 supervisord 启动情况：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep <span class="string">&quot;supervisor&quot;</span></span></span><br><span class="line">root  24901  1  0 Sep23 ? 00:00:30 /usr/bin/python /usr/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -tunpl</span></span><br><span class="line">tcp 0 0 127.0.0.1:9001  0.0.0.0:*  LISTEN  24901/python</span><br></pre></td></tr></table></figure><h2 id="监控进程"><a href="#监控进程" class="headerlink" title="监控进程"></a>监控进程</h2><p>Supervisor 提供了多种监控服务的方式，包括 supervisorctl 命令行终端、Web 端、XML_RPC 接口多种方式。</p><h3 id="命令终端"><a href="#命令终端" class="headerlink" title="命令终端"></a>命令终端</h3><p>直接使用 supervisorctl 即可在命令行终端查看所有服务的情况，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">supervisorctl</span> </span><br><span class="line">work:0      RUNNING   pid 31313, uptime 0:00:07</span><br><span class="line">work:1      RUNNING   pid 31318, uptime 0:00:06</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u 用户名 -p 密码</span></span><br></pre></td></tr></table></figure><p>supervisorctl 常用命令列表如下；</p><ul><li><a href="#">status</a>：查看服务状态</li><li><a href="#">update</a>：重新加载配置文件</li><li><a href="#">restart</a>：重新启动服务</li><li><a href="#">stop</a>：停止服务</li><li><a href="#">pid</a>：查看某服务的 pid</li><li><a href="#">tail</a>：输出最新的 log 信息</li><li><a href="#">shutdown</a>：关闭 supervisord 服务</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>在配置中开启 inet_http_server 后，即可通过 Web 界面便捷地监控进程服务了。</p><p><img src="//www.fanhaobai.com/2017/09/supervisor/9d28cc24-a0d8-11e7-abc4-cec278b6b50a.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot;&gt;Supervisor&lt;/a&gt; 是一款使用 Python 开发的非常优秀的进程管理工具。它可以在类 UNIX 系统上让用户精确地监视与控制多组指定数量的服务进程。当监控的服务进程意外退出时，会尝试自动重启这些服务，以保持服务可用状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/09/supervisor/d42decd3-2342-4e8f-a34f-48b47fc6e557.png&quot;&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.fanhaobai.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.fanhaobai.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Lua在Nginx的应用</title>
    <link href="https://www.fanhaobai.com/2017/09/lua-in-nginx.html"/>
    <id>https://www.fanhaobai.com/2017/09/lua-in-nginx.html</id>
    <published>2017-09-09T13:25:59.000Z</published>
    <updated>2024-04-18T08:38:12.671Z</updated>
    
    <content type="html"><![CDATA[<p>当 Nginx 标准模块和配置不能灵活地适应系统要求时，就可以考虑使用 Lua 扩展和定制 Nginx 服务。<a href="http://openresty.org/en/">OpenResty</a> 集成了大量精良的 Lua 库、第三方模块，可以方便地搭建能够处理超高并发、扩展性极高的 Web 服务，所以这里选择 OpenResty 提供的 <a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> 方案。</p><p><img src="//www.fanhaobai.com/2017/09/lua-in-nginx/63113174-45d7-4a27-8472-d037675c2cbd.jpg"><span id="more"></span></p><h2 id="安装Lua环境"><a href="#安装Lua环境" class="headerlink" title="安装Lua环境"></a>安装Lua环境</h2><p>lua-nginx-module 依赖于 LuaJIT 和 ngx_devel_kit。LuaJIT 需要安装，ngx_devel_kit 只需下载源码包，在 Nginx 编译时指定 ngx_devel_kit 目录。</p><h3 id="系统依赖库"><a href="#系统依赖库" class="headerlink" title="系统依赖库"></a>系统依赖库</h3><p>首先确保系统已安装如下依赖库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install readline-devel pcre-devel openssl-devel gcc</span></span><br></pre></td></tr></table></figure><h3 id="安装LuaJIT"><a href="#安装LuaJIT" class="headerlink" title="安装LuaJIT"></a>安装LuaJIT</h3><p>首先，安装 <a href="http://luajit.org/index.html">LuaJIT</a> 环境，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf LuaJIT-2.0.5.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> LuaJIT-2.0.5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装成功</span></span><br><span class="line">==== Successfully installed LuaJIT 2.0.5 to /usr/local ====</span><br></pre></td></tr></table></figure><p>设置 LuaJIT 有关的环境变量。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> LUAJIT_LIB=/usr/local/lib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> LUAJIT_INC=/usr/local/include/luajit-2.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/lib&quot;</span> &gt; /etc/ld.so.conf.d/usr_local_lib.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldconfig</span></span><br></pre></td></tr></table></figure><h3 id="下载相关模块"><a href="#下载相关模块" class="headerlink" title="下载相关模块"></a>下载相关模块</h3><p>下载 <a href="https://github.com/simpl/ngx_devel_kit/tags">ngx_devel_kit</a> 源码包，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf v0.3.0.tar.gz</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩后目录名</span></span><br><span class="line">ngx_devel_kit-0.3.0</span><br></pre></td></tr></table></figure><p><strong>接下来</strong>，下载 Lua 模块  <a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> 源码包，为 Nginx 编译作准备。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://github.com/openresty/lua-nginx-module/archive/v0.10.10.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf v0.10.10.tar.gz</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩后目录名</span></span><br><span class="line">lua-nginx-module-0.10.10</span><br></pre></td></tr></table></figure><h3 id="加载Lua模块"><a href="#加载Lua模块" class="headerlink" title="加载Lua模块"></a>加载Lua模块</h3><p>Nginx 1.9 版本后可以动态加载模块，但这里由于版本太低只能重新编译安装 Nginx。下载 Nginx 源码包并解压：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget http://nginx.org/download/nginx-1.13.5.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf nginx-1.13.5.tar.gz</span></span><br></pre></td></tr></table></figure><p>编译并重新安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> nginx-1.13.5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加--add-module=/usr/src/lua-nginx-module-0.10.10 --add-module=/usr/src/ngx_devel_kit-0.3.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module --with-pcre --add-module=/usr/src/lua-nginx-module-0.10.10 --add-module=/usr/src/ngx_devel_kit-0.3.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否安装成功</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nginx -v</span></span><br></pre></td></tr></table></figure><h3 id="配置Nginx环境"><a href="#配置Nginx环境" class="headerlink" title="配置Nginx环境"></a>配置Nginx环境</h3><p>现在只需配置 Nginx，即可嵌入 Lua 脚本。首先，在 http 部分配置 Lua 模块和第三方库路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第三方库（cjson）地址luajit-2.0/lib</span><br><span class="line">lua_package_path &#x27;/home/www/lua/?.lua;;&#x27;;</span><br><span class="line">lua_package_cpath &#x27;/usr/local/include/luajit-2.0/lib/?.so;;&#x27;;</span><br></pre></td></tr></table></figure><p>接着，配置一个 Lua 脚本服务：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello world测试</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> /lua_content &#123;</span><br><span class="line">        <span class="comment"># 定义MIME类型</span></span><br><span class="line">        <span class="attribute">default_type</span> <span class="string">&#x27;text/plain&#x27;</span>;</span><br><span class="line">        <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">            ngx.say(&#x27;Hello,world!&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试安装和配置是否正常：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service nginx <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service nginx reload</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问地址/lua_content输出</span></span><br><span class="line">Hello,world!</span><br></pre></td></tr></table></figure><h2 id="Lua调用Nginx"><a href="#Lua调用Nginx" class="headerlink" title="Lua调用Nginx"></a>Lua调用Nginx</h2><p>lua-nginx-module 模块中已经为 Lua 提供了丰富的 Nginx 调用 API，每个 API 都有各自的作用环境，详细描述见 <a href="https://github.com/openresty/lua-nginx-module#nginx-api-for-lua">Nginx API for Lua</a>。这里只列举基本 API 的使用 。</p><p>先配一个 Lua 脚本服务，配置文件如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /lua_api</span> &#123;  </span><br><span class="line">    <span class="comment"># 示例用的Nginx变量  </span></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$name</span> <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;  </span><br><span class="line">    <span class="comment"># 通过Lua文件进行内容处理</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> /home/www/nginx-api.lua;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxvarvariable">ngx.var</a></li></ul><p>可以通过<code>ngx.var.var_name</code>形式获取或设置 Nginx 变量值，例如 request_uri、host、request 等。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ngx.say打印内容</span></span><br><span class="line">ngx.say(ngx.var.request_uri)</span><br><span class="line">ngx.var.name = <span class="string">&#x27;www.fanhaobai.com&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_headers">ngx.req.get_headers()</a></li></ul><p>该方法会以表的形式返回当前请求的头信息。查看请求的头信息：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;Host : &#x27;</span>, ngx.req.get_headers().host, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_headers()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;,&quot;</span>), <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">&quot; : &quot;</span>, v, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当然，通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_header">ngx.req.set_header()</a> 也可以设置头信息。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.req.set_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args">ngx.req.get_uri_args()</a></li></ul><p>该方法以表形式返回当前请求的所有 GET 参数。查看请求 query 为<code>?name=fhb</code>的 GET 参数：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;name : &#x27;</span>, ngx.req.get_uri_args().name, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_uri_args()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;,&quot;</span>), <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">&quot; : &quot;</span>, v, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>同样，可以通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_uri_args">ngx.req.set_uri_args()</a> 设置请求的所有 GET 参数。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123;name=<span class="string">&#x27;fhb&#x27;</span>&#125;) <span class="comment">--&#123;name=&#x27;fhb&#x27;&#125;可以为query形式name=fhb</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_post_args">get_post_args()</a></li></ul><p>该方法以表形式返回当前请求的所有 POST 参数，POST 数据必须是 application/x-www-form-urlencoded 类型。查看请求<code>curl --data &#39;name=fhb&#39; localhost/lua_api</code>的 POST 参数：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--必须先读取body体</span></span><br><span class="line">ngx.req.read_body()</span><br><span class="line">ngx.say(<span class="string">&#x27;name : &#x27;</span>, ngx.req.get_post_args().name, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_post_args()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">&quot; : &quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">&quot;,&quot;</span>), <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">&quot; : &quot;</span>, v, <span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqget_body_data">ngx.req.get_body_data()</a> 方法可以获取未解析的请求 body 体内容字符串。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_method">ngx.req.get_method()</a></li></ul><p>获取请求的大写字母形式的请求方式，通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_method">ngx.req.set_method()</a> 可以设置请求方式。例如：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(ngx.req.get_method())</span><br></pre></td></tr></table></figure><h3 id="响应部分"><a href="#响应部分" class="headerlink" title="响应部分"></a>响应部分</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxheaderheader">ngx.header</a></li></ul><p>通过<code>ngx.header.header_name</code>的形式获取或设置响应头信息。如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(ngx.header.content_type)</span><br><span class="line">ngx.header.content_type = <span class="string">&#x27;text/plain&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#print">ngx.print()</a></li></ul><p>ngx.print() 方法会填充指定内容到响应 body 中。如下所示：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.<span class="built_in">print</span>(ngx.header.content_type)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxsay">ngx.say()</a></li></ul><p>如上述使用，ngx.say() 方法同 ngx.print() 方法，只是会在后追加一个换行符。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxexit">ngx.exit()</a></li></ul><p>以某个状态码返回响应内容，状态码常量对应关系见 <a href="https://github.com/openresty/lua-nginx-module#http-status-constants">HTTP status constants</a> 部分，也支持数字形式的状态码。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxredirect">ngx.redirect()</a></li></ul><p>重定向当前请求到新的 url，响应状态码可选列表为 301、302（默认）、303、307。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.redirect(<span class="string">&#x27;http://www.fanhaobai.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxrematch">ngx.re.match</a></li></ul><p>该方法提供了正则表达式匹配方法。请求<code>?name=fhb&amp;age=24</code>匹配 GET 参数中的数字：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> m, err = ngx.re.<span class="built_in">match</span>(ngx.req.set_uri_args, <span class="string">&quot;[0-9]+&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">then</span></span><br><span class="line">    ngx.say(m[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ngx.say(<span class="string">&quot;match not found&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxlog">ngx.log()</a></li></ul><p>通过该方法可以将内容写入 Nginx 日志文件，日志文件级别需同 log 级别一致。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxmd5">ngx.md5()</a> | <a href="https://github.com/openresty/lua-nginx-module#ngxencode_base64">ngx.encode_base64()</a> | ngx.decode_base64()</li></ul><p>它们都是字符串编码方式。ngx.md5() 可以对字符串进行 md5 加密处理，而 ngx.encode_base64() 是对字符串 base64 编码， ngx.decode_base64() 为 base64 解码。</p><h2 id="Nginx中嵌入Lua"><a href="#Nginx中嵌入Lua" class="headerlink" title="Nginx中嵌入Lua"></a>Nginx中嵌入Lua</h2><p>上面讲述了怎么在 Lua 中调用 Nginx 的 API 来扩展或定制 Nginx 的功能，那么编写好的 Lua 脚本怎么在 Nginx 中得到执行呢？其实，Nginx 是通过模块指令形式在其 11 个处理阶段做插入式处理，指令覆盖 http、server、server if、location、location if 这几个范围。</p><h3 id="模块指令列表"><a href="#模块指令列表" class="headerlink" title="模块指令列表"></a>模块指令列表</h3><p>这里只列举基本的 Lua 模块指令，更多信息参考 <a href="https://www.nginx.com/resources/wiki/modules/lua/#directives">Directives</a> 部分。</p><table><thead><tr><th>指令</th><th>所在阶段</th><th>使用范围</th><th>说明</th></tr></thead><tbody><tr><td>init_by_lua<br>init_by_lua_file</td><td>加载配置文件</td><td>http</td><td>可以用于初始化全局配置</td></tr><tr><td>set_by_lua<br>set_by_lua_file</td><td>rewrite</td><td>server<br>location<br>location if</td><td>复杂逻辑的变量赋值，注意是阻塞的</td></tr><tr><td>rewrite_by_lua<br>rewrite_by_lua_file</td><td>rewrite</td><td>http<br>server<br>location<br>location if</td><td>实现复杂逻辑的转发或重定向</td></tr><tr><td>content_by_lua<br>content_by_lua_file</td><td>content</td><td>location<br>location if</td><td>处理请求并输出响应</td></tr><tr><td>header_filter_by_lua<br>header_filter_by_lua_file</td><td>响应头信息过滤</td><td>http<br>server<br>location<br>location if</td><td>设置响应头信息</td></tr><tr><td>body_filter_by_lua<br>body_filter_by_lua_file</td><td>输出过滤</td><td>http<br>server<br>location<br>location if</td><td>对输出进行过滤或修改</td></tr></tbody></table><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>注意到，每个指令都会有<code>*_lua</code>和<code>*_lua_file</code>两个指令，<code>*_lua</code>指令后为 Lua 代码块，而<code>*_lua_file</code>指令后为 Lua 脚本文件路径。下面将只对<code>*_lua</code>指令进行说明。</p><ul><li>init_by_lua</li></ul><p>该指令会在 Nginx 的 Master 进程加载配置时执行，所以可以完成 Lua 模块初始化工作，Worker 进程同样会继承这些。</p><p><code>nginx.conf</code>配置文件中的 http 部分添加如下代码：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">-- 所有worker共享的全局变量</span><br><span class="line"><span class="attribute">lua_shared_dict</span> shared_data <span class="number">1m</span>;  </span><br><span class="line"><span class="attribute">init_by_lua_file</span> /usr/example/lua/init.lua;</span><br></pre></td></tr></table></figure><p><code>init.lua</code>初始化脚本为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&#x27;cjson&#x27;</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&#x27;resty.redis&#x27;</span></span><br><span class="line"><span class="keyword">local</span> shared_data = ngx.shared.shared_data</span><br></pre></td></tr></table></figure><ul><li>set_by_lua</li></ul><p>我们直接使用 set 指令很难实现很复杂的变量赋值逻辑，而 set_by_lua 模块指令就可以解决这个问题。</p><p><code>nginx.conf</code>配置文件 location 部分内容为：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /lua &#123;</span><br><span class="line">    <span class="attribute">set_by_lua_file</span> <span class="variable">$num</span> /home/www/set.lua;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set.lua</code>脚本内容为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> i = uri_args.a <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> j = uri_args.b <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> i + j</span><br></pre></td></tr></table></figure><p>上述赋值逻辑，请求 query 为<code>?a=10&amp;b=2</code>时响应内容为 12。</p><ul><li>rewrite_by_lua</li></ul><p>可以实现内部 URL 重写或者外部重定向。<code>nginx.conf</code>配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /lua &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">rewrite_by_lua_file</span> /home/www/rewrite.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rewrite.lua</code>脚本内容：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ngx.req.get_uri_args()[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;app&quot;</span> <span class="keyword">then</span></span><br><span class="line">    ngx.req.set_uri(<span class="string">&quot;/m_h5&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>access_by_lua</li></ul><p>用于访问权限控制。例如，只允许带有身份标识用户访问，<code>nginx.conf</code>配置为：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /lua &#123;  </span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">access_by_lua_file</span> /home/www/access.lua;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>access.lua</code>脚本内容为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ngx.req.get_uri_args()[<span class="string">&quot;token&quot;</span>] == <span class="string">&quot;fanhb&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>content_by_lua</li></ul><p>该指令在 <a href="#Lua%E8%B0%83%E7%94%A8Nginx">Lua 调用 Nginx</a> 部分已经使用过了，用于输出响应内容。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>使用 Lua 模块对本站的 ES 服务做受信操作控制，即非受信 IP 只能查询操作。<code>nginx.conf</code>配置如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    set $allowed <span class="string">&#x27;115.171.226.212&#x27;</span>;</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">if</span> ngx.re.<span class="built_in">match</span>(ngx.req.get_method(), <span class="string">&quot;PUT|POST|DELETE&quot;</span>) <span class="keyword">and</span> <span class="keyword">not</span> ngx.re.<span class="built_in">match</span>(ngx.var.request_uri, <span class="string">&quot;_search&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    start, _ = <span class="built_in">string</span>.<span class="built_in">find</span>(ngx.var.allowed, ngx.var.remote_addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start <span class="keyword">then</span></span><br><span class="line">ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h3><p>在 Nginx 配置文件的 location 部分配置 Lua 脚本基本参数，并配置 Lua 模块指令：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line"><span class="attribute">set</span> rate_per <span class="number">300</span></span><br><span class="line">access_by_lua_file /home/www/access.lua;</span><br></pre></td></tr></table></figure><p>Lua 脚本实现频率控制逻辑，使用 Redis 对单位时间内的访问次数做缓存，key 为访问 uri 拼接 token 后的 md5 值。具体内容如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ngx.var.rate_per) <span class="keyword">or</span> <span class="number">200</span></span><br><span class="line"><span class="keyword">local</span> expire_time = <span class="built_in">tonumber</span>(ngx.var.rate_expire) <span class="keyword">or</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;rate.limit:string:&quot;</span></span><br><span class="line"></span><br><span class="line">red:set_timeout(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">&quot;www.fanhaobai.com&quot;</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to connect redis: &quot;</span> .. err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">key = key .. ngx.md5(ngx.var.request_uri .. (ngx.req.get_uri_args()[<span class="string">&#x27;token&#x27;</span>] <span class="keyword">or</span> ngx.req.get_post_args()[<span class="string">&#x27;token&#x27;</span>]))</span><br><span class="line"><span class="keyword">local</span> times, err = red:incr(key)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> times <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to exec incr: &quot;</span> .. err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">elseif</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    ok, err = red:expire(key, expire_time)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;failed to exec expire: &quot;</span> .. err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/09/lua.html">进入Lua的世界</a> <span>（2017-09-03）</span></li><li><a href="https://www.fanhaobai.com/2017/09/lua-in-redis.html">Lua在Redis的应用</a> <span>（2017-09-04）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当 Nginx 标准模块和配置不能灵活地适应系统要求时，就可以考虑使用 Lua 扩展和定制 Nginx 服务。&lt;a href=&quot;http://openresty.org/en/&quot;&gt;OpenResty&lt;/a&gt; 集成了大量精良的 Lua 库、第三方模块，可以方便地搭建能够处理超高并发、扩展性极高的 Web 服务，所以这里选择 OpenResty 提供的 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot;&gt;lua-nginx-module&lt;/a&gt; 方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/09/lua-in-nginx/63113174-45d7-4a27-8472-d037675c2cbd.jpg&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Nginx" scheme="https://www.fanhaobai.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="https://www.fanhaobai.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua在Redis的应用</title>
    <link href="https://www.fanhaobai.com/2017/09/lua-in-redis.html"/>
    <id>https://www.fanhaobai.com/2017/09/lua-in-redis.html</id>
    <published>2017-09-04T13:50:19.000Z</published>
    <updated>2024-04-18T08:38:12.671Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 从 2.6 版本起，也已开始支持 <a href="https://redis.io/commands/eval">Lua 脚本</a>，我们可以更加得心应手地使用或扩展 Redis，特别是在高并发场景下 Lua 脚本提供了更高效、可靠的解决方案。</p><p><img src="//www.fanhaobai.com/2017/09/lua-in-redis/3916d13312c22d84d29d3860b59544a9.png"><span id="more"></span></p><h2 id="为什么要使用Lua"><a href="#为什么要使用Lua" class="headerlink" title="为什么要使用Lua"></a>为什么要使用Lua</h2><p>我们先看一个抢购场景下 <a href="#">商品库存</a> 的问题，用 PHP 可简单实现为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$key</span> = <span class="string">&#x27;number:string&#x27;</span>;</span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$number</span> = <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$number</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">decr</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$number</span>--;</span><br></pre></td></tr></table></figure><p>这段代码其实存在问题，高并发时会出现库存超卖的情况，因为上述操作在 Redis 中不是原子操作，会导致库存逻辑的判断失效。尽管可以通过优化代码来解决问题，比如使用 <a href="#">Decr</a> 原子操作命令、或者使用 <a href="#">锁</a> 的方式，但这里使用 Lua 脚本来解决。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">&#x27;number:string&#x27;</span></span><br><span class="line"><span class="keyword">local</span> number = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;GET&quot;</span>, key))</span><br><span class="line"><span class="keyword">if</span> number &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&quot;DECR&quot;</span>, key)</span><br><span class="line"><span class="keyword">return</span> number<span class="comment">--</span></span><br></pre></td></tr></table></figure><p>这段脚本代码虽然是 Lua 语言编写（ <a href="https://www.fanhaobai.com/2017/09/lua.html">进入Lua的世界</a>），但是其实就是 PHP 版本的翻译版。那为什么这样，Lua 脚本就能解决库存问题了呢？</p><p>Redis 中嵌入 Lua 脚本，所具有的几个特性为：</p><ul><li><a href="#">原子操作</a>：Redis 将整个 Lua 脚本作为一个原子执行，无需考虑并发，无需使用事务来保证数据一致性；</li><li><a href="#">高性能</a>：嵌入 Lua 脚本后，可以减少多个命令执行的网络开销，进而间接提高 Redis 性能；</li><li><a href="#">可复用</a>：Lua 脚本会保存于 Redis 中，客户端都可以使用这些脚本；</li></ul><h2 id="在Redis中嵌入Lua"><a href="#在Redis中嵌入Lua" class="headerlink" title="在Redis中嵌入Lua"></a>在Redis中嵌入Lua</h2><p><img src="//www.fanhaobai.com/2017/09/lua-in-redis/3916d13312c22d84d29d3860b59544a9.png"></p><h3 id="使用Lua解析器"><a href="#使用Lua解析器" class="headerlink" title="使用Lua解析器"></a>使用Lua解析器</h3><p>Redis 提供了 EVAL（直接执行脚本） 和 EVALSHA（执行 SHA1 值的脚本） 这两个命令，可以使用内置的 Lua 解析器执行 Lua 脚本。语法格式为：</p><ul><li><a href="#">EVAL</a>  script  numkeys  key [key …]  arg [arg …] </li><li><a href="#">EVALSHA</a>  sha1  numkeys  key [key …]  arg [arg …] </li></ul><p>参数说明：</p><ul><li>script / sha1：EVAL 命令的第一个参数为需要执行的 Lua 脚本字符，EVALSHA 命令的一个参数为 Lua 脚本的 <a href="https://redis.io/commands/eval#bandwidth-and-evalsha">SHA1 值</a></li><li>numkeys：表示 key 的个数</li><li>key [key …]：从第三个参数开始算起，表示在脚本中所用到的那些 Redis 键（key），这些键名参数可以在 Lua 中通过全局数组 KYES[i] 访问</li><li>arg [arg …]：附加参数，在 Lua 中通过全局数组 ARGV[i] 访问</li></ul><p>EVAL 命令的使用示例：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; EVAL <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure><p>每次使用 EVAL 命令都会传递需执行的 Lua 脚本内容，这样增加了宽带的浪费。Redis 内部会永久保存被运行在脚本缓存中，所以使用 EVALSHA（建议使用） 命令就可以根据脚本 SHA1 值执行对应的 Lua 脚本。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hello&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;1b936e3fe509bcbc9cd0664897bbe8fd0cac101b&quot;</span></span><br><span class="line">&gt; EVALSHA <span class="number">1</span>b936e3fe509bcbc9cd0664897bbe8fd0cac101b <span class="number">0</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>Redis 中执行 Lua 脚本都是以原子方式执行，所以是原子操作。另外，redis-cli 命令行客户端支持直接使用<code>--eval lua_file</code>参数执行 Lua 脚本。</p></blockquote><p>Redis 中有关脚本的命令除了 EVAL 和 EVALSHA 外，<a href="#">其他常用命令</a> 如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SCRIPT EXISTS script [script …]</td><td>查看脚本是是否保存在缓存中</td></tr><tr><td>SCRIPT FLUSH</td><td>从缓存中移除所有脚本</td></tr><tr><td>SCRIPT KILL</td><td>杀死当前运行的脚本</td></tr><tr><td>SCRIPT LOAD script</td><td>将脚本添加到缓存中,不立即执行<br>返回脚本SHA1值</td></tr></tbody></table><h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>由于 Redis 和 Lua 都有各自定义的数据类型，所以在使用执行完 Lua 脚本后，会存在一个数据类型转换的过程。</p><p>Lua 到 Redis 类型转换与 Redis 到 Lua 类型转换相同部分关系：</p><table><thead><tr><th><a href="https://www.fanhaobai.com/2017/09/lua.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Lua 类型</a></th><th><a href="http://www.redis.cn/topics/protocol.html">Redis 返回类型</a></th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>integer</td><td>浮点数会转换为整数<br>3.333–&gt;3</td></tr><tr><td>string</td><td>bulk</td><td></td></tr><tr><td>table（array）</td><td>multi bulk</td><td></td></tr><tr><td>boolean false</td><td>nil</td><td></td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; EVAL <span class="string">&quot;return 3.333&quot;</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; EVAL <span class="string">&quot;return &#x27;fhb&#x27;&quot;</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;fhb&quot;</span></span><br><span class="line">&gt; EVAL <span class="string">&quot;return &#123;&#x27;fhb&#x27;, &#x27;lw&#x27;, &#x27;lbf&#x27;&#125;&quot;</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;fhb&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lw&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lbf&quot;</span></span><br><span class="line">&gt; EVAL <span class="string">&quot;return false&quot;</span> <span class="number">0</span></span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，从 Lua 转化为 Redis 类型比 Redis 转化为 Lua 类型多了一条 <a href="#">额外</a> 规则：</p><table><thead><tr><th>Lua 类型</th><th>Redis 返回类型</th><th>说明</th></tr></thead><tbody><tr><td>boolean true</td><td>integer</td><td>返回整型 1</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; EVAL <span class="string">&quot;return true&quot;</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总而言之，<a href="#">类型转换的原则</a> 是将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><h3 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h3><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> f(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>执行<code>redis-cli --eval function.lua</code>命令，会抛出尝试定义全局变量的错误：</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">(error) ERR Error running script (<span class="keyword">call</span> to f_0a602c93c4a2064f8dc648c402aa27d68b69514f): @enable_strict_lua:<span class="number">8</span>: user_script:<span class="number">1</span>: Script attempted to create global variable &#x27;f&#x27;</span><br></pre></td></tr></table></figure><h2 id="Lua脚本调用Redis命令"><a href="#Lua脚本调用Redis命令" class="headerlink" title="Lua脚本调用Redis命令"></a>Lua脚本调用Redis命令</h2><p>Redis 创建了用于与 Lua 环境协作的组件—— 伪客户端，它负责执行 Lua 脚本中的 Redis 命令。</p><p><img src="//www.fanhaobai.com/2017/09/lua-in-redis/ae7223b50754e37b7cd89cfe24fc13dd.png"></p><h3 id="调用Redis命令"><a href="#调用Redis命令" class="headerlink" title="调用Redis命令"></a>调用Redis命令</h3><p>在 Redis 内置的 Lua 解析器中，调用 redis.call() 和 redis.pcall() 函数执行 Redis 的命令。它们除了处理错误的行为不一样外，其他行为都保持一致。调用 格式：</p><ul><li>redis.call(command, [key …], arg [arg …] )</li><li>redis.pcall(command, [key …], arg [arg …] )</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; EVAL <span class="string">&quot;return redis.call(&#x27;SET&#x27;, &#x27;name&#x27;, &#x27;fhb&#x27;)&quot;</span> <span class="number">0</span></span><br><span class="line">&gt; EVAL <span class="string">&quot;return redis.pcall(&#x27;GET&#x27;, &#x27;name&#x27;)&quot;</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;fhb&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Redis日志"><a href="#Redis日志" class="headerlink" title="Redis日志"></a>Redis日志</h3><p>在 Lua 脚本中，可以通过调用 redis.log()  函数来写 Redis 日志。格式为：</p><p>redis.log(loglevel, message)</p><p>loglevel 参数可以是 redis.LOG_DEBUG、redis.LOG_VERBOSE、redis.LOG_NOTICE、redis.LOG_WARNING 的任意值。</p><p>查看<code>redis.conf</code>日志配置信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">logleval必须一致才会记录</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/home/logs/redis.log&quot;</span><br></pre></td></tr></table></figure><p>Lua 写 Redis 日志示例：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; EVAL <span class="string">&quot;redis.log(redis.LOG_NOTICE, &#x27;I am fhb&#x27;)&quot;</span> <span class="number">0</span></span><br><span class="line"><span class="number">113</span>:M <span class="number">04</span> Sep <span class="number">13</span>:<span class="number">12</span>:<span class="number">36.229</span> * I am fhb</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="API-访问速率控制"><a href="#API-访问速率控制" class="headerlink" title="API 访问速率控制"></a>API 访问速率控制</h3><p>通过 Lua 实现一个针对用户的 API 访问速率控制，Lua 代码如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;rate.limit:string:&quot;</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">&quot;INCR&quot;</span>, key)</span><br><span class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;EXPIRE&quot;</span>, key, expire_time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> times &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>KEYS[1] 可以用 API 的 URI + 用户 uid 组成，ARGV[1] 为单位时间限制访问的次数，ARGV[2] 为限制的单位时间。</p><h3 id="批量HGETTALL"><a href="#批量HGETTALL" class="headerlink" title="批量HGETTALL"></a>批量HGETTALL</h3><p>这个例子演示通过 Lua 实现批量 HGETALL，当然也可以使用 <a href="https://www.fanhaobai.com/2017/08/redis-pipelining.html">管道</a> 实现。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- KEYS为uid数组</span></span><br><span class="line"><span class="keyword">local</span> users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,uid <span class="keyword">in</span> <span class="built_in">ipairs</span>(KEYS) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> user = redis.call(<span class="string">&#x27;hgetall&#x27;</span>, uid)</span><br><span class="line">    <span class="keyword">if</span> user ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(users, i, user)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> users</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然使用 Lua 脚本给我们带来了许多便利，但是需要注意几个使用事项：</p><ul><li>Lua 脚本在执行时是阻塞的，不应该在 Lua 脚本中有耗时的处理逻辑；</li><li>在集群模式时，Lua 脚本必须使用参数 key 传递需操作的 Redis 的 key，且要求所操作的 key 都在同一个 slot 节点上，可以使用以<code>&#123;&#125;</code>标记的 hash tag 方式解决。</li></ul><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/09/lua.html">进入Lua的世界</a> <span>（2017-09-03）</span></li><li><a href="https://www.fanhaobai.com/2017/09/lua-in-nginx.html">Lua在Nginx的应用</a> <span>（2017-09-09）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 从 2.6 版本起，也已开始支持 &lt;a href=&quot;https://redis.io/commands/eval&quot;&gt;Lua 脚本&lt;/a&gt;，我们可以更加得心应手地使用或扩展 Redis，特别是在高并发场景下 Lua 脚本提供了更高效、可靠的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/09/lua-in-redis/3916d13312c22d84d29d3860b59544a9.png&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="https://www.fanhaobai.com/tags/Lua/"/>
    
      <category term="Redis" scheme="https://www.fanhaobai.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>进入Lua的世界</title>
    <link href="https://www.fanhaobai.com/2017/09/lua.html"/>
    <id>https://www.fanhaobai.com/2017/09/lua.html</id>
    <published>2017-09-03T14:49:22.000Z</published>
    <updated>2024-04-18T08:38:12.672Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 是一个扩展式程序设计语言，作为一个强大、轻量的脚本语言，可以嵌入任何需要的程序中使用。Lua 被设计成一种动态类型语言，且它的语法相对较简单，这里只介绍其基本语法和使用方法，更多信息见 <a href="http://cloudwu.github.io/lua53doc/manual.html">Lua 5.3 参考手册</a>。</p><p><img src="//www.fanhaobai.com/2017/09/lua/c391629e-be21-4038-ab25-b47fe368daeb.jpg"><span id="more"></span></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Lua 作为通用型脚本语言，有 8 种基本数据类型：</p><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>nil</td><td>只有一种值 nil<br>标识和别的任何值的差异</td><td>nil</td></tr><tr><td>boolean</td><td>两种值 false 和 true</td><td>false</td></tr><tr><td>number</td><td>实数（双精度浮点数）</td><td>520</td></tr><tr><td>string</td><td>字符串，不区分单双引号</td><td>“fhb”<br>‘fhb’</td></tr><tr><td>function</td><td>函数</td><td>function haha() <br>   return 1<br>end</td></tr><tr><td>userdata</td><td>将任意 C 数据保存在 Lua 变量</td><td></td></tr><tr><td>thread</td><td>区别独立的执行线程<br>用来实现协程</td><td></td></tr><tr><td>table</td><td>表，实现了一个关联数组<br>唯一一种数据结构</td><td>{1, 2, 3}</td></tr></tbody></table><p>使用库函数 <a href="https://www.codingnow.com/2000/download/lua_manual.html#pdf-type">type()</a> 可以返回一个变量或标量的类型。有关数据类型需要说明的是：</p><ul><li><strong>nil</strong> 和 <strong>false</strong> 都能导致条件为假，而另外所有的值都被当作真</li><li>在 number 和 string 类型参与比较或者运算时，会存在隐式类型转化，当然也可以显示转化（tonumber()）</li><li>由于 table、 function、thread、userdata 的值是所谓的对象，变量本身只是一个对对象的引用，所以赋值、参数传递、函数返回，都是对这些对象的引用传递</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Lua 中有三类变量：全局变量、局部变量、还有 table 的域。<a href="#">任何变量除非显式的以 local 修饰词定义为局部变量，否则都被定义为全局变量</a>，局部变量作用范围为函数或者代码块内。说明，在变量的首次赋值之前，变量的值均为 nil。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 行注释</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">块注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">globalVar = <span class="string">&#x27;is global&#x27;</span></span><br><span class="line"><span class="comment">-- if代码块</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">local</span> localVar = <span class="string">&#x27;is local&#x27;</span></span><br><span class="line">   <span class="built_in">print</span>(localVar)    <span class="comment">-- 可以访问局部变量</span></span><br><span class="line">   <span class="built_in">print</span>(globalVar)   <span class="comment">-- 可以访问全局变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(localVar)       <span class="comment">-- 不能访问局部变量</span></span><br><span class="line"><span class="built_in">print</span>(globalVar)      <span class="comment">-- 可以访问全局变量</span></span><br></pre></td></tr></table></figure><h2 id="标识符约定"><a href="#标识符约定" class="headerlink" title="标识符约定"></a>标识符约定</h2><p>Lua 中用到的名字（标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串，同大多数语言保持一致。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面这些是保留的关键字，不能用作名字：</p><p><img src="//www.fanhaobai.com/2017/09/lua/fe33e61ca081f36909b9f2d16b5c9d4b.png"></p><p>大部分的流程控制关键字将在 <a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a> 部分说明。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><img src="//www.fanhaobai.com/2017/09/lua/84414e900ee77fc8fd1baf9fc9c7a7d7.png"></p><p>大部分运算操作符将在 <a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>  部分进行说明。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Lua 的一个执行单元叫做 chunk（语句组），一个语句组就是一串语句段，而 block（语句块）是一列语句段。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> block <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面将介绍 Lua 的主要流程控制语句。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Lua 中同样是用 if 语句作为条件流程控制语句，else if 或者 else 子句可以省略。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- exp为条件表达式，block为条件语句</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>控制结构中的条件表达式可以返回任何值。 false 和 nil 都被认为是假，所有其它值都被认为是真。另外 Lua 中并没有提供 switch 子句，我们除了使用冗长的 if 子句外，怎么实现其他语言中的 <a href="#">switch</a> 功能呢？</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 利用表实现</span></span><br><span class="line"><span class="keyword">local</span> switch = &#123;</span><br><span class="line">   [<span class="number">1</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>    <span class="comment">-- 索引对应的域为匿名函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Case 1.&quot;</span></span><br><span class="line">   <span class="keyword">end</span>,</span><br><span class="line">   [<span class="number">2</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Case 2.&quot;</span></span><br><span class="line">   <span class="keyword">end</span>,</span><br><span class="line">   [<span class="number">3</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Case 3.&quot;</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">exp</span> = <span class="number">4</span>         <span class="comment">-- exp为条件表达式</span></span><br><span class="line"><span class="keyword">local</span> func = switch[<span class="built_in">exp</span>]</span><br><span class="line"><span class="comment">-- 实现switch-default功能</span></span><br><span class="line"><span class="keyword">if</span> (func) <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> func()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Case default.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Lua 支持 for、while、repeat 这三种循环子句。</p><p><a href="#">while</a> 子句结构定义为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结束条件为：循环条件==false</span></span><br><span class="line"><span class="keyword">while</span> 循环条件 <span class="keyword">do</span></span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p><a href="#">for</a> 子句结构定义为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- 结束条件为：变量&lt;=循环结束值  </span></span><br><span class="line"><span class="keyword">for</span> 变量=初值, 循环结束值, 步长 <span class="keyword">do</span></span><br><span class="line">   代码块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>另外，for 结合 in 关键字可以遍历 table 类型的数据，如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> names = &#123;<span class="string">&#x27;fhb&#x27;</span>, <span class="string">&#x27;lw&#x27;</span>, <span class="string">&#x27;lbf&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">local</span> name;</span><br><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(names) <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      name = value</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p><a href="#">repeat</a> 子句只有循环条件为 true 时，才退出循环。跟通常使用习惯相反，因此使用较少。其结构定义为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 结束条件为：循环条件==true</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   代码块</span><br><span class="line"><span class="keyword">until</span> 循环条件</span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">until</span> i &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h3 id="语句的退出"><a href="#语句的退出" class="headerlink" title="语句的退出"></a>语句的退出</h3><p>return 和 break 关键字都可以用来退出语句组，但 return 关键字可以用来退出函数和代码块，包括循环语句，而 break 关键字只能退出循环语句。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>在 Lua 中由多个操作符和操作数组成一个表达式。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>Lua 允许多重赋值。 因此，赋值的语法定义是等号左边是一系列变量， 而等号右边是一系列的表达式。 两边的元素都用逗号间。如果右值比需要的更多，多余的值就被忽略，如果右值的数量不够， 将会被扩展若干个 nil。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 变量简单赋值</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="comment">-- 交换x和y的值</span></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>Lua 支持常见的数学运算操作符，见下表：</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>+<br>-</td><td>加减运算</td><td>10 - 5</td></tr><tr><td>*<br>/</td><td>乘除运算</td><td>10 * 5</td></tr><tr><td>%</td><td>取模运算</td><td>10 % 5</td></tr><tr><td>^</td><td>求幂运算</td><td>4^(-0.5)</td></tr><tr><td>-</td><td>取负运算</td><td>-0.5</td></tr></tbody></table><p>需要指出的是，string 类型进行数学运算操作时，会隐式转化为 number 类型。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&#x27;12&#x27;</span> / <span class="number">6</span>    <span class="comment">-- 返回2</span></span><br></pre></td></tr></table></figure><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>Lua 中的比较操作符有见下表：</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>==</td><td>等于，为严格判断</td><td>“1” == 1 结果为 false</td></tr><tr><td>~=</td><td>不等于<br>等价于==操作的反值</td><td>“1”~=1 结果为 true</td></tr><tr><td>&lt;<br>&lt;=</td><td>小于或小于等于</td><td>1&lt;=2</td></tr><tr><td>&gt;<br>&gt;=</td><td>大于或大于等于</td><td>2&gt;=1</td></tr></tbody></table><p>比较运算的结果一定是 boolean 类型。<a href="#">如果操作数都是数字，那么就直接做数字比较，如果操作数都是字符串，就用字符串比较的方式进行，否则，无法进行比较运算</a>。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>Lua 中的逻辑操作符有 and、or 以及 not，一样把 false 和 nil 都作为假， 而其它值都当作真。</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>and</td><td>与</td><td>10 and 20</td></tr><tr><td>or</td><td>或</td><td>10 or 20</td></tr><tr><td>not</td><td>取非</td><td>not false</td></tr></tbody></table><p>取反操作 not 总是返回 false 或 true 中的一个。 and 和 or 都遵循短路规则，也就是说 and 操作符在第一个操作数为 false 或 nil 时，返回这第一个操作数， 否则，and 返回第二个参数； or 操作符在第一个操作数不为 nil 和 false 时，返回这第一个操作数，否则返回第二个操作数。 </p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>           <span class="comment">--&gt; 20</span></span><br><span class="line"><span class="literal">nil</span> <span class="keyword">and</span> <span class="number">10</span>          <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">or</span> <span class="number">20</span>            <span class="comment">--&gt; 10</span></span><br><span class="line"><span class="literal">nil</span> <span class="keyword">or</span> <span class="string">&quot;a&quot;</span>          <span class="comment">--&gt; &quot;a&quot;</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">false</span>           <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h3><p>Lua 中还有两种特别的操作符，分别为字符串连接操作符（..）和取长度操作符（#）。</p><p>特别说明： </p><ul><li>如果字符串连接操作符的操作数存在 number 类型，则会隐式转化为 string 类型</li><li>取长度操作符获取字符串的长度是它的字节数，table 的长度被定义成一个整数下标 n</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> .. <span class="number">2</span>           <span class="comment">--&gt; &#x27;12&#x27;</span></span><br><span class="line">#<span class="string">&#x27;123&#x27;</span>             <span class="comment">--&gt; 3</span></span><br><span class="line">#&#123;<span class="number">1</span>, <span class="number">2</span>&#125;            <span class="comment">--&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h3><p>Lua 中操作符的优先级见下表，从低到高优先级顺序： </p><p><img src="//www.fanhaobai.com/2017/09/lua/fc34646b-5eaf-45ba-b89a-0d8fc3f1b71d.png"></p><p>运算符优先级通常是这样，但是可以用括号来改变运算次序。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 Lua 中，函数是和字符串、数值和表并列的基本数据结构， 属于第一类对象( first-class-object)，可以和数值等其他类型一样赋给变量以及作为参数传递，同样可以作为返回值接收（闭包）。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数在 Lua 中定义也很简单，基本结构为：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- arg为参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">(arg)</span></span></span><br><span class="line">　　body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 阶乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="keyword">return</span> fact(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以用 local 关键字来修饰函数，表示局部函数。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 Lua 中有一个概念，函数与所有类型值一样都是匿名的，即它们都没有名称。当讨论一个函数名时，实际上是在讨论一个持有某函数的变量：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span> <span class="keyword">return</span> -x <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 上述写法只是一种语法糖，是下述代码的简写形式</span></span><br><span class="line">f = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span> <span class="keyword">return</span> -x <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Lua 中函数实参有两种传递方式，但大部分情况会进行值传递。</p><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>当实参值为非 table 类型时，会采用值传递。几个传参规则如下：</p><ul><li>若实参个数大于形参个数，从左向右，多余的实参被忽略</li><li>若实参个数小于形参个数，从左向右，没有被初始化的形参被初始化为 nil</li><li>支持边长参数，用<code>...</code>表示</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, b)</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">(a, ...)</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用参数情况</span></span><br><span class="line">f(<span class="number">3</span>)             a=<span class="number">3</span>, b=<span class="literal">nil</span></span><br><span class="line">f(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)       a=<span class="number">3</span>, b=<span class="number">4</span></span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)       a=<span class="number">3</span>, ...  <span class="comment">--&gt; 4 5</span></span><br></pre></td></tr></table></figure><p>当函数为变长参数时，函数内使用<code>...</code>来获取变长参数，Lua 5.0 后<code>...</code>替换为名 arg 的隐含局部变量。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">   <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;...&#125;) <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(k, v)</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>) </span><br></pre></td></tr></table></figure><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>当实参为 table 类型时，传递的只是实参的引用而已。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(arg)</span></span></span><br><span class="line">   <span class="built_in">arg</span>[<span class="number">3</span>] = <span class="string">&#x27;new&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">f(a)</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">3</span>]        <span class="comment">--&gt; &quot;new&quot;</span></span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>Lua 函数允许返回多个值，中间用逗号隔开。函数返回值接收规则：</p><ul><li>若返回值个数大于接收变量的个数，多余的返回值会被忽略</li><li>若返回值个数小于参数个数，从左向右，没有被返回值初始化的变量会被初始化为 nil</li></ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&quot;a&quot;</span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x, y = f1()         <span class="comment">--&gt; x=&quot;a&quot;, y=nil</span></span><br><span class="line">x = f2()            <span class="comment">--&gt; x=&quot;a&quot;, &quot;b&quot;被丢弃</span></span><br><span class="line"><span class="comment">-- table构造式可以接受函数所有返回值</span></span><br><span class="line"><span class="keyword">local</span> tab = &#123;f2()&#125;  <span class="comment">--&gt; t=&#123;&quot;a&quot;, &quot;b&quot;&#125;</span></span><br><span class="line"><span class="comment">-- ()会迫使函数返回一个结果</span></span><br><span class="line">printf((f2()))      <span class="comment">--&gt; &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>Lua 中除了我们自定义函数外，已经实现了部分功能函数，见 <a href="http://cloudwu.github.io/lua53doc/manual.html#6">标准函数库</a>。</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>Lua 中最特别的数据类型就是表（table），可以用来实现数组、Hash、对象，全局变量也使用表来管理。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- array</span></span><br><span class="line"><span class="keyword">local</span> array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>], #array)          <span class="comment">--&gt; 1, 3</span></span><br><span class="line"><span class="comment">-- hash</span></span><br><span class="line"><span class="keyword">local</span> hash = &#123; a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(hash.a, hash[<span class="string">&#x27;b&#x27;</span>], #hash)  <span class="comment">--&gt; 1, 2, 0</span></span><br><span class="line"><span class="comment">-- array和hash</span></span><br><span class="line"><span class="keyword">local</span> tab = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">tab[<span class="string">&#x27;x&#x27;</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&#x27;hash&#x27;</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> &#123;tab.x, #tab&#125;             <span class="comment">--&gt; 2, 3</span></span><br></pre></td></tr></table></figure><p>说明：当表表示数组时，索引从 1 开始。</p><h3 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h3><p>元表（metatable）中的键名称为事件，值称为元方法，它用来定义原始值在特定操作下的行为。可通过 <a href="#">getmetatable()</a> 来获取任一事件的元方法，同样可以通过 <a href="#">setmetatable()</a> 覆盖任一事件的元方法。Lua 支持的表事件：</p><table><thead><tr><th>元方法</th><th>事件</th></tr></thead><tbody><tr><td>__add(table, value)<br>__sub(table, value)</td><td>+ 和 - 操作</td></tr><tr><td>__mul(table, value)<br>__div(table, value)</td><td>* 和 / 操作</td></tr><tr><td>__mod(table, value)<br>__pow(table, value)</td><td>% 和 ^ 操作</td></tr><tr><td>__concat(table, value)</td><td>.. 操作</td></tr><tr><td>__len(table)</td><td># 操作</td></tr><tr><td>__eq(table, value)<br>__lt(table, value)<br>__le(table, value)</td><td>== 、&lt;、&lt;= 操作</td></tr><tr><td>__index(table, index)<br>__newindex(table, index)</td><td>取和赋值下标操作</td></tr><tr><td>__call(table, …)</td><td>调用一个值</td></tr><tr><td>__tostring(table)</td><td>调用 tostring() 时</td></tr></tbody></table><p>覆盖这些元方法，即可实现重载运算符操作。例如重载 tostring 事件：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> hash = &#123; x = <span class="number">2</span>, y = <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">local</span> operator = &#123;</span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123; &quot;</span> .. <span class="built_in">self</span>.x .. <span class="string">&quot;, &quot;</span> .. <span class="built_in">self</span>.y .. <span class="string">&quot; &#125;&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(hash, operator)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(hash))             <span class="comment">--&gt; &quot;&#123; 2, 3 &#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lua 是面向过程语言，使得可以简单易学。轻量级的特性，使得以脚本方式轻易地嵌入别的程序中，例如 <a href="https://pecl.php.net/package/lua">PHP</a>、JAVA、<a href="https://redis.io/commands/eval">Redis</a>、Nginx 等语言或应用。当然，Lua 也可以通过表实现面向对象编程。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/09/lua-in-redis.html">Lua在Redis的应用</a> <span>（2017-09-04）</span></li><li><a href="https://www.fanhaobai.com/2017/09/lua-in-nginx.html">Lua在Nginx的应用</a> <span>（2017-09-09）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua 是一个扩展式程序设计语言，作为一个强大、轻量的脚本语言，可以嵌入任何需要的程序中使用。Lua 被设计成一种动态类型语言，且它的语法相对较简单，这里只介绍其基本语法和使用方法，更多信息见 &lt;a href=&quot;http://cloudwu.github.io/lua53doc/manual.html&quot;&gt;Lua 5.3 参考手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/09/lua/c391629e-be21-4038-ab25-b47fe368daeb.jpg&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="https://www.fanhaobai.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>使用Redis管道提升性能</title>
    <link href="https://www.fanhaobai.com/2017/08/redis-pipelining.html"/>
    <id>https://www.fanhaobai.com/2017/08/redis-pipelining.html</id>
    <published>2017-08-31T06:10:35.000Z</published>
    <updated>2024-04-18T08:38:12.670Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的 <a href="https://redis.io/topics/pipelining">管道</a> （pipelining）是用来打包多条无关命令批量执行，以减少多个命令分别执行带来的网络交互时间。在一些批量操作数据的场景，使用管道可以显著提升 Redis 的读写性能。</p><p><img src="http://www.fanhaobai.com/2017/08/redis-pipelining/abc8ae13-9f76-4cd0-902d-a4fbb9fedd4f.png" alt="预览图"><span id="more"></span></p><h2 id="原理演示"><a href="#原理演示" class="headerlink" title="原理演示"></a>原理演示</h2><p>Redis 的管道实质就是命令打包批量执行，多次网络交互减少到单次。使用管道和不使用管道时的交互过程如下：</p><p><img src="http://www.fanhaobai.com/2017/08/redis-pipelining/abc8ae13-9f76-4cd0-902d-a4fbb9fedd4f.png" alt="原理图"></p><p>我们使用 nc 命令来直观感受下 Redis 管道的使用过程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nc命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install nc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nc打包多个命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">printf</span> <span class="string">&quot;PING\r\nPING\r\nPING\r\n&quot;</span>) | nc localhost 6379</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">响应</span></span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure><p>因此，只要通过管道进行命令打包后，Redis 就可以批量返回命令的执行结果了。</p><h2 id="管道的应用"><a href="#管道的应用" class="headerlink" title="管道的应用"></a>管道的应用</h2><p>首先，构造示例需要的 Hash 用户数据：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$keyPrex</span> = <span class="string">&#x27;user:hash:u:&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span>&lt;=<span class="number">10000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">hMset</span>(<span class="variable">$keyPrex</span>.<span class="variable">$i</span>, [</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>   =&gt; <span class="title function_ invoke__">name</span>(),       //<span class="title function_ invoke__">name</span>()函数生成随机姓名</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>    =&gt; <span class="title function_ invoke__">rand</span>(<span class="number">21</span>, <span class="number">30</span>),</span><br><span class="line">        <span class="string">&#x27;sex&#x27;</span>    =&gt; <span class="title function_ invoke__">rand</span>(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="string">&#x27;is_new&#x27;</span> =&gt; <span class="title function_ invoke__">rand</span>(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，查看导入 Redis 中的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys user:hash:u:*</span><br><span class="line"> 9997) &quot;user:hash:u:3013&quot;</span><br><span class="line"> 9998) &quot;user:hash:u:8971&quot;</span><br><span class="line"> 9999) &quot;user:hash:u:4761&quot;</span><br><span class="line">10000) &quot;user:hash:u:1828&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:hash:u:1828</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;ggrg&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;23&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;0&quot;</span><br><span class="line">7) &quot;is_new&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在某个社交活动中，通过一系列筛选逻辑后取得种子用户 uid，然后用这些 uid 去 Hash 获取用户的信息。这种情况下你会怎么来处理呢？</p><h3 id="不使用管道"><a href="#不使用管道" class="headerlink" title="不使用管道"></a>不使用管道</h3><p>一般情况下，在数据量较小时，我们会直接使用 HGETALL 命令遍历地获取用户数据。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$start</span> = <span class="title function_ invoke__">nowTime</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">range</span>(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">as</span> <span class="variable">$id</span>) &#123;</span><br><span class="line">    <span class="variable">$user</span>[] = <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">hgetAll</span>(<span class="variable">$keyPrex</span>.<span class="variable">$id</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;时间：&#x27;</span>, <span class="title function_ invoke__">nowTime</span>() - <span class="variable">$start</span>, <span class="string">&#x27;ms&#x27;</span>, PHP_EOL;</span><br><span class="line"></span><br><span class="line">时间：<span class="number">39</span>ms</span><br></pre></td></tr></table></figure><p>执行所用时间：<a href="#">39ms</a></p><h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><p>因为通过 uid 批量获取用户数据，各个命令并没有依赖关系，所以可以使用 Redis 的管道来优化查询。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$start</span> = <span class="title function_ invoke__">nowTime</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">multi</span>(<span class="title class_">Redis</span>::<span class="variable constant_">PIPELINE</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">range</span>(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">as</span> <span class="variable">$id</span>) &#123;</span><br><span class="line">    <span class="comment">//返回资源id相同的socket资源，并未执行命令</span></span><br><span class="line">    <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">hgetAll</span>(<span class="variable">$keyPrex</span>.<span class="variable">$id</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">exec</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;时间：&#x27;</span>, <span class="title function_ invoke__">nowTime</span>() - <span class="variable">$start</span>, <span class="string">&#x27;ms&#x27;</span>, PHP_EOL;</span><br><span class="line"></span><br><span class="line">时间：<span class="number">6</span>ms</span><br></pre></td></tr></table></figure><p>使用管道后，执行时间显著地减少为：<a href="#">6ms</a>。使用 tcpdump 抓取打包后的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:45:03.029049 IP localhost.58176 &gt; localhost.6379: Flags [P.], seq 2255478840:2255479211, ack 3144685411, win 342, options [nop,nop,TS val 17640474 ecr 17640474], length 371</span><br><span class="line">E..../@.@.o..........@...o.8.p.c...V.......</span><br><span class="line">,.*2</span><br><span class="line">$7</span><br><span class="line">HGETALL</span><br><span class="line">$13</span><br><span class="line">user:hash:u:1</span><br><span class="line">*2</span><br><span class="line">$7</span><br><span class="line">HGETALL</span><br><span class="line">$13</span><br><span class="line">user:hash:u:2</span><br><span class="line">*2</span><br><span class="line">$7</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在批量操作（查询和写入）数据时，我们应尽量避免多次跟 Redis 的网络交互。这时，可以使用管道实现，也可以 Redis 内嵌 Lua 脚本实现。<strong>需要注意的是</strong>：</p><ul><li><a href="#">管道只适用于无因果关联的多命令操作</a>，否则就需要借助 Lua 脚本实现批量操作；</li><li>在实际应用中，Redis 往往不可能是单机部署，如果想要在集群中使用管道，可以部署为一主多从架构，此时所有节点的数据都一致，随机选取节点使用管道即可；</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在批量获取数据时，尽管使用 Redis 的管道性能会显著提升，但是使用管道时 Redis 会缓存之前命令的结果，最后一并输出给终端，因此所打包的命令不宜太多，否则内存使用会很严重。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 的 &lt;a href=&quot;https://redis.io/topics/pipelining&quot;&gt;管道&lt;/a&gt; （pipelining）是用来打包多条无关命令批量执行，以减少多个命令分别执行带来的网络交互时间。在一些批量操作数据的场景，使用管道可以显著提升 Redis 的读写性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.fanhaobai.com/2017/08/redis-pipelining/abc8ae13-9f76-4cd0-902d-a4fbb9fedd4f.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="DB" scheme="https://www.fanhaobai.com/categories/DB/"/>
    
      <category term="Redis" scheme="https://www.fanhaobai.com/categories/DB/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.fanhaobai.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch检索 — 聚合和LBS</title>
    <link href="https://www.fanhaobai.com/2017/08/elasticsearch-advanced-search.html"/>
    <id>https://www.fanhaobai.com/2017/08/elasticsearch-advanced-search.html</id>
    <published>2017-08-21T14:42:43.000Z</published>
    <updated>2024-04-18T08:38:12.668Z</updated>
    
    <content type="html"><![CDATA[<p>文章 <a href="https://www.fanhaobai.com/2017/08/elasticsearch-search.html">Elasticsearch检索实战</a> 已经讲述了 Elasticsearch 基本检索使用，已满足大部分检索场景，但是某些特定项目中会使用到 <a href="#">聚合</a> 和 <a href="#">LBS</a> 这类高级检索，以满足检索需求。这里将讲述 Elasticsearch 的聚合和 LBS 检索使用方法。</p><p><img src="//www.fanhaobai.com/2017/08/elasticsearch-advanced-search/d758139c-86ce-4472-89e8-7eb385cf7991.jpg"><span id="more"></span></p><p>本文示例的房源数据，<a href="http://es.fanhaobai.com/rooms/_search">见这里</a>，检索同样使用 Elasticsearch 的 DSL 对比 SQL 来说明。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><h3 id="常规聚合"><a href="#常规聚合" class="headerlink" title="常规聚合"></a>常规聚合</h3><p>aggs 子句聚合是 Elasticsearch 常规的聚合实现方式。</p><h4 id="桶和指标"><a href="#桶和指标" class="headerlink" title="桶和指标"></a>桶和指标</h4><p>先理解这两个基本概念：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>桶（Buckets）</td><td>满足特定条件的文档的集合</td></tr><tr><td>指标（Metrics）</td><td>对桶内的文档进行统计计算</td></tr></tbody></table><p>每个聚合都是 <a href="#">一个或者多个桶和零个或者多个指标</a> 的组合，聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。例如这个 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(field_name) <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> field_name</span><br></pre></td></tr></table></figure><p>其中<code>COUNT(field_name)</code>相当于指标，<code>GROUP BY field_name</code>相当于桶。桶在概念上类似于 SQL 的分组（GROUP BY），而指标则类似于 COUNT() 、 SUM() 、 MAX() 等统计方法。</p><p>桶和指标的可用取值列表：</p><table><thead><tr><th>分类</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>桶</td><td>terms</td><td>按精确值划分桶</td></tr><tr><td>指标</td><td>sum</td><td>桶内对该字段值求总数</td></tr><tr><td>指标</td><td>min</td><td>桶内对该字段值求最小值</td></tr><tr><td>指标</td><td>max</td><td>桶内对该字段值求最大值</td></tr><tr><td>指标</td><td>avg</td><td>桶内对该字段值求平均数</td></tr><tr><td>指标</td><td>cardinality（基数）</td><td>桶内对该字段不同值的数量（<em>distinct</em> 值）</td></tr></tbody></table><h4 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h4><p>Elasticsearch 聚合 DSL 描述如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">    <span class="string">&quot;aggs_name&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;operate&quot;</span> : &#123; <span class="string">&quot;field&quot;</span> : <span class="string">&quot;field_name&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，aggs_name 表示聚合结果返回的字段名，operate 表示桶或指标的操作符名，field_name 为需要进行聚合的字段。</p><ul><li>例1，统计西二旗每个小区的房源数量：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL描述</span></span><br><span class="line"><span class="keyword">SELECT</span> resblockId, <span class="built_in">COUNT</span>(resblockId) <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> bizcircleCode <span class="operator">=</span> <span class="number">611100314</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> resblockId</span><br></pre></td></tr></table></figure><p>Elasticsearch 聚合为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;must&quot;</span>: [&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;bizcircleCode&quot;</span>: <span class="number">611100314</span> &#125;&#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;resblock_list&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;resblockId&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;total&quot;</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="string">&quot;max_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: [... ...]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;resblock_list&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;doc_count_error_upper_bound&quot;</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="string">&quot;sum_other_doc_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="string">&quot;buckets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;key&quot;</span>: <span class="number">1321052240532</span>, <span class="comment">//小区id为1321052240532有4间房</span></span><br><span class="line">          <span class="string">&quot;doc_count&quot;</span>: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;key&quot;</span>: <span class="number">1111047349969</span>,<span class="comment">//小区id为1111047349969有1间房</span></span><br><span class="line">          <span class="string">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;key&quot;</span>: <span class="number">1111050770108</span>,<span class="comment">//小区id为1111050770108有1间房</span></span><br><span class="line">          <span class="string">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>可见，此时聚合的结果有且只有分组后文档的  <a href="#">数量</a>，只适合做一些分组后文档数的统计。</p><ul><li>例2，去重统计西二旗小区的数量：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL描述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> resblockId) <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> bizcircleCode <span class="operator">=</span> <span class="number">611100314</span></span><br></pre></td></tr></table></figure><p>使用 cardinality 指标统计：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;resblock_count&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;cardinality&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;resblockId&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加度量指标"><a href="#添加度量指标" class="headerlink" title="添加度量指标"></a>添加度量指标</h4><p>上述的简单聚合，虽然可以统计桶内的文档数量，但是没法实现组内的其他指标统计，比如小区内的最低房源价格，这时就可以给桶添加一个 min 指标。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL描述</span></span><br><span class="line"><span class="keyword">SELECT</span> resblockId, <span class="built_in">MIN</span>(price) <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> bizcircleCode <span class="operator">=</span> <span class="number">611100314</span></span><br></pre></td></tr></table></figure><p>添加 min 指标后为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;resblock_list&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;resblockId&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;min&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;buckets&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: <span class="number">1321052240532</span>,</span><br><span class="line">    <span class="string">&quot;doc_count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;min_price&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="number">3320</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="嵌套桶"><a href="#嵌套桶" class="headerlink" title="嵌套桶"></a>嵌套桶</h4><p>当然桶与桶之间也可以进行嵌套，这样就能满足复杂的聚合场景了。</p><p>例如，统计每个商圈的房源价格分布情况：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL描述</span></span><br><span class="line"><span class="keyword">SELECT</span> bizcircleCode, GROUP_CONCAT(price) <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> cityCode <span class="operator">=</span> <span class="number">110000</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> bizcircleCode</span><br></pre></td></tr></table></figure><p>桶聚合实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bizcircle_price&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;bizcircleCode&quot;</span> &#125;,</span><br><span class="line">      <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;price_list&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;bizcircle_price&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;doc_count_error_upper_bound&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;sum_other_doc_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;buckets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: <span class="number">18335745</span>,</span><br><span class="line">      <span class="string">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;price_list&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;buckets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;key&quot;</span>: <span class="number">3500</span>,</span><br><span class="line">          <span class="string">&quot;doc_count&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ... ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加文档信息"><a href="#增加文档信息" class="headerlink" title="增加文档信息"></a>增加文档信息</h4><p>通常情况下，聚合只返回了统计的一些指标，当需要获取聚合后每组的文档信息（小区的名字和坐标等）时，该怎么处理呢？这时，使用 top_hits 子句就可以实现。</p><p>例如，获取西二旗每个小区最便宜的房源信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rooms&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;top_hits&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;sort&quot;</span>: &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，size 为组内返回的文档个数，sort 表示组内文档的排序规则，_source 指定组内文档返回的字段。</p><p>聚合后的房源信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;bizcircle_price&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;buckets&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: <span class="number">1111050770108</span>,</span><br><span class="line">      <span class="string">&quot;doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;rooms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">              <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111050770108</span>,</span><br><span class="line">                <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;领秀慧谷C区&quot;</span>,</span><br><span class="line">                <span class="string">&quot;size&quot;</span>: <span class="number">15.3</span>,</span><br><span class="line">                <span class="string">&quot;bizcircleName&quot;</span>: [ <span class="string">&quot;西二旗&quot;</span>, <span class="string">&quot;回龙观&quot;</span> ],</span><br><span class="line">                <span class="string">&quot;location&quot;</span>: <span class="string">&quot;40.106349,116.31051&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">&quot;sort&quot;</span>: [ <span class="number">3500</span> ]</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段折叠"><a href="#字段折叠" class="headerlink" title="字段折叠"></a>字段折叠</h3><p>从 Elasticsearch 5.0 之后，增加了一个新特性 field collapsing（字段折叠），字段折叠就是特定字段进行合并并去重，然后返回结果集，该功也能实现 agg top_hits 的聚合效果。</p><p>例如， <a href="#%E5%A2%9E%E5%8A%A0%E6%96%87%E6%A1%A3%E4%BF%A1%E6%81%AF">增加文档信息</a> 部分的获取西二旗每个小区最便宜的房源信息，可以实现为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;collapse&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;field&quot;</span>: <span class="string">&quot;resblockId&quot;</span>,  <span class="comment">//按resblockId字段进行折叠</span></span><br><span class="line">    <span class="string">&quot;inner_hits&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;top_price&quot;</span>, <span class="comment">//房源信息结果键名</span></span><br><span class="line">      <span class="string">&quot;size&quot;</span>: <span class="number">1</span>,           <span class="comment">//每个折合集文档数</span></span><br><span class="line">      <span class="string">&quot;sort&quot;</span>: [            <span class="comment">//每个折合集文档排序规则</span></span><br><span class="line">        &#123; <span class="string">&quot;price&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: []        <span class="comment">//文档的字段</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检索结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111050770108</span>,</span><br><span class="line">        <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;领秀慧谷C区&quot;</span>,</span><br><span class="line">        ... ...</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;resblockId&quot;</span>: [ <span class="number">1111050770108</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;inner_hits&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;top_price&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;hits&quot;</span>: [ </span><br><span class="line">            &#123; </span><br><span class="line">              <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">              <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111050770108</span>,</span><br><span class="line">                <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;领秀慧谷C区&quot;</span>,</span><br><span class="line">                <span class="string">&quot;price&quot;</span>: <span class="number">3500</span>,</span><br><span class="line">                ... ...</span><br><span class="line">                <span class="string">&quot;location&quot;</span>: <span class="string">&quot;40.106349,116.31051&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">&quot;sort&quot;</span>: [ <span class="number">3500</span> ]</span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Field collapsing 和 agg top_hits 区别：field collapsing 的结果是够精确，同时速度较快，更支持分页功能。</p></blockquote><h2 id="LBS"><a href="#LBS" class="headerlink" title="LBS"></a>LBS</h2><p>Elasticsearch 同样也支持了空间位置检索，即可以通过地理坐标点进行过滤检索。</p><h3 id="索引格式"><a href="#索引格式" class="headerlink" title="索引格式"></a>索引格式</h3><p>由于地理坐标点不能被动态映射自动检测，需要显式声明对应字段类型为 geo-point，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /rooms   <span class="comment">//索引名</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;room&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="string">&quot;location&quot;</span>: &#123;          <span class="comment">//空间位置检索字段</span></span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span>  <span class="comment">//字段类型</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>当需检索字段类型设置成 geo_point 后，推送的经纬度信息的形式可以是字符串、数组或者对象，如下：</p><table><thead><tr><th>形式</th><th>符号</th><th>示例</th></tr></thead><tbody><tr><td>字符串</td><td>“lat,lon”</td><td>“40.060937,116.315943”</td></tr><tr><td>对象</td><td>lat 和 lon</td><td>{ “lat”:40.060937, “lon”:116.315943 }</td></tr><tr><td>数组</td><td>[lon, lat]</td><td>[116.315943, 40.060937]</td></tr></tbody></table><p>特别需要注意数组形式时 lon 与 lat 的前后位置，不然就果断踩坑了。</p><p>然后，推送含有经纬度的数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /rooms/room/</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;resblockId&quot;</span>: <span class="number">1321052240532</span>,</span><br><span class="line">  <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;领秀新硅谷1号院&quot;</span>,</span><br><span class="line">  <span class="string">&quot;houseId&quot;</span>: <span class="number">1112046338679</span>,</span><br><span class="line">  <span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span>,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="number">611100314</span> ],</span><br><span class="line">  <span class="string">&quot;bizcircleName&quot;</span>: [ <span class="string">&quot;西二旗&quot;</span> ],</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: <span class="number">3330</span>,</span><br><span class="line">  <span class="string">&quot;location&quot;</span>: <span class="string">&quot;40.060937,116.315943&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检索过滤方式"><a href="#检索过滤方式" class="headerlink" title="检索过滤方式"></a>检索过滤方式</h3><p>Elasticsearch 中支持 4 种地理坐标点过滤器，如下表：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>geo_distance</td><td>找出与指定位置在给定距离内的点</td></tr><tr><td>geo_distance_range</td><td>找出与指定点距离在最小距离和最大距离之间的点</td></tr><tr><td>geo_bounding_box</td><td>找出落在指定矩形框中的点</td></tr><tr><td>geo_polygon</td><td>找出落在多边形中的点，将不说明</td></tr></tbody></table><p>例如，查找西二旗地铁站 4km 的房源信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;filter&quot;</span>: &#123;              <span class="comment">//过滤搜索子句</span></span><br><span class="line">    <span class="string">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;4km&quot;</span>,</span><br><span class="line">      <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lat&quot;</span>: <span class="number">40.106349</span>,</span><br><span class="line">        <span class="string">&quot;lon&quot;</span>: <span class="number">116.31051</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LBS 检索的结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111050770108</span>,</span><br><span class="line">        <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;领秀慧谷C区&quot;</span>,</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="string">&quot;location&quot;</span>: <span class="string">&quot;40.106349,116.31051&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111047349969</span>,</span><br><span class="line">        <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;融泽嘉园&quot;</span>,</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="string">&quot;location&quot;</span>: <span class="string">&quot;40.074203,116.315445&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲述了使用 Elasticsearch 进行 <a href="#">聚合</a> 和 <a href="#">LBS</a> 检索，尽管文中只是以示例形式进行说明，会存在很多不全面的地方，还是希望对你我学习 Elasticsearch 能有所帮助。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/08/elasticsearch-search.html">Elasticsearch检索实战</a> <span>（2017-08-09）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章 &lt;a href=&quot;https://www.fanhaobai.com/2017/08/elasticsearch-search.html&quot;&gt;Elasticsearch检索实战&lt;/a&gt; 已经讲述了 Elasticsearch 基本检索使用，已满足大部分检索场景，但是某些特定项目中会使用到 &lt;a href=&quot;#&quot;&gt;聚合&lt;/a&gt; 和 &lt;a href=&quot;#&quot;&gt;LBS&lt;/a&gt; 这类高级检索，以满足检索需求。这里将讲述 Elasticsearch 的聚合和 LBS 检索使用方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/elasticsearch-advanced-search/d758139c-86ce-4472-89e8-7eb385cf7991.jpg&quot;&gt;
    
    </summary>
    
      <category term="Lucene" scheme="https://www.fanhaobai.com/categories/Lucene/"/>
    
    
      <category term="Elasticsearch" scheme="https://www.fanhaobai.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>身份证的编码规则</title>
    <link href="https://www.fanhaobai.com/2017/08/id-card.html"/>
    <id>https://www.fanhaobai.com/2017/08/id-card.html</id>
    <published>2017-08-20T03:39:31.000Z</published>
    <updated>2024-04-18T08:38:12.669Z</updated>
    
    <content type="html"><![CDATA[<p>在我国现行的身份证系统中共有 15 位和 18 位两种身份证号码，第一代身份证大多为 15 位号码，由于 15 位身份证只能为 1900.01.01 到 1999.12.31 出生的人编码（千年虫问题），所以后来逐步替换为 18 位的身份证号码。</p><p><img src="//www.fanhaobai.com/2017/08/id-card/05f73384-a9ba-4a80-8433-563331dfd896.jpg"><span id="more"></span></p><h2 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h2><h3 id="15位"><a href="#15位" class="headerlink" title="15位"></a>15位</h3><p>15 位身份证编码规则为：<a href="#">DDDDDD YYMMDD XXS</a></p><p>各组成部分说明：</p><table><thead><tr><th>部分名</th><th>描述</th></tr></thead><tbody><tr><td>DDDDDD</td><td>6 位地区编码</td></tr><tr><td>YYMMDD</td><td>出生年月。年份用 2 位表示</td></tr><tr><td>XXS</td><td>顺序码。<br>其中 S 为性别识别码，奇数为男，偶数为女</td></tr></tbody></table><p>例如某个 15 位 ID 为：513701930509101。</p><h3 id="18位"><a href="#18位" class="headerlink" title="18位"></a>18位</h3><p>18 位身份证较 15 位身份证，出生年月改变为 8 位，并引入了校验位。编码规则为：<a href="#">DDDDDD YYYYMMDD XXX Y</a></p><p>各组成部分说明：</p><table><thead><tr><th>部分名</th><th>描述</th></tr></thead><tbody><tr><td>DDDDDD</td><td>6 位地区编码</td></tr><tr><td>YYYYMMDD</td><td>出生年月。年份用 4 位表示</td></tr><tr><td>XXX</td><td>顺序码。奇数为男，偶数为女</td></tr><tr><td>Y</td><td>校验位。前 17 位值计算而得</td></tr></tbody></table><p>校验位 Y 取值范围为 [1, 0, X, 9, 8, 7, 6, 5, 4, 3, 2]，其采用加权方式校验，校验规则为：p = mod(∑(Ai×Wi), 11)</p><p>参数说明：</p><ul><li>i 为身份证数字所在的位数，1-17；</li><li>Ai 为身份证第 i 位对应的数字值；</li><li>Wi 为加权因子，值为 [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]；</li><li>p 表示获取 Y 范围值的第 p+1 个值作为校验值 Y；</li></ul><p>例如某个 18 位 ID 位：513701199305091010，校验位后续计算得出。</p><h2 id="格式校验"><a href="#格式校验" class="headerlink" title="格式校验"></a>格式校验</h2><p>通过分析身份证的 <a href="#%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99">编码规则</a>，我们就可以得出身份证的校验规则，这里使用正则表达式去进行匹配。</p><h3 id="15位-1"><a href="#15位-1" class="headerlink" title="15位"></a>15位</h3><p>15 位身份证<code>DDDDDD YYMMDD XXS</code>的每部分的正则匹配表达式为：</p><table><thead><tr><th>部分名</th><th>正则表达式</th></tr></thead><tbody><tr><td>DDDDDD</td><td>[1-9]\d{5}</td></tr><tr><td>YYMMDD</td><td>(\d{2})(0[1-9]&#124;(1[0-2]))(([0-2][1-9])&#124;([1-2]0)&#124;31)</td></tr><tr><td>XXS</td><td>\d{3}</td></tr></tbody></table><p>由此可得 15 位身份证证正则匹配表达式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;^[1-9]\d&#123;5&#125;\d&#123;2&#125;(0[1-9]|(1[0-2]))(([0-2][1-9])|([1-2]0)|31)\d&#123;3&#125;$&#x27;</span></span><br><span class="line"><span class="comment">//可简化为:</span></span><br><span class="line"><span class="string">&#x27;^[1-9]\d&#123;7&#125;(0[1-9]|1[0-2])([0-2][1-9]|[1-2]0|31)\d&#123;3&#125;$&#x27;</span></span><br></pre></td></tr></table></figure><p>PHP 中校验为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ID_15_PREG</span> = <span class="string">&#x27;/^[1-9]\d&#123;7&#125;(0[1-9]|1[0-2])([0-2][1-9]|[1-2]0|31)\d&#123;3&#125;$/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_string</span>(<span class="variable">$id</span>) || <span class="keyword">empty</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>) == <span class="number">15</span> &amp;&amp; <span class="title function_ invoke__">preg_match</span>(<span class="built_in">static</span>::<span class="variable constant_">ID_15_PREG</span>, <span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18位-1"><a href="#18位-1" class="headerlink" title="18位"></a>18位</h3><p>同理，18 位身份证<code>DDDDDD YYYYMMDD XXX Y</code>的每部分的正则匹配表达式为：</p><table><thead><tr><th>部分名</th><th>正则表达式</th></tr></thead><tbody><tr><td>DDDDDD</td><td>[1-9]\d{5}</td></tr><tr><td>YYYYMMDD</td><td>([1-9]\d{3})(0[1-9]&#124;(1[0-2]))(([0-2][1-9])&#124;([1-2]0)&#124;31)</td></tr><tr><td>XXX</td><td>\d{3}</td></tr><tr><td>Y</td><td>\d</td></tr></tbody></table><p>由此可得 18 位身份证证正则匹配表达式为： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;^[1-9]\d&#123;5&#125;([1-9]\d&#123;3&#125;)((0[1-9]|(1[0-2]))(([0-2][1-9])|([1-2]0)|31)\d&#123;3&#125;\d|[Xx]$&#x27;</span></span><br><span class="line"><span class="comment">//可简化为：</span></span><br><span class="line"><span class="string">&#x27;^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;(0[1-9]|1[0-2])([0-2][1-9]|[1-2]0|31)(\d&#123;4&#125;|\d&#123;3&#125;[Xx])$&#x27;</span></span><br></pre></td></tr></table></figure><p>根据校验位校验规则，实现 <strong>校验位</strong> 的编码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getCheckBit</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">18</span> !== <span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$yArr</span> = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">    <span class="variable">$wArr</span> = [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>)-<span class="number">2</span>; <span class="variable">$i</span>&gt;=<span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">        <span class="variable">$sum</span> += <span class="variable">$id</span>[<span class="variable">$i</span>] * <span class="variable">$wArr</span>[<span class="variable">$i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$key</span> = <span class="variable">$sum</span> % <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$yArr</span>[<span class="variable">$key</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，PHP 中校验逻辑为:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ID_18_PREG</span> = <span class="string">&#x27;/^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;(0[1-9]|1[0-2])([0-2][1-9]|[1-2]0|31)(\d&#123;4&#125;|\d&#123;3&#125;[Xx])$/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_string</span>(<span class="variable">$id</span>) || <span class="keyword">empty</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>) == <span class="number">18</span> &amp;&amp; <span class="title function_ invoke__">preg_match</span>(<span class="built_in">static</span>::<span class="variable constant_">ID_18_PREG</span>, <span class="variable">$id</span>) &amp;&amp; <span class="title function_ invoke__">strtoupper</span>(<span class="variable">$id</span>[<span class="number">17</span>]) === <span class="built_in">self</span>::<span class="title function_ invoke__">getCheckBit</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>) == <span class="number">15</span> &amp;&amp; <span class="title function_ invoke__">preg_match</span>(<span class="built_in">static</span>::<span class="variable constant_">ID_15_PREG</span>, <span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15位转化为18位"><a href="#15位转化为18位" class="headerlink" title="15位转化为18位"></a>15位转化为18位</h2><p>在金融等某些特殊行业，需要将 15 位身份证号码格式化为 18 位。由于 15 位身份证颁发年份都是 19** 年，所以在转化为 18 位时补充出生年份时直接添加 19 即可。</p><p>转化步骤：</p><ul><li>年份补全成 4 位，年份前直接添加 19；</li><li>补全上步的新号码为 18 位，可以在原号码末尾直接追加 X；</li><li>计算新号码的校验位并替换原校验位值；</li></ul><p>15 位身份证转化为 18 位的代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">format18</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">static</span>::<span class="title function_ invoke__">validate</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">15</span> !== <span class="title function_ invoke__">strlen</span>(<span class="variable">$id</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$newId</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$id</span>, <span class="number">0</span>, <span class="number">6</span>) . <span class="string">&#x27;19&#x27;</span> . <span class="title function_ invoke__">substr</span>(<span class="variable">$id</span>, -<span class="number">9</span>) . <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="variable">$newId</span>[<span class="number">17</span>] = <span class="built_in">static</span>::<span class="title function_ invoke__">getCheckBit</span>(<span class="variable">$newId</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$newId</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化示例结果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//15位---------------------18位</span></span><br><span class="line"><span class="string">&#x27;370725881105149&#x27;</span> =&gt; <span class="string">&#x27;37072519881105149X&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我国现行的身份证系统中共有 15 位和 18 位两种身份证号码，第一代身份证大多为 15 位号码，由于 15 位身份证只能为 1900.01.01 到 1999.12.31 出生的人编码（千年虫问题），所以后来逐步替换为 18 位的身份证号码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/id-card/05f73384-a9ba-4a80-8433-563331dfd896.jpg&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>APP接口多版本处理</title>
    <link href="https://www.fanhaobai.com/2017/08/api-version.html"/>
    <id>https://www.fanhaobai.com/2017/08/api-version.html</id>
    <published>2017-08-19T10:36:09.000Z</published>
    <updated>2024-04-18T08:38:12.660Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 APP 端 API 接口时，随着 APP 的版本迭代，尽管通常 APP 只需要保持 4-5 个版本可用，过老版本会强制更新，但 API 接口避免不了出现多个版本的情况，那么 API 接口的多版本问题服务端怎么解决呢？</p><p><img src="//www.fanhaobai.com/2017/08/api-version/114d5a46452f82018a1f0aaee82fdfab.png"><span id="more"></span></p><p>要实现 API 的版本控制，常见的方法就是引入版本号。本文结合 Yii 2 来进行演示。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>传递 API 的版本号大致有两种方式：</p><ul><li>版本号配置为子域名，但由于版本号变更频繁，该方式采用较少；</li><li>版本号嵌入 URL 中，如百度 API 的<code>http://api.map.baidu.com/direction/v2/transit</code>；</li><li>版本号放入 HTTP 请求头的 Accept 中，如<code>Accept: application/json; version=1</code>；</li></ul><p>这两种方式都存在不足，第 1 种版本号跟资源不相关，所以违背 Restful 风格，第 2 种接口版本信息又不够直观。Yii 2 中混合了这两种方法实现了主版本号和小版本号，如下：</p><ul><li>把每个主版本的 API 实现在一个单独的模块（例如 v1，v2），因此，API 的 URL 会包含主版本号；</li><li>在每一个主要版本（即相应的模块），使用 Accept 请求头确定小版本号实现具体业务逻辑；</li></ul><p>之所以使用大小版本号是为了更好地分离代码。当小迭代或者 bug 修复时，更新小版本号，大的需求变更或者一次开发周期中迭代次数较多则更新大版本号。</p><h2 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h2><p>每个版本代码放置于一个独立的目录下，由于项目中每个 API 同时存在多个版本，如果都是独立的多份代码，相邻版本之间逻辑大致相同，所以代码冗余较高，另外存在需要修改多份代码的情况，不易维护。</p><p>另一种方式是通过调整代码结构，新版本 <a href="#">继承</a> 上一个版本，通过 <a href="#">重写</a> 来更好地进行功能迭代和升级，同时也能版本兼容。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>根据大版本号分离成模块后，项目目录结构如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">api/</span><br><span class="line">    controllers/</span><br><span class="line">        BaseAction.php  <span class="comment">#版本控制</span></span><br><span class="line">        BaseController.php  <span class="comment">#基础控制器 </span></span><br><span class="line">    models/</span><br><span class="line">        logics/</span><br><span class="line">            RoomLogic.php   <span class="comment">#房源的相关公用检索逻辑</span></span><br><span class="line">        SolrModel.php       <span class="comment">#solr基础Model</span></span><br><span class="line">        RoomModel.php       <span class="comment">#房源数据源</span></span><br><span class="line">    modules/</span><br><span class="line">        v1/                     <span class="comment">#v1</span></span><br><span class="line">            controllers/</span><br><span class="line">                room/</span><br><span class="line">                    ListAction.php  <span class="comment">#List方法所有版本</span></span><br><span class="line">                RoomController.php  <span class="comment">#v1版的房源控制器,继承自BaseController</span></span><br><span class="line">            models/</span><br><span class="line">                logics/</span><br><span class="line">                    RoomLogic.php   <span class="comment">#v1版的房源检索逻辑,继承自RoomLogic.php</span></span><br><span class="line">            Module.php</span><br><span class="line">        v2/                     <span class="comment">#v2</span></span><br><span class="line">            controllers/</span><br><span class="line">                room/</span><br><span class="line">                    ListAction.php  <span class="comment">#List方法所有版本</span></span><br><span class="line">                RoomController.php  <span class="comment">#v2版的房源控制器,继承自BaseController</span></span><br><span class="line">            models/</span><br><span class="line">                logics/</span><br><span class="line">                    RoomLogic.php   <span class="comment">#v2版的房源检索逻辑,继承自v1/RoomLogic.php</span></span><br><span class="line">            Module.php</span><br></pre></td></tr></table></figure><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在编码时，尽量将每个版本公有逻辑提出到 common 下，只将版本特有逻辑放置于对应版本下。</p><h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p>公有部分，包括公有逻辑，数据源 model 等，放置于 controllers、models 部分。</p><ul><li>BaseAction.php</li></ul><p>BaseAction 用户处理小版本路由，后续的 Action 都继承自此。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">base</span>\<span class="title">InvalidCallException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">helpers</span>\<span class="title">ArrayHelper</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseAction</span> <span class="keyword">extends</span> \<span class="title">yii</span>\<span class="title">base</span>\<span class="title">Action</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$version</span> = <span class="title class_">ArrayHelper</span>::<span class="title function_ invoke__">getValue</span>(<span class="title class_">\Yii</span>::<span class="variable">$app</span>-&gt;response-&gt;acceptParams, <span class="string">&#x27;version&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$this</span>, <span class="string">&quot;version<span class="subst">$version</span>&quot;</span>)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">call_user_func</span>([<span class="variable">$this</span>, <span class="string">&quot;version<span class="subst">$version</span>&quot;</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCallException</span>(<span class="string">&#x27;invaild version.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RoomModel.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">models</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomModel</span> <span class="keyword">extends</span> <span class="title">SolrModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RoomLogic.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">models</span>\<span class="title class_">logics</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">models</span>\<span class="title">RoomModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomLogic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计房源数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">countRoomByResblock</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$params</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$model</span> = <span class="keyword">new</span> <span class="title class_">RoomModel</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;从solr获取信息&#x27;</span>, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h4><p>v1 版本为初始版本，大部分逻辑只需继承自公有逻辑<code>common/RoomLogic.php</code>。</p><ul><li>v1/RoomController.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v1</span>\<span class="title class_">controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">modules</span>\<span class="title">v1</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomController</span> <span class="keyword">extends</span> \<span class="title">api</span>\<span class="title">controllers</span>\<span class="title">BaseAction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;list&#x27;</span> =&gt; [<span class="string">&#x27;class&#x27;</span> =&gt; <span class="string">&#x27;api\modules\v1\controllers\room\ListAction&#x27;</span>]</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v1/ListAction.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v1</span>\<span class="title class_">controllers</span>\<span class="title class_">room</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">modules</span>\<span class="title">v1</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">base</span>\<span class="title">DynamicModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAction</span> <span class="keyword">extends</span> \<span class="title">api</span>\<span class="title">controllers</span>\<span class="title">BaseAction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//v1.1版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">version1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;v1：&#x27;</span>, PHP_EOL;</span><br><span class="line">        <span class="title class_">RoomLogic</span>::<span class="title function_ invoke__">countRoomByResblock</span>(<span class="variable">$form</span>-&gt;attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//v1.2版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">version2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;v1.2：&#x27;</span>, PHP_EOL;</span><br><span class="line">        <span class="title class_">RoomLogic</span>::<span class="title function_ invoke__">countRoomByResblock</span>(<span class="variable">$form</span>-&gt;attributes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v1/RoomLogic.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v1</span>\<span class="title class_">models</span>\<span class="title class_">logics</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomLogic</span> <span class="keyword">extends</span> \<span class="title">api</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * v1版统计房源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">countRoomByResblock</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$params</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">countRoomByResblock</span>(<span class="variable">$params</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v1 版结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求信息</span></span><br><span class="line"><span class="variable constant_">GET</span> /v1/room/list.<span class="property">json</span></span><br><span class="line"><span class="title class_">Accept</span>: application/json; version=<span class="number">1</span></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">v1：</span><br><span class="line">从solr获取信息</span><br></pre></td></tr></table></figure><h4 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h4><p>v2 版逻辑对 v1 版进行了扩展，比如返回小区房源的最低价、小区房源总数等。</p><ul><li>v2/RoomController.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v2</span>\<span class="title class_">controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">controllers</span>\<span class="title">BaseController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">modules</span>\<span class="title">v2</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;list&#x27;</span> =&gt; [<span class="string">&#x27;class&#x27;</span> =&gt; <span class="string">&#x27;api\modules\v2\controllers\room\ListAction&#x27;</span>]</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v2/ListAction.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v2</span>\<span class="title class_">controllers</span>\<span class="title class_">room</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">modules</span>\<span class="title">v2</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">yii</span>\<span class="title">base</span>\<span class="title">DynamicModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAction</span> <span class="keyword">extends</span> \<span class="title">api</span>\<span class="title">controllers</span>\<span class="title">BaseAction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//v2.1版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">version1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;v2：&#x27;</span>, PHP_EOL;</span><br><span class="line">        <span class="title class_">RoomLogic</span>::<span class="title function_ invoke__">countRoomByResblock</span>(<span class="variable">$form</span>-&gt;attributes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v2/RoomLogic.php</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">modules</span>\<span class="title class_">v2</span>\<span class="title class_">models</span>\<span class="title class_">logics</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomLogic</span> <span class="keyword">extends</span> \<span class="title">api</span>\<span class="title">modules</span>\<span class="title">v1</span>\<span class="title">models</span>\<span class="title">logics</span>\<span class="title">RoomLogic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * v2版统计房源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">countRoomByResblock</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$params</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">countRoomByResblock</span>(<span class="variable">$params</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;我扩展了v1版逻辑&#x27;</span>, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 版结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求信息</span></span><br><span class="line"><span class="variable constant_">GET</span> /v2/room/list.<span class="property">json</span></span><br><span class="line"><span class="title class_">Accept</span>: application/json; version=<span class="number">1</span></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">v2：</span><br><span class="line">从solr获取信息</span><br><span class="line">我扩展了v1版逻辑</span><br></pre></td></tr></table></figure><h4 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h4><p> 如果某一天，数据源需要从 solr 切换到 es，那么只需改写共有<code>RoomLogic.php</code>并保持数据结构不变，老版本数据也就切换为 es 了。</p><p>RoomModel 修改：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">models</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomModel</span> <span class="keyword">extends</span> <span class="title">EsModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RoomLogic 部分修改 countRoomByResblock 方法：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">api</span>\<span class="title class_">models</span>\<span class="title class_">logics</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">api</span>\<span class="title">models</span>\<span class="title">RoomModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoomLogic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">countRoomByResblock</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$params</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$model</span> = <span class="keyword">new</span> <span class="title class_">RoomModel</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;从es获取信息&#x27;</span>, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v3 版结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v3：</span><br><span class="line">从es获取信息</span><br><span class="line">我扩展了v1版逻辑</span><br></pre></td></tr></table></figure><p>老版本 v2 版结果如下；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v2：</span><br><span class="line">从es获取信息</span><br><span class="line">我扩展了v1版逻辑</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文叙述的方式，虽然多个版本时代码不会冗余，但是每个版本之间会有较强的依赖关系，并没有做到应用解耦。实际中还需根据业务场景选择合适的版本处理方案，本文仅提供一种实现思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发 APP 端 API 接口时，随着 APP 的版本迭代，尽管通常 APP 只需要保持 4-5 个版本可用，过老版本会强制更新，但 API 接口避免不了出现多个版本的情况，那么 API 接口的多版本问题服务端怎么解决呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/api-version/114d5a46452f82018a1f0aaee82fdfab.png&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>什么是Bitmap算法？</title>
    <link href="https://www.fanhaobai.com/2017/08/bitmap.html"/>
    <id>https://www.fanhaobai.com/2017/08/bitmap.html</id>
    <published>2017-08-16T15:10:42.000Z</published>
    <updated>2024-04-18T08:38:12.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://mp.weixin.qq.com/s?__biz=MjM5OTA1MDUyMA==&mid=2655438893&idx=2&sn=42383086a358b718d7de569c42b5fbf8&chksm=bd73045a8a048d4c4237d362d7007889740f4b75de565325ee28aeba183380e3e03d1dce37b8&mpshare=1&scene=23&srcid=0817azlyj8TR6xsyxW0KNolG##">伯乐专栏 玻璃猫</a></p></blockquote><p>本文的灵感来源于京东金融数据部张洪雨同学的项目经历，感谢这位大神的技术分享。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/e897a05e-90c5-442f-8700-b07650c5bb79.png"><span id="more"></span></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/de158ff0-a75a-4742-890f-7f8fa54e8429.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/b94d2ee6-08b8-46bb-bc14-648d25f3d1b0.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/2ecb7934-8521-4b03-a13d-27a884d2cb18.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/f9dc49b3-503c-427e-8256-7db81b39466f.jpg"></p><p>为满足用户标签的统计需求，小灰利用 MySQL 设计了如下的表结构，每一个维度的标签都对应着 MySQL 表的一列：</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/98132f45-baeb-4317-823f-28994b6a1b53.jpg"></p><p>要想统计所有 90 后的程序员该怎么做呢？</p><p>用一条求交集的 SQL 语句即可：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name) <span class="keyword">AS</span> 用户数 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="string">&#x27;90后&#x27;</span> <span class="keyword">AND</span> occupation <span class="operator">=</span> <span class="string">&#x27;程序员&#x27;</span></span><br></pre></td></tr></table></figure><p>要想统计所有使用苹果手机或者 00 后的用户总合该怎么做？用一条求并集的 SQL 语句即可：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> name) <span class="keyword">AS</span> 用户数 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;苹果&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="string">&#x27;00后&#x27;</span></span><br></pre></td></tr></table></figure><p>两个月之后——</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/57833b05-cf4c-4f30-8ff2-a5c5f3682139.jpg"></p><p>———————————————</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/f0c74969-652b-4fa2-b980-fc4f5f99c61d.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/b94201a7-beaf-4613-beda-f7a3674f5228.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/bf6bf8d3-3801-4fca-b229-8cc83ea5ba81.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/bf0f2d59-b0de-4f96-b598-ffccb8677758.jpg"></p><p>1.给定长度是 10 的 bitmap，每一个 bit 位分别对应着从 0 到 9 的 10 个整型数。此时 bitmap 的所有位都是 0。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/5ad4199b-e5d1-45f9-9657-98f2f2c34960.png"></p><p>2.把整型数 4 存入 bitmap，对应存储的位置就是下标为 4 的位置，将此 bit 置为 1。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/2f3a90c8-afe8-4d5c-995a-d064ac1f5336.png"></p><p>3.把整型数 2 存入 bitmap，对应存储的位置就是下标为 2 的位置，将此 bit 置为 1。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/fc1939b6-a486-4998-9507-c3e5825bce9a.png"></p><p>4.把整型数 1 存入 bitmap，对应存储的位置就是下标为 1 的位置，将此 bit 置为 1。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/eda83296-8ff6-4558-975c-a73860cccc54.png"></p><p>5.把整型数 3 存入 bitmap，对应存储的位置就是下标为 3 的位置，将此 bit 置为 1。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/f4079a06-d308-4f25-ad37-46f2d1baf851.png"></p><p>要问此时 bitmap 里存储了哪些元素？显然是 4,3,2,1，一目了然。</p><p>bitmap 不仅方便查询，还可以去除掉重复的整型数。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/92401d1b-02ac-446f-908e-3057fa9c7fd4.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/8be164ef-9f6a-4a56-8a5d-53b417c9310a.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/3933f7cb-934c-42e7-8fc7-989b3e021010.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/e0e6f586-03ce-4d11-a390-34ff3c25400b.jpg"></p><p>1.建立用户名和用户 ID 的映射。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/a134be42-9acb-41c6-bc80-469b86de8ba0.png"></p><p>2.让每一个标签存储包含此标签的所有用户 ID，每一个标签都是一个独立的 bitmap。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/1dbec168-cbf6-4b42-bb56-ca143f559d06.jpg"></p><p>3.这样，实现用户的去重和查询统计，就变得一目了然。</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/3c423c70-2ed7-4cc4-a6fa-ce56bf285a5b.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/63f0f0a2-22e4-49dd-bcec-47e43fc69787.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/1da4242d-018f-4cf4-82c3-e3421b4cf003.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/a9997194-b4d8-4cf5-bb3e-33a68229729b.jpg"></p><p>1.如何查找使用苹果手机的程序员用户？</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/d68e8fa2-433a-47dc-8aed-ff1b993cf082.png"></p><p>2.如何查找所有男性或者00后的用户？</p><p><img src="//www.fanhaobai.com/2017/08/bitmap/45ef8692-b1d3-4b4b-a6ed-dbe105fb3f97.png"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/97c98774-03b3-47ed-852c-71d1a546a65c.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/d14eff84-5eb1-4268-87ae-4776c66af4a5.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/1605c694-bf55-4500-9531-9832df13b082.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/24836d0b-efb2-450f-9307-d078722e2c72.jpg"></p><p><img src="//www.fanhaobai.com/2017/08/bitmap/e72e268a-facd-4480-85be-c779db24ee74.jpg"></p><p><a href="#">说明</a>：该项目最初的技术选型并非 MySQL，而是内存数据库 hana。本文为了便于理解，把最初的存储方案写成了 MySQL 数据库。</p><p><strong>漫画算法系列 <a href="#">»</a></strong></p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560419&idx=1&sn=535073d4d69cf7fc45074ccb8c25ba1e&chksm=f1fee120c68968367597137515f21ef8d7a8ab68c9f4fce051dae5f2631afdc48ec11a30dd0e&scene=21#wechat_redirect">漫画算法：最小栈的实现</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560448&idx=1&sn=b4ca3d01a438fac78be4077f270974ca&chksm=f1fee143c6896855179eff005164be47c7c662d4c8badf571a79c4acd9e2aca9fd84839ca093&scene=21#wechat_redirect">漫画算法：判断 2 的乘方</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560411&idx=1&sn=2e655df46f082a50a4657a40f292d63a&chksm=f1fee118c689680eba2b9ba965780387aeafd08a72eecb2c748eece85b77631b0a5511f2833b&scene=21#wechat_redirect">漫画算法：找出缺失的整数</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560408&idx=1&sn=db553ce9deedf38c44841e16cb095d2e&chksm=f1fee11bc689680d83ff71d40dc191ee9899b8e5ef4bf9b98001ebb4daf13059a5961586ea1a&scene=21#wechat_redirect">漫画算法：辗转相除法是什么鬼？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561168&idx=1&sn=9d1c6f7ba6d651c75399c4aa5254a7d8&chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&scene=21#wechat_redirect">漫画算法：什么是动态规划？（整合版）</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561205&idx=1&sn=3c4feb6339e00e13bdd8cc6a11eb0304&chksm=f1feec36c689652085b1b89acd6ca07316140f1c7478249e4b251c204b6cf3a5bb276b0275be&scene=21#wechat_redirect">漫画算法：什么是跳跃表？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561220&idx=1&sn=2a6d8a0290f967027b1d54456f586405&chksm=f1feec47c689655113fa65f7911a1f59bbd994030ad685152b30e53d643049f969eefaa13058&scene=21#wechat_redirect">漫画算法：什么是 B 树？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561244&idx=1&sn=df3abafd3aa2f5a3abfe507bfc26982f&chksm=f1feec5fc6896549f89cbb82ee3d8010c63da76814030b285fa29322795de512ccca207064ee&scene=21#wechat_redirect">漫画算法：什么是 B+ 树？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561254&idx=1&sn=7500e3e54a573b19ce2fbfa0a82f2b13&chksm=f1feec65c689657386c8913f819bb5253bece3bd56f7fcc725201c925723e2fbc5bfcb962b9c&scene=21#wechat_redirect">漫画算法：什么是一致性哈希？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560503&idx=1&sn=461c62e9c88fb6fbd30a0a4a59bce76f&chksm=f1fee174c68968628afbcdc7fdbba04daef811dd94de94bf90a6a4e0b907d1b67638eaabe2ff&scene=21#wechat_redirect">漫画算法：无序数组排序后的最大相邻差值</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTA1MDUyMA==&amp;mid=2655438893&amp;idx=2&amp;sn=42383086a358b718d7de569c42b5fbf8&amp;chksm=bd73045a8a048d4c4237d362d7007889740f4b75de565325ee28aeba183380e3e03d1dce37b8&amp;mpshare=1&amp;scene=23&amp;srcid=0817azlyj8TR6xsyxW0KNolG##&quot;&gt;伯乐专栏 玻璃猫&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的灵感来源于京东金融数据部张洪雨同学的项目经历，感谢这位大神的技术分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/bitmap/e897a05e-90c5-442f-8700-b07650c5bb79.png&quot;&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.fanhaobai.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Solr的使用 — 检索</title>
    <link href="https://www.fanhaobai.com/2017/08/solr-search.html"/>
    <id>https://www.fanhaobai.com/2017/08/solr-search.html</id>
    <published>2017-08-13T08:22:24.000Z</published>
    <updated>2024-04-18T08:38:12.671Z</updated>
    
    <content type="html"><![CDATA[<p>本文是延续 <a href="https://www.fanhaobai.com/2017/08/solr-insatll-push.html">Solr的使用</a> 系列，前一篇文章已经讲了 Solr 的部署和数据推送，这里主要以示例方式讲述 Solr 的常见查询语法，同时介绍如何使用 PHP 语言的客户端 <a href="https://github.com/fan-haobai/solarium">solarium</a>  同 Solr 集群进行数据交互。<br><img src="//www.fanhaobai.com/2017/08/solr-search/c4665602-82dc-4cc3-9eaf-c0ed12935d08.png"><span id="more"></span></p><p>想要详细地了解 Solr 查询语法，可参考 <a href="https://cwiki.apache.org/confluence/display/solr/Query+Syntax+and+Parsing">官方wiki</a>。</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>用于示例的数据，我已经推送到了 Solr ，<a href="http://solr.fanhaobai.com/solr/rooms/select?q=*:*&wt=json&indent=true">见这里</a>。数据 Core 为 rooms，数据格式形如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111027377528</span>,</span><br><span class="line">    <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;金隅丽港城&quot;</span>,</span><br><span class="line">    <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span>,</span><br><span class="line">    <span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span>,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>: <span class="number">10.5</span>,</span><br><span class="line">    <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="number">18335711</span> ],</span><br><span class="line">    <span class="string">&quot;bizcircleName&quot;</span>: [ <span class="string">&quot;望京&quot;</span> ],</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="number">2300</span>,</span><br><span class="line">    <span class="string">&quot;location&quot;</span>: <span class="string">&quot;39.997106,116.469306&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;0119df79-68d9-4cd9-ba07-4d6395a4841c&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111047349969</span>,</span><br><span class="line">    <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;融泽嘉园&quot;</span>,</span><br><span class="line">    ... ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h2 id="查询语句的组成"><a href="#查询语句的组成" class="headerlink" title="查询语句的组成"></a>查询语句的组成</h2><p>通过向 Solr 集群 GET 请求<code>/solr/core-name/select?query</code>形式的查询 API 完成查询，其中 core-name 为查询的 Core 名称。查询语句 query 由以下基本元素项组成，按使用频率先后排序：</p><table><thead><tr><th>名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>wt</td><td>响应结果的格式</td><td>json</td></tr><tr><td>fl</td><td>指定结果集的字段</td><td>*（所有字段）</td></tr><tr><td>fq</td><td>过滤查询</td><td>id : 0119df79-68d9-4cd9-ba07</td></tr><tr><td>start</td><td>指定结果集起始返回的行数，默认 0</td><td>0</td></tr><tr><td>rows</td><td>指定结果集返回的行数，默认 10</td><td>15</td></tr><tr><td>sort</td><td>结果集的排序规则</td><td>price+asc</td></tr><tr><td>defType</td><td>设置查询解析器名称</td><td>dismax</td></tr><tr><td>timeAllowed</td><td>查询超时时间</td><td></td></tr></tbody></table><h3 id="wt"><a href="#wt" class="headerlink" title="wt"></a>wt</h3><p>wt 设置结果集格式，支持 json、xml、csv、php、ruby、pthyon，序列化的结果集，常使用 json 格式。</p><h3 id="fl"><a href="#fl" class="headerlink" title="fl"></a>fl</h3><p>fl 指定返回的字段，多指使用“空格”和“,”号分割，但只支持设置了<code>stored=true</code>的字段。<code>*</code>表示返回全部字段，一般情况不需要返回文档的全部字段。</p><p><strong>字段别名</strong>：使用<code>displayName:fieldName</code>形式指定字段的别名，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fl=id,<span class="attr">sales_price</span>:price,name</span><br></pre></td></tr></table></figure><p><strong>函数</strong>：fl 还支持使用 Solr <a href="#%E5%87%BD%E6%95%B0">内置函数</a>，例如根据单价算总价：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fl=id,<span class="attr">total</span>:<span class="title function_">product</span>(size,price)</span><br></pre></td></tr></table></figure><h3 id="fq"><a href="#fq" class="headerlink" title="fq"></a>fq</h3><p>fq 过滤查询条件，可充分利用 cache，所以可以利用 fq 提高检索性能。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort 指定结果集的排序规则，格式为<code>&lt;fieldName&gt;+&lt;sort&gt;</code>，支持 asc 和 desc 两种排序规则。例如按照价格倒序排列：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sort=price+desc</span><br></pre></td></tr></table></figure><p>也可以多字段排序，价格和面积排序：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sort=price+asc,size+desc</span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>查询字符串 q 由以下元素项组成，字段条件形如<code>fieldName:value</code>格式：</p><table><thead><tr><th>名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>q</td><td>查询字符串</td><td>*:*</td></tr><tr><td>q.op</td><td>表达式之间的关系操作符</td><td>AND/OR</td></tr><tr><td>df</td><td>查询被索引的字段</td><td>id:0119df79-68d9-4cd9-ba07</td></tr></tbody></table><p>以上元素项的默认值由<code>solrconfig.xml</code>配置文件定义。通常查询时设置<code>q=*:*</code>，然后通过 fq 过滤条件来完成查询，通过缓存提高查询性能。</p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>Solr 的模糊查询使用占位符来描述查询规则，如下：</p><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>匹配单个字符</td><td>te?t 会检索到 test 和 text</td></tr><tr><td>*</td><td>匹配零个或多个字符</td><td>tes* 会检索到 tes、test 等</td></tr></tbody></table><p>查询小区名称中包含“嘉”的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> resblockName <span class="keyword">LIKE</span> &quot;%嘉%&quot;</span><br></pre></td></tr></table></figure><p>Solr 的模糊查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fq=<span class="attr">resblockName</span>:*嘉*</span><br></pre></td></tr></table></figure><h3 id="单精确值查询"><a href="#单精确值查询" class="headerlink" title="单精确值查询"></a>单精确值查询</h3><p>单精确值查询是最简单的查询，类似于 SQL 中 = 操作符。查询小区 id 为 1111027377528 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> resblockId <span class="operator">=</span> <span class="number">1111027377528</span></span><br></pre></td></tr></table></figure><p>Solr 中查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fq=<span class="attr">resblockId</span>:<span class="number">1111027377528</span></span><br></pre></td></tr></table></figure><h3 id="多精确值查询"><a href="#多精确值查询" class="headerlink" title="多精确值查询"></a>多精确值查询</h3><p>多精确值查询是单精确值查询的扩展，格式为<code>(value1 value2 ...)</code>，功能类似于 SQL 的 IN 操作符。查询小区 id 为 1111027377528 或者 1111047349969 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> resblockId <span class="keyword">IN</span> (<span class="number">1111027377528</span>, <span class="number">1111047349969</span>)</span><br></pre></td></tr></table></figure><p>Solr 中查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fq=<span class="attr">resblockId</span>:(<span class="number">1111027377528</span> <span class="number">1111047349969</span>)</span><br></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>范围查询是查询指定范围的值（数字和时间），格式为<code>[value1 TO value2]</code>，类似于 SQL 的 BETWEEN 操作符。查询价格在 [2000, 3000] 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>Solr 中范围查询为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fq=price:[2000 TO 3000]</span><br></pre></td></tr></table></figure><p>几个特殊的范围查询：</p><table><thead><tr><th>条件</th><th>表达式</th><th>示例</th></tr></thead><tbody><tr><td>&gt;=</td><td>[value TO *]</td><td>price:[2000 TO *] 价格 &gt;=2000</td></tr><tr><td>&lt;=</td><td>[* TO value]</td><td>price:[* TO 2000] 价格 &lt;=2000</td></tr></tbody></table><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>将基本查询结合布尔查询，就可以实现大部分复杂的检索场景。布尔查询支持以下几种布尔操作：</p><table><thead><tr><th>操作逻辑</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>AND</td><td>&amp;&amp;<br>+</td><td>逻辑与关系</td></tr><tr><td>OR</td><td></td><td>逻辑或关系</td></tr><tr><td>NOT</td><td>！<br>-</td><td>逻辑取反关系</td></tr></tbody></table><p>查询北京市价格区间在 [2000, 3000] 或者上海市价格区间在 [1500, 2000] 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> (cityCode<span class="operator">=</span><span class="number">110000</span> <span class="keyword">AND</span> price <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">3000</span>) <span class="keyword">OR</span> (cityCode<span class="operator">=</span><span class="number">310000</span> <span class="keyword">AND</span> price <span class="keyword">BETWEEN</span> <span class="number">1500</span> <span class="keyword">AND</span> <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>转换为逻辑与布尔查询：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fq=(<span class="attr">cityCode</span>:<span class="number">110000</span> &amp;&amp; <span class="attr">price</span>:[<span class="number">2000</span> <span class="variable constant_">TO</span> <span class="number">3000</span>])||(<span class="attr">cityCode</span>:<span class="number">310000</span> &amp;&amp; <span class="attr">price</span>:[<span class="number">1500</span> <span class="variable constant_">TO</span> <span class="number">2000</span>])</span><br></pre></td></tr></table></figure><h2 id="Group查询"><a href="#Group查询" class="headerlink" title="Group查询"></a>Group查询</h2><p>在实际中分组查询比较常见，当然 Solr 也支持分组查询。分组查询语句由以下基本元素项组成（常用部分）：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>group</td><td>boolean</td><td>是否进行分组查询</td></tr><tr><td>group.field</td><td>string</td><td>按该字段值进行分组</td></tr><tr><td>group.limit</td><td>integer</td><td>每组元素集大小，默认为 1</td></tr><tr><td>group.offset</td><td>integer</td><td>每组元素起始行数</td></tr><tr><td>group.sort</td><td>string</td><td>组内元素排序规则，asc 和 desc</td></tr></tbody></table><p>查询西二旗内价格最便宜小区的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> bizcircleCode<span class="operator">=</span><span class="number">611100314</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> resblockId <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span> LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Group 分组查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">q=*:*&amp;fq=<span class="attr">bizcircleCode</span>:<span class="number">611100314</span>&amp;group=<span class="literal">true</span>&amp;group.<span class="property">field</span>=resblockId&amp;group.<span class="property">limit</span>=<span class="number">1</span>&amp;group.<span class="property">sort</span>=size+desc</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;groupValue&quot;</span>: <span class="number">1111047349969</span>,</span><br><span class="line">    <span class="string">&quot;doclist&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;numFound&quot;</span>: <span class="number">1</span>,                 <span class="comment">//每组房源数</span></span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;docs&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;resblockId&quot;</span>: <span class="number">1111047349969</span>,</span><br><span class="line">        <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;融泽嘉园&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="number">611100314</span> ],</span><br><span class="line">        <span class="string">&quot;price&quot;</span>: <span class="number">2500</span></span><br><span class="line">        ... ...</span><br><span class="line">    &#125;]</span><br><span class="line">    ... ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h2 id="Facet查询"><a href="#Facet查询" class="headerlink" title="Facet查询"></a>Facet查询</h2><p>在大多数情况下，Group 分组已经能满足我们的需求，但是如果待分组字段为多值，Group 分组已经无能为力了，这时使用 Facet 就能轻松解决。</p><p>Solr 的 Facet 语句由以下基本元素构成（常用）：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>facet</td><td>boolean</td><td>是否进行 facet 查询</td></tr><tr><td>facet.field</td><td>string</td><td>按该字段值进行 facet</td></tr><tr><td>facet.limit</td><td>integer</td><td>每组元素集大小，默认为 1</td></tr><tr><td>facet.offset</td><td>integer</td><td>每组元素起始行数</td></tr><tr><td>facet.sort</td><td>string</td><td>结果集排序规则，asc 和 desc</td></tr><tr><td>facet.mincount</td><td>integer</td><td>每组元素最小数量</td></tr></tbody></table><p>例如，统计每个商圈的房源分布情况并倒序排列，由于 bizcircleCode 字段为多值，Facet 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时不需要文档信息，故rows=0</span></span><br><span class="line">q=*:*&amp;fq=<span class="attr">cityCode</span>:<span class="number">110000</span>&amp;facet=<span class="literal">true</span>&amp;facet.<span class="property">field</span>=bizcircleCode&amp;facet.<span class="property">sort</span>=desc&amp;rows=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;facet_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bizcircleCode&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;18335711&quot;</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;18335745&quot;</span>,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;611100314&quot;</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间检索"><a href="#空间检索" class="headerlink" title="空间检索"></a>空间检索</h2><p>Solr 的 geofilt 过滤器可以实现 LBS 检索，但要在<code>schema.xml</code>配置中将需检索字段的字段类型设置为<code>solr.LatLonType</code>类型。geofilt 过滤器参数列表如下：</p><table><thead><tr><th>名称</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>d</td><td>检索距离，单位 km</td><td>2</td></tr><tr><td>pt</td><td>检索中心点坐标，格式：lat,lon</td><td>40.074203,116.315445</td></tr><tr><td>sfield</td><td>检索的索引字段</td><td>location</td></tr></tbody></table><p>示例中的 location 字段，值为  “40.074203,116.315445”，类型配置为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.LatLonType&quot;</span> <span class="attr">subFieldSuffix</span>=<span class="string">&quot;_coordinate&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">type</span>=<span class="string">&quot;location&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>则检索坐标点<code>40.074203,116.315445</code>附近 2 公里的房源信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">q=*:*&amp;fq=&#123;!geofilt&#125;&amp;spatial=<span class="literal">true</span>&amp;pt=<span class="number">40.074203</span>,<span class="number">116.315445</span>&amp;sfield=location&amp;d=<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Solr 提供一些函数以实现逻辑或数学运算。其中常用 <strong>数学运算</strong> 函数列表如下：</p><table><thead><tr><th>函数名</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>abs</td><td>求绝对值</td><td>abs(-5)</td></tr><tr><td>max</td><td>返回最大值</td><td>max(1, 2, 3)</td></tr><tr><td>min</td><td>返回最小值</td><td>min(1, 2, 3)</td></tr><tr><td>pow</td><td>返回指数运算的结果</td><td>pow(2, 2)</td></tr><tr><td>sqrt</td><td>开方运算的结果</td><td>sqrt(100)</td></tr><tr><td>product</td><td>乘积</td><td>product(1, 2, 3)</td></tr><tr><td>sub</td><td>差</td><td>sub(3, 2)</td></tr><tr><td>sum</td><td>和</td><td>sum(1, 2, 3)</td></tr><tr><td>div</td><td>商</td><td>div(4, 2)</td></tr><tr><td>log</td><td>10 的对数</td><td>log(10)</td></tr></tbody></table><p>常用的 <strong>逻辑运算</strong> 函数：</p><table><thead><tr><th>函数名</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>def</td><td>定义字段默认值</td><td>def(price, 0)</td></tr><tr><td>if</td><td>if(test,value1,value2)<br>test?value1:value2</td><td></td></tr><tr><td>exists</td><td>字段是否存在</td><td></td></tr></tbody></table><p>这些函数可以使用在返回值或者查询条件上。例如返回每个房源的每平方米价格信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">q=*:*&amp;fl=*,<span class="attr">avgPrice</span>:<span class="title function_">div</span>(price, size)</span><br></pre></td></tr></table></figure><h2 id="solarium客户端"><a href="#solarium客户端" class="headerlink" title="solarium客户端"></a>solarium客户端</h2><p>PHP 可以使用 <a href="https://github.com/solariumphp/solarium">solarium</a> 客户端，实现 Solr 数据源的检索，详细使用说明 <a href="http://solarium.readthedocs.io/en/stable/">见这里</a>。</p><h3 id="配置基本"><a href="#配置基本" class="headerlink" title="配置基本"></a>配置基本</h3><p>solarium 客户端需要配置 Solr 的基本信息。如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$solr</span> = [</span><br><span class="line">    <span class="string">&#x27;endpoint&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;localhost&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span> =&gt; <span class="string">&#x27;solr.fanhaobai.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span> =&gt; <span class="number">80</span>,</span><br><span class="line">            <span class="string">&#x27;path&#x27;</span> =&gt; <span class="string">&#x27;/solr/rooms/&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>solarium 提供的查询方法较丰富，整理后如下表所示：</p><table><thead><tr><th>方法</th><th>所属对象</th><th>描述</th></tr></thead><tbody><tr><td>createSelect</td><td>client</td><td>创建查询 query 对象</td></tr><tr><td>select</td><td>client</td><td>执行查询，返回 result 对象</td></tr><tr><td>setQuery</td><td>query</td><td>添加 query 条件</td></tr><tr><td>setStart</td><td>query</td><td>设置结果集起始行</td></tr><tr><td>setRows</td><td>query</td><td>设置结果集行数</td></tr><tr><td>setFields</td><td>query</td><td>设置返回的字段</td></tr><tr><td>addSort</td><td>query</td><td>结果集排序规则</td></tr><tr><td>createFilterQuery</td><td>query</td><td>创建 filter query 对象</td></tr></tbody></table><p>查询北京市的所有房源信息，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Solarium\Client</span>(<span class="variable">$solr</span>);</span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">createSelect</span>()-&gt;<span class="title function_ invoke__">setStart</span>(<span class="number">0</span>)-&gt;<span class="title function_ invoke__">setRows</span>(<span class="number">20</span>);</span><br><span class="line"><span class="variable">$query</span>-&gt;<span class="title function_ invoke__">createFilterQuery</span>(<span class="string">&#x27;rooms&#x27;</span>)-&gt;<span class="title function_ invoke__">setQuery</span>(<span class="string">&#x27;cityCode:110000&#x27;</span>);</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">select</span>(<span class="variable">$query</span>);</span><br></pre></td></tr></table></figure><h3 id="Group查询-1"><a href="#Group查询-1" class="headerlink" title="Group查询"></a>Group查询</h3><p>solarium 提供的分组查询方法如下表所示（常用）：</p><table><thead><tr><th>方法</th><th>所属对象</th><th>描述</th></tr></thead><tbody><tr><td>getGrouping</td><td>query</td><td>创建分组 group 对象</td></tr><tr><td>addQuery</td><td>group</td><td>添加分组 query</td></tr><tr><td>setSort</td><td>group</td><td>设置分组排序规则</td></tr><tr><td>setLimit</td><td>group</td><td>设置分组数量</td></tr><tr><td>getGrouping</td><td>result</td><td>获取分组信息</td></tr></tbody></table><p>获取西二旗每个小区的房源分布信息，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Solarium\Client</span>(<span class="variable">$solr</span>);</span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">createSelect</span>()-&gt;<span class="title function_ invoke__">setStart</span>(<span class="number">0</span>)-&gt;<span class="title function_ invoke__">setRows</span>(<span class="number">20</span>)-&gt;<span class="title function_ invoke__">setQuery</span>(<span class="string">&#x27;bizcircleCode:611100314&#x27;</span>);</span><br><span class="line"><span class="variable">$group</span> = <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">getGrouping</span>();</span><br><span class="line"><span class="variable">$group</span>-&gt;<span class="title function_ invoke__">addField</span>(<span class="string">&#x27;resblockId&#x27;</span>)-&gt;<span class="title function_ invoke__">setLimit</span>(<span class="number">10</span>)-&gt;<span class="title function_ invoke__">setSort</span>(<span class="string">&#x27;price desc&#x27;</span>)-&gt;<span class="title function_ invoke__">setNumberOfGroups</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">select</span>(<span class="variable">$query</span>);</span><br><span class="line"><span class="variable">$groups</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">getGrouping</span>();</span><br></pre></td></tr></table></figure><h3 id="Facet查询-1"><a href="#Facet查询-1" class="headerlink" title="Facet查询"></a>Facet查询</h3><p>solarium 提供的 Facet 查询方法，如下表（常用）：</p><table><thead><tr><th>方法</th><th>所属对象</th><th>描述</th></tr></thead><tbody><tr><td>getFacetSet</td><td>query</td><td>创建分组 facet 对象</td></tr><tr><td>createFacetField</td><td>facet</td><td>创建 facet 字段</td></tr><tr><td>setField</td><td>facet</td><td>facet 分组字段</td></tr><tr><td>setLimit</td><td>facet</td><td>设置 facet 分组大小</td></tr></tbody></table><p>获取北京市每个商圈的房源分布信息，如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Solarium\Client</span>(<span class="variable">$solr</span>);</span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">createSelect</span>()-&gt;<span class="title function_ invoke__">setStart</span>(<span class="number">0</span>)-&gt;<span class="title function_ invoke__">setRows</span>(<span class="number">20</span>)-&gt;<span class="title function_ invoke__">setQuery</span>(<span class="string">&#x27;bizcircleCode:611100314&#x27;</span>);</span><br><span class="line"><span class="variable">$facet</span> = <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">getFacetSet</span>();</span><br><span class="line"><span class="variable">$facet</span>-&gt;<span class="title function_ invoke__">createFacetField</span>(<span class="string">&#x27;bizcircle&#x27;</span>)-&gt;<span class="title function_ invoke__">setField</span>(<span class="string">&#x27;bizcircleCode&#x27;</span>)-&gt;<span class="title function_ invoke__">setLimit</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">select</span>(<span class="variable">$query</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，Solr 系列就整理完毕了，未涉及的部分后续接触时再补充。这两天利用休息时间充电，自己在 Solr 方面的技能也算是上了一个台阶了。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/08/solr-install-push.html">Solr的使用 — 部署和数据推送</a> <span>（2017-08-12）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是延续 &lt;a href=&quot;https://www.fanhaobai.com/2017/08/solr-insatll-push.html&quot;&gt;Solr的使用&lt;/a&gt; 系列，前一篇文章已经讲了 Solr 的部署和数据推送，这里主要以示例方式讲述 Solr 的常见查询语法，同时介绍如何使用 PHP 语言的客户端 &lt;a href=&quot;https://github.com/fan-haobai/solarium&quot;&gt;solarium&lt;/a&gt;  同 Solr 集群进行数据交互。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/solr-search/c4665602-82dc-4cc3-9eaf-c0ed12935d08.png&quot;&gt;
    
    </summary>
    
      <category term="Lucene" scheme="https://www.fanhaobai.com/categories/Lucene/"/>
    
    
      <category term="Solr" scheme="https://www.fanhaobai.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Solr的使用 — 部署和数据推送</title>
    <link href="https://www.fanhaobai.com/2017/08/solr-install-push.html"/>
    <id>https://www.fanhaobai.com/2017/08/solr-install-push.html</id>
    <published>2017-08-12T09:19:01.000Z</published>
    <updated>2024-04-18T08:38:12.670Z</updated>
    
    <content type="html"><![CDATA[<p>来到 ziroom 后，我使用 Solr 支持业务也有段时间了，大多数情况下 Solr 满足业务需求，但由于 Solr 随着数据量急剧上升后检索性能和更新索引效率衰退较快，同时一些历史遗留原因导致字段较多不易维护，现架构上已将搜索引擎迁移到了 ES。在这里整理记录自己使用 Solr 的点滴，供后续学习和使用时参考。<br><img src="//www.fanhaobai.com/2017/08/solr-install-push/43735106-acb6-4f42-a136-dd5ab347ef49.png"><span id="more"></span></p><p><a href="#">Solr的使用</a> 系列的重点应是 Solr 的检索，如果需要可以直接传送到 <a href="https://www.fanhaobai.com/2017/08/solr-search.html">Sorl检索</a> 部分。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>由于该 Solr 平台只供学习使用，所以直接采用 Docker 方式部署，这样能避免一些复杂的依赖环境导致的问题。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>从 <a href="https://hub.docker.com/">Hub</a> 拉取 Solr <a href="https://hub.docker.com/_/solr/">官方镜像</a> 到本地，这里只选择 5.5 版本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull solr:5.5</span></span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Docker 需要通过挂载宿主机目录的方式持久化数据，先创建供挂载目录（注意目录读写权限）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /home/docker/solr</span></span><br></pre></td></tr></table></figure><p><strong>启动</strong> 容器，挂载数据目录，隐射监听端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker --name solr -p 127.0.0.1:8983:8983 -v /home/docker/solr:/opt/solr/server/solr -d solr:5.5</span></span><br></pre></td></tr></table></figure><p>我们往往需要修改容器的一些默认参数（Solr 的配置），需要我们登入容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it solr /bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p>注：由于容器中 /opt/solr/server/solr 会默认存在一些 Solr 启动的必须配置文件，直接将空目录挂载到该目录，会导致容器启动失败。可以先将目录挂载到 /opt/solr/mydata 目录，启动容器后<code>cp /opt/solr/server/solr/* /opt/solr/mydata/</code>，获得这些配置文件后，重新以上述地址挂载启动容器即可。</p></blockquote><h3 id="配置Web服务"><a href="#配置Web服务" class="headerlink" title="配置Web服务"></a>配置Web服务</h3><p>Solr 容器启动成功后，配置 Web 服务器到 8983 端口，访问后看到 <a href="http://solr.fanhaobai.com/">Solr Admin</a> 页面，就表示安装成功了。</p><p>向 Solr 里推送数据，需要先建立 Core（核），然后在 Core 上创建或更新 Document（文档）。</p><h2 id="新建Core"><a href="#新建Core" class="headerlink" title="新建Core"></a>新建Core</h2><p>Core 默认路径为<code>/opt/solr/server/solr</code>。有两种方式新建 Core，<strong>方式一</strong> 是使用命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/solr create_core -c books</span></span><br><span class="line">Creating new core &#x27;books&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;responseHeader&quot;:&#123;</span><br><span class="line">    &quot;status&quot;:0,</span><br><span class="line">    &quot;QTime&quot;:1140</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;core&quot;:&quot;books&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除核使用delete</span></span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：在 Admin 面板点击 “Core Admin &gt;&gt; Add Core”，填写 name、instanceDir、dataDir、config、schema（文档的字段类型描述） 信息即可。由于 config 和 schema 配置可由模板生成，所以我偏向于使用命令方式创建。</p><blockquote><p>注：方式一和方式二，其实都是通过<code>/solr/admin/cores?action=CREATE</code>这个 API 来完成创建任务。</p></blockquote><p>新建 Core 后，可选中 books 核，点击 “Files”，这里列举出后面需要使用的 2 个配置文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/opt/solr/server/solr/bools/conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用命令创建后自动生成，后续新建文档的字段类型描述需加入其中</span></span><br><span class="line">managed-schema</span><br><span class="line">solrconfig.xml</span><br></pre></td></tr></table></figure><h2 id="新建Document-s"><a href="#新建Document-s" class="headerlink" title="新建Document(s)"></a>新建Document(s)</h2><p>Document 存放着数据记录，新建 Document 后就可以使用 Solr 检索了。这里需存入 book 的数据格式（例如 json）如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span> : <span class="string">&quot;978-0641723445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cat&quot;</span> : [<span class="string">&quot;book&quot;</span>, <span class="string">&quot;hardcover&quot;</span>],</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;The Lightning Thief&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span> : <span class="string">&quot;Rick Riordan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;price&quot;</span> : <span class="number">12.50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置字段类型"><a href="#配置字段类型" class="headerlink" title="配置字段类型"></a>配置字段类型</h3><p>如果没有配置字段映射类型推送数据时，Solr 会自动根据字段值设置字段的映射类型，并保存在<code>core-name/conf/managed-schema</code>文件，但是有时结果并不是我们想要的，所以配置文档的字段类型描述很有必要。</p><p>从上述 book 的数据可得，各个 Document 的字段类型关系：</p><table><thead><tr><th>字段名</th><th>类型</th><th>是否只被索引</th></tr></thead><tbody><tr><td>id</td><td>string</td><td>√</td></tr><tr><td>cat</td><td>strings</td><td></td></tr><tr><td>name</td><td>string</td><td></td></tr><tr><td>author</td><td>strings</td><td></td></tr><tr><td>price</td><td>tdouble</td><td></td></tr></tbody></table><p>字段类型通过文件<code>schema.xml</code>描述，需放置于 Core 的 conf 目录，文档格式可以参考<code>managed-schema</code>文件，基本要素大致为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ![需更改]schema.name需要同core名一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.6&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ![需更改]唯一键，重复时记录会覆盖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>id<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ![无需更改]fieldType定义字段值类型,这里只列举了部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;boolean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.BoolField&quot;</span> <span class="attr">sortMissingLast</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="comment">&lt;!-- as: true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;booleans&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.BoolField&quot;</span> <span class="attr">sortMissingLast</span>=<span class="string">&quot;true&quot;</span> <span class="attr">multiValued</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="comment">&lt;!-- as: [true,false,true] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.TrieIntField&quot;</span> <span class="attr">positionIncrementGap</span>=<span class="string">&quot;0&quot;</span> <span class="attr">precisionStep</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">&lt;!-- ![需更改]field定义各字段类型,type为fieldType.name定义值,indexed=false使用只用于返回而无需进行搜索的字段,stored=false适用只需要搜索而无需返回的字段,required=true字段值必须存在 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;_version_&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;strings&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">type</span>=<span class="string">&quot;strings&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tdouble&quot;</span>/&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">&lt;!-- ![无需更改]dynamicField --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">&quot;*&quot;</span> <span class="attr">dest</span>=<span class="string">&quot;_text_&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果后续更新 schema.xml 配置后，需要对 Core 进行 Reload 操作，否则检索时字段类型可能未变更。可以点击 “Core Admin &gt;&gt; Reload” 操作。</p></blockquote><h3 id="推送数据"><a href="#推送数据" class="headerlink" title="推送数据"></a>推送数据</h3><p>Solr 支持的数据源类型较多，为 xml、json、csv 等格式。</p><p><strong>方式一</strong>：使用 post 命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">post工具</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/post -c books server/solr/data/books.json</span> </span><br></pre></td></tr></table></figure><p><code>books.json</code>是以 json 格式描述的一些 book，可以批量推送数据。</p><p><strong>方式二</strong>：在 Admin 面板点击 “books &gt;&gt; Documents”，在 Document(s) 一栏中输入一个 book 信息，并点击 “ Submit Document” 即可。成功右侧会返回：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Status</span>: success</span><br><span class="line"><span class="title class_">Response</span>:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;responseHeader&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;QTime&quot;</span>: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过 <a href="http://solr.fanhaobai.com/solr/books/select?q=*:*&wt=json&indent=true">检索</a>，可以查看数据推送是否成功，检索结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;docs&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;978-0641723445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cat&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;book&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hardcover&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;The Lightning Thief&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Rick Riordan&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="number">12.5</span>,</span><br><span class="line">    <span class="string">&quot;_version_&quot;</span>: <span class="number">1575546976608452600</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>注：方式一和二其实是殊途同归，都是 POST 请求<code>solr/books/update?wt=json</code>这个 API。</p></blockquote><h2 id="删除Document-s"><a href="#删除Document-s" class="headerlink" title="删除Document(s)"></a>删除Document(s)</h2><p>删除 Document 其实也是 update 操作，同样有两种方式。</p><p>先使用 xml 格式构建需要删除 Document 的条件描述<code>del-book.xml</code>，如删除 id 为 978-0641723445 的 book 信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要删除文档的query条件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">query</span>&gt;</span>id:978-0641723445<span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- commit一定要，否则不会提交修改到索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commit</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式一</strong>：同样使用 post 命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/post -c books server/solr/data/del-book.xml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里会自动提交commit,所以del-book.xml中无commit也可以</span></span><br><span class="line">COMMITting Solr index changes to http://localhost:8983/solr/books/update..</span><br></pre></td></tr></table></figure><p><strong>方式二</strong>：在 Admin 面板点击 “books &gt;&gt; Documents”，Document Type 项选择 xml，然后在 Document(s) 一栏中输入需要删除 book 的条件描述（del-book.xml 内容），并点击 “ Submit Document” 即可。</p><p>重新检索，可以发现 id 为 978-0641723445 的 book 信息已经被成功删除。</p><blockquote><p>注：方式一和二都是 POST 请求<code>solr/books/update?wt=json</code>这个 API。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文仅仅叙述了 Solr 的 Docker 单节点部署和简单的数据推送实现，由于个人能力和时间限制，并未涉及到其生成环境的应用环节。后续的一篇文章将会记录 Solr 的检索语法和 PHP 作为客户端调用 Solr 服务的一种方案。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/08/solr-search.html">Solr的使用 — 检索</a> <span>（2017-08-13）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来到 ziroom 后，我使用 Solr 支持业务也有段时间了，大多数情况下 Solr 满足业务需求，但由于 Solr 随着数据量急剧上升后检索性能和更新索引效率衰退较快，同时一些历史遗留原因导致字段较多不易维护，现架构上已将搜索引擎迁移到了 ES。在这里整理记录自己使用 Solr 的点滴，供后续学习和使用时参考。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/solr-install-push/43735106-acb6-4f42-a136-dd5ab347ef49.png&quot;&gt;
    
    </summary>
    
      <category term="Lucene" scheme="https://www.fanhaobai.com/categories/Lucene/"/>
    
    
      <category term="Solr" scheme="https://www.fanhaobai.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch检索实战</title>
    <link href="https://www.fanhaobai.com/2017/08/elasticsearch-search.html"/>
    <id>https://www.fanhaobai.com/2017/08/elasticsearch-search.html</id>
    <published>2017-08-09T15:38:30.000Z</published>
    <updated>2024-04-18T08:38:12.669Z</updated>
    
    <content type="html"><![CDATA[<p>随着公司房源数据的急剧增多，现搜索引擎 Solr 的搜索效率和建立索引效率显著降低，而 <a href="https://github.com/elastic/elasticsearch">Elasticsearch</a> 是一个实时的分布式搜索和分析引擎，它是基于全文搜索引擎 <a href="https://lucene.apache.org/">Apache Lucene</a> 之上，接入 Elasticsearch 是必然之选。本文是我学习使用 Elasticsearch 检索的笔记。</p><p><img src="//www.fanhaobai.com/2017/08/elasticsearch-search/9a3accb9-0da1-47e4-ad58-428370464af6.jpg"><span id="more"></span></p><p>Elasticsearch 支持 RESTful API 方式检索，查询结果以 JSON 格式响应，文中示例数据见 <a href="http://es.fanhaobai.com/">这里</a>。有关 Elasticsearch 详细使用说明，见  <a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/">官方文档</a>。</p><h2 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h2><p>检索 url 中需包含 <strong>索引名</strong>，<code>_search</code>为查询关键字。例如 <a href="http://es.fanhaobai.com/rooms/_search">http://es.fanhaobai.com/rooms/_search</a> 的 rooms 为索引名，此时表示无任何条件检索，检索结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /rooms/_search</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;took&quot;</span>: <span class="number">6</span>,</span><br><span class="line">   <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="string">&quot;_shards&quot;</span>: &#123; ... &#125;,</span><br><span class="line">   <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;total&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">&quot;max_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;rooms&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;room_info&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">               <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111027377528&quot;</span>,</span><br><span class="line">               <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;金隅丽港城&quot;</span>,</span><br><span class="line">               <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span>,</span><br><span class="line">               <span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span>,</span><br><span class="line">               <span class="string">&quot;size&quot;</span>: <span class="number">10.5</span>,</span><br><span class="line">               <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="string">&quot;18335711&quot;</span> ],</span><br><span class="line">               <span class="string">&quot;bizcircleName&quot;</span>: [ <span class="string">&quot;望京&quot;</span> ],</span><br><span class="line">       <span class="string">&quot;price&quot;</span>: <span class="number">2300</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">               <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111047349969&quot;</span>,</span><br><span class="line">               <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;融泽嘉园&quot;</span>,</span><br><span class="line">               <span class="string">&quot;houseId&quot;</span>: <span class="number">1087817932553</span>,</span><br><span class="line">               <span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span>,</span><br><span class="line">               <span class="string">&quot;size&quot;</span>: <span class="number">10.35</span>,</span><br><span class="line">               <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="string">&quot;611100314&quot;</span> ],</span><br><span class="line">               <span class="string">&quot;bizcircleName&quot;</span>: [ <span class="string">&quot;西二旗&quot;</span> ],</span><br><span class="line">               <span class="string">&quot;price&quot;</span>: <span class="number">2500</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line"> ... ...</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：Elasticsearch 官方偏向于使用 GET 方式（能更好描述信息检索的行为），GET 方式可以携带请求体，但是由于不被广泛支持，所以 Elasticsearch 也支持 POST 请求。后续查询语言使用 POST 方式。</p></blockquote><p>当我们确定了需要检索文档的 url 后，就可以使用查询语法进行检索，Elasticsearch 支持以下 Query string（查询字符串）和 DSL（结构化）2 种检索语句。</p><h2 id="检索语句"><a href="#检索语句" class="headerlink" title="检索语句"></a>检索语句</h2><h3 id="Query-string"><a href="#Query-string" class="headerlink" title="Query string"></a>Query string</h3><p>我们可以直接在 get 请求时的 url 后追加<code>q=</code>查询参数，这种方法常被称作 query string 搜索，因为我们像传递 url 参数一样去传递查询语句。例如查询小区 id 为 1111027374551 的房源信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /rooms/_search?q=<span class="attr">resblockId</span>:<span class="number">1111027374551</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询结果,无关信息已省略</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111027374551&quot;</span>,</span><br><span class="line">            <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;国风北京二期&quot;</span>,</span><br><span class="line">            ... ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然查询字符串便于查询特定的搜索，但是它也有局限性。</p><h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><p>DSL 查询以 JSON 请求体的形式出现，它允许构建更加复杂、强大的查询。DSL 方式查询上述 query string 查询条件则为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /rooms/_search</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111027374551&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>term 语句为过滤类型之一，后面再进行说明。使用 DSL 语句查询支持 <strong>filter</strong>（过滤器）、<strong>match</strong>（全文检索）等复杂检索场景。</p><h2 id="基本检索"><a href="#基本检索" class="headerlink" title="基本检索"></a>基本检索</h2><p>Elasticsearch 支持为 2 种检索行为，它们都是使用 DSL 语句来表达检索条件，分别为 <strong>query</strong> （结构化查询）和 <strong>filter</strong>（结构化搜索）。</p><p>说明：后续将使用 SQL 对比 DSL 语法进行搜索条件示例。</p><h3 id="结构化查询"><a href="#结构化查询" class="headerlink" title="结构化查询"></a>结构化查询</h3><p>结构化查询支持全文检索，会对检索结果进行相关性计算。使用结构化查询，需要传递 query 参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;query&quot;</span>: your_query &#125;</span><br><span class="line"><span class="comment">//your_query为&#123;&#125;表示空查询</span></span><br></pre></td></tr></table></figure><blockquote><p>注：后续查询中不再列出 query 参数，只列出 your_query（查询内容）。</p></blockquote><h4 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h4><p>match_all 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询。查询所有房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms</span><br></pre></td></tr></table></figure><p>match_all 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;match_all&quot;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h4><p>match 查询为全文搜索，类似于 SQL 的 LIKE 查询。查询小区名中包含“嘉”的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> resblockName <span class="keyword">LIKE</span> <span class="string">&#x27;%嘉%&#x27;</span></span><br></pre></td></tr></table></figure><p>match 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;嘉&quot;</span> &#125;&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111047349969&quot;</span>,</span><br><span class="line">            <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;融泽嘉园&quot;</span>,</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h4><p>multi_match 查询可以在多个字段上执行相同的 match 查询：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>:  <span class="string">&quot;京&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span>: [ <span class="string">&quot;resblockName&quot;</span>, <span class="string">&quot;bizcircleName&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>range 查询能检索出那些落在指定区间内的文档，类似于 SQL 的 BETWEEN 操作。range 查询被允许的操作符有：</p><table><thead><tr><th>操作符</th><th>操作关系</th></tr></thead><tbody><tr><td>gt</td><td>大于</td></tr><tr><td>gte</td><td>大于等于</td></tr><tr><td>lt</td><td>小于</td></tr><tr><td>lte</td><td>小于等于</td></tr></tbody></table><p>查询价格在 (2000, 2500] 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">2500</span> <span class="keyword">AND</span> price <span class="operator">!=</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>range 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;price&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;gt&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">            <span class="string">&quot;lte&quot;</span>: <span class="number">2500</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>term 查询用于精确值匹配，可能是数字、时间、布尔。例如查询房屋 id 为 1087599828743 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> houseId <span class="operator">=</span> <span class="number">1087599828743</span></span><br></pre></td></tr></table></figure><p>term 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="terms查询"><a href="#terms查询" class="headerlink" title="terms查询"></a>terms查询</h4><p>terms 查询同 term 查询，但它允许指定多值进行匹配，类似于 SQL 的 IN 操作。例如查询房屋 id 为 1087599828743 或者 1087817932342 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> houseId <span class="keyword">IN</span> (<span class="number">1087599828743</span>, <span class="number">1087817932342</span>)</span><br></pre></td></tr></table></figure><p>terms 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;houseId&quot;</span>: [ <span class="number">1087599828743</span>, <span class="number">1087817932342</span> ] &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>term 查询和 terms 查询都不分析输入的文本， 不会进行相关性计算。</p></blockquote><h4 id="exists查询和missing查询"><a href="#exists查询和missing查询" class="headerlink" title="exists查询和missing查询"></a>exists查询和missing查询</h4><p>exists 查询和 missing 查询被用于查找那些指定字段中有值和无值的文档，类似于 SQL 中的 IS NOT NULL 和 IS NULL 查询。查询价格有效的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> price <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>exists 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;exists&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><p>我们时常需要将多个条件的结构进行逻辑与和或操作，等同于 SQL 的 AND 和 OR，这时就应该使用 bool 子句合并多子句结果。 共有 3 种 bool 查询，分别为 must（AND）、must_not（NOT）、should（OR）。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>must</td><td>AND 关系，<strong>必须</strong> 匹配这些条件才能检索出来</td></tr><tr><td>must_not</td><td>NOT 关系，<strong>必须不</strong> 匹配这些条件才能检索出来</td></tr><tr><td>should</td><td>OR 关系，<strong>至少匹配一条</strong> 条件才能检索出来</td></tr><tr><td>filter</td><td><strong>必须</strong> 匹配，不参与评分</td></tr></tbody></table><p>查询小区中包含“嘉”字或者房屋 id 为 1087599828743 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> (resblockName <span class="keyword">LIKE</span> <span class="string">&#x27;%嘉%&#x27;</span> <span class="keyword">OR</span> houseId <span class="operator">=</span> <span class="number">1087599828743</span>) <span class="keyword">AND</span> (cityCode <span class="operator">=</span> <span class="number">110000</span>)</span><br></pre></td></tr></table></figure><p>bool 查询为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;must&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>: &#123;<span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span> &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">&quot;should&quot;</span>: [</span><br><span class="line">        &#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;嘉&quot;</span> &#125;&#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 filter 语句来使得其子句不参与评分过程，减少评分可以有效地优化性能。重写前面的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;should&quot;</span>: [</span><br><span class="line">        &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;resblockName&quot;</span>: <span class="string">&quot;嘉&quot;</span> &#125;&#125;</span><br><span class="line">     ],</span><br><span class="line">     <span class="string">&quot;filter&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">           <span class="string">&quot;must&quot;</span>: &#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;cityCode&quot;</span>: <span class="number">110000</span> &#125;&#125;,</span><br><span class="line">           <span class="string">&quot;should&quot;</span>: [</span><br><span class="line">              &#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span> &#125;&#125;</span><br><span class="line">           ]</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bool 查询可以相互的进行嵌套，已完成非常复杂的查询条件。</p><h4 id="constant-score查询"><a href="#constant-score查询" class="headerlink" title="constant_score查询"></a>constant_score查询</h4><p>constant_score 查询将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 <strong>filter</strong>（过滤器）而没有其它查询（评分查询）的情况下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;constant_score&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;houseId&quot;</span>: <span class="number">1087599828743</span> &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h3><p>结构化搜索的查询适合确定值数据（数字、日期、时间），这些类型数据都有明确的格式。结构化搜索结果始终是是或非，结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档，由于结构化搜索使用到过滤器，在查询时需要传递 filter 参数，由于 DSL 语法查询必须以 query 开始，所以 filter 需要放置在 query 里，因此结构化查询的结构为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;constant_score&quot;</span>: &#123; </span><br><span class="line">            <span class="string">&quot;filter&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">//your_filters</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：后续搜索中不再列出 query 参数，只列出 your_filters（过滤内容）。</p></blockquote><p>结构化搜索一样存在很多过滤器 term、terms、range、exists、missing、bool，我们在结构化查询中都已经接触过了。</p><h4 id="term搜索"><a href="#term搜索" class="headerlink" title="term搜索"></a>term搜索</h4><p>最为常用的 term 搜索用于查询精确值，可以用它处理数字（number）、布尔值（boolean）、日期（date）以及文本（text）。查询小区 id 为 1111027377528 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> resblockId <span class="operator">=</span> &quot;1111027377528&quot;</span><br></pre></td></tr></table></figure><p>term 搜索为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;resblockId&quot;</span>: <span class="string">&quot;1111027377528&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>类似<code>XHDK-A-1293-#fJ3</code>这样的文本直接使用 term 查询时，可能无法获取到期望的结果。是因为 Elasticsearch 在建立索引时，会将该数据分析成 xhdk、a、1293、#fj3 字样，这并不是我们期望的，可以通过指定 not_analyzed 告诉 Elasticsearch 在建立索引时无需分析该字段值。</p><h4 id="terms搜索"><a href="#terms搜索" class="headerlink" title="terms搜索"></a>terms搜索</h4><p>terms 搜索使用方式和 term 基本一致，而 terms 是搜索字段多值的情况。查询商圈 code 为 18335711 或者 611100314 的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> bizcircleCode <span class="keyword">IN</span> (<span class="number">18335711</span>, <span class="number">611100314</span>)</span><br></pre></td></tr></table></figure><p>terms搜索为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;terms&quot;</span>: &#123; <span class="string">&quot;bizcircleCode&quot;</span>: [ <span class="string">&quot;18335711&quot;</span>, <span class="string">&quot;611100314&quot;</span> ] &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="range搜索"><a href="#range搜索" class="headerlink" title="range搜索"></a>range搜索</h4><p>在进行范围过滤查询时使用 range 搜索，支持数字、字母、日期的范围查询。查询面积在 [15, 25] 平米之间的房源信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> size <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>range 搜索为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;gte&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;lte&quot;</span>: <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range 搜索使用在日期上：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;gt&quot;</span>: <span class="string">&quot;2017-01-01 00:00:00&quot;</span>,</span><br><span class="line">            <span class="string">&quot;lt&quot;</span>: <span class="string">&quot;2017-01-07 00:00:00&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exists和missing搜索"><a href="#exists和missing搜索" class="headerlink" title="exists和missing搜索"></a>exists和missing搜索</h4><p>exists 和 missing 搜索是针对某些字段值存在和缺失的查询。查询房屋面积存在的房源列表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL表述</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> size <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>exists 搜索为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;exists&quot;</span>: &#123; <span class="string">&quot;field&quot;</span>: <span class="string">&quot;size&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>missing 搜索刚好和 exists 搜索相反，但语法一致。</p><h4 id="bool组合搜索"><a href="#bool组合搜索" class="headerlink" title="bool组合搜索"></a>bool组合搜索</h4><p>bool 过滤器是为了解决过滤多个值或字段的问题，它可以接受多个其他过滤器作为子过滤器，并将这些过滤器结合成各式各样的逻辑组合。</p><p>bool 过滤器的组成部分，同 bool 查询一致：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;must&quot;</span>:     [],</span><br><span class="line">      <span class="string">&quot;should&quot;</span>:   [],</span><br><span class="line">      <span class="string">&quot;must_not&quot;</span>: [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于如下 SQL 查询条件：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rooms <span class="keyword">WHERE</span> (bizcircleCode <span class="operator">=</span> <span class="number">18335711</span> <span class="keyword">AND</span> price <span class="keyword">BETWEEN</span> <span class="number">2000</span> <span class="keyword">AND</span> <span class="number">2500</span>) <span class="keyword">OR</span> (bizcircleCode <span class="operator">=</span> <span class="number">611100314</span> <span class="keyword">AND</span> price <span class="operator">&gt;=</span> <span class="number">2500</span>)</span><br></pre></td></tr></table></figure><p>使用 bool 过滤器实现为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">       <span class="string">&quot;should&quot;</span>: [</span><br><span class="line">           &#123; </span><br><span class="line">              <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;bizcircleCode&quot;</span>: <span class="string">&quot;18335711&quot;</span> &#125;,</span><br><span class="line">              <span class="string">&quot;range&quot;</span>: &#123; <span class="string">&quot;price&quot;</span>: &#123; <span class="string">&quot;gte&quot;</span>: <span class="number">2000</span>, <span class="string">&quot;lte&quot;</span>: <span class="number">25000</span> &#125;&#125;</span><br><span class="line">           &#125;, </span><br><span class="line">           &#123; </span><br><span class="line">              <span class="string">&quot;term&quot;</span>: &#123; <span class="string">&quot;bizcircleCode&quot;</span>: <span class="string">&quot;611100314&quot;</span> &#125;,</span><br><span class="line">              <span class="string">&quot;range&quot;</span>: &#123; <span class="string">&quot;price&quot;</span>: &#123; <span class="string">&quot;gte&quot;</span>: <span class="number">2500</span> &#125;&#125;</span><br><span class="line">           &#125; </span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>区别</strong>：结构化查询会进行相关性计算，因此不会缓存检索结果；而结构化搜索会缓存搜索结果，因此具有较高的检索效率，在不需要全文搜索或者其它任何需要影响相关性得分的查询中建议只使用结构化搜索。当然，结构化查询和结构化搜索可以配合使用。</p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p> 该部分较复杂，已单独使用文章进行说明，见 <a href="https://www.fanhaobai.com/2017/08/elasticsearch-advanced-search.html#%E8%81%9A%E5%90%88">Elasticsearch检索 — 聚合和LBS</a> 部分。</p><h3 id="source子句"><a href="#source子句" class="headerlink" title="_source子句"></a>_source子句</h3><p>某些时候可能不需要返回文档的全部字段，这时就可以使用 _source 子句指定返回需要的字段。只返回需要的房源信息字段：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;_source&quot;</span>: [ <span class="string">&quot;cityCode&quot;</span>, <span class="string">&quot;houseId&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;resblockName&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort子句"><a href="#sort子句" class="headerlink" title="sort子句"></a>sort子句</h3><h4 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4><p>排序是使用比较多的推荐方式，在 Elasticsearch 中，默认会按照相关性进行排序，相关性得分由一个浮点数进行表示，并在搜索结果中通过<code>_score</code>参数返回（未参与相关性评分时分数为 1）， 默认是按<code>_score</code>降序排序。</p><p>sort 方式有 desc、asc 两种。将房源查询结果按照价格升序排列：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;sort&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;price&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h4><p>当存在多级排序的场景时，结果首先按第一个条件排序，仅当结果集的第一个 sort 值完全相同时才会按照第二个条件进行排序，以此类推。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">      &#123; <span class="string">&quot;price&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="string">&quot;_score&quot;</span>: &#123; <span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;&#125;  <span class="comment">//price一直时，按照相关性降序</span></span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段多指排序"><a href="#字段多指排序" class="headerlink" title="字段多指排序"></a>字段多指排序</h4><p>当字段值为 <strong>多值</strong> 及 <a href="#">字段多指排序</a>，Elasticsearch 会对于数字或日期类型将多值字段转为单值。转化有 min 、max 、avg、 sum 这 4 种模式。 </p><p>例如，将房源查询结果按照商圈 code 升序排列：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;sort&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;bizcircleCode&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">         <span class="string">&quot;mode&quot;</span>:  <span class="string">&quot;min&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页子句"><a href="#分页子句" class="headerlink" title="分页子句"></a>分页子句</h3><p>和 SQL 使用 LIMIT 关键字返回单 page 结果的方法相同，Elasticsearch 接受 from（初始结果数量）和 size（应该返回结果数量） 参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;size&quot;</span>: <span class="number">8</span>,</span><br><span class="line">   <span class="string">&quot;from&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证查询合法性"><a href="#验证查询合法性" class="headerlink" title="验证查询合法性"></a>验证查询合法性</h2><p>在实际应用中，查询可能变得非常的复杂，理解起来就有点困难了。不过可以使用<code>validate-query</code>API来验证查询合法性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /room/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;query&quot;</span>: &#123; <span class="string">&quot;resblockName&quot;</span>: &#123; <span class="string">&quot;match&quot;</span>: <span class="string">&quot;嘉&quot;</span> &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合法的 query 返回信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;valid&quot;</span>:         <span class="literal">false</span>,</span><br><span class="line">   <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;total&quot;</span>:       <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;successful&quot;</span>:  <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;failed&quot;</span>:      <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>别的业务线已经投入 Elasticsearch 使用有段时间了，找房业务线正由 Solr 切换为 Elasticsearch，各个系统有一个探索和磨合的过程。当然，Elasticsearch 我们已经服务化了，对 DSL 语法也进行了一些简化，同时支持了定制化业务。另外，使用 <a href="https://github.com/NLPchina/elasticsearch-sql">elasticsearch-sql</a> 插件可以让 Elasticsearch 也支持 SQL 操作。  </p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/08/elasticsearch-advanced-search.html">Elasticsearch检索 — 聚合和LBS</a> <span>（2017-08-21）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着公司房源数据的急剧增多，现搜索引擎 Solr 的搜索效率和建立索引效率显著降低，而 &lt;a href=&quot;https://github.com/elastic/elasticsearch&quot;&gt;Elasticsearch&lt;/a&gt; 是一个实时的分布式搜索和分析引擎，它是基于全文搜索引擎 &lt;a href=&quot;https://lucene.apache.org/&quot;&gt;Apache Lucene&lt;/a&gt; 之上，接入 Elasticsearch 是必然之选。本文是我学习使用 Elasticsearch 检索的笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/08/elasticsearch-search/9a3accb9-0da1-47e4-ad58-428370464af6.jpg&quot;&gt;
    
    </summary>
    
      <category term="Lucene" scheme="https://www.fanhaobai.com/categories/Lucene/"/>
    
    
      <category term="Elasticsearch" scheme="https://www.fanhaobai.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用Charles抓包</title>
    <link href="https://www.fanhaobai.com/2017/07/charles.html"/>
    <id>https://www.fanhaobai.com/2017/07/charles.html</id>
    <published>2017-07-22T01:58:18.000Z</published>
    <updated>2024-04-18T08:38:12.652Z</updated>
    
    <content type="html"><![CDATA[<p>Charles 是在 Mac 下常用的截取网络封包的工具（Win 环境也已支持），在移动端开发过程中，我们常需要截取网络包分析服务端的通讯协议。Charles 将自己设置成系统的网络访问代理服务器，不仅可以提供 SSL 代理，还支持流量的控制、支持重发网络请求、支持修改网络请求参数、支持网络响应截获并动态修改。<br><img src="//www.fanhaobai.com/2017/07/charles/0dc3e6f6-250e-4172-af30-83b91cfddf76.png"><span id="more"></span></p><h3 id="安装Charles"><a href="#安装Charles" class="headerlink" title="安装Charles"></a>安装Charles</h3><p>从 Charles 的 <a href="https://www.charlesproxy.com/download/">官方网站</a> 下载最新的安装包，下载晚完成安装即可。</p><p>Charles 是付费软件，当然免费状态也可以使用。可以使用如下信息完成注册：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Registered Name: https://zhile.io</span><br><span class="line">License Key: 48891cf209c6d32bf4</span><br></pre></td></tr></table></figure><p>如果注册失败，可以尝试 <a href="http://charles.iiilab.com/">这种方法</a>。</p><h3 id="设置成系统代理服务器"><a href="#设置成系统代理服务器" class="headerlink" title="设置成系统代理服务器"></a>设置成系统代理服务器</h3><p>由于 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以第一步是需要将 Charles 设置成系统的代理服务器。</p><p>启动 Charles 后，菜单中的 “Proxy” -&gt; “Windos Proxy（或者Mac OS X Proxy）”， 来将 Charles 设置成系统代理。如下所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/0a6e7c09-6361-4e9f-9bc4-778bb7656bc4.png"></p><p>配置后，就可以在界面中看到截取的网络请求。但是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置， 所以需要将 Chrome 和 Firefox 设置成使用系统的代理服务器，或者直接设置成地址<code>127.0.0.1：8888</code>。</p><p>如果 Chrome 已安装了 Host Switch Plus 插件，则需要暂时关闭。</p><p><img src="//www.fanhaobai.com/2017/07/charles/4e97e097-b884-4db0-b07f-292a78a77544.png"></p><h3 id="过滤网络请求"><a href="#过滤网络请求" class="headerlink" title="过滤网络请求"></a>过滤网络请求</h3><p>一般情况下，我们只需要监听指定服务器上发送的请求，可以使用如下办法解决：</p><ul><li><p>方式1：在主界面 “Sequence” -&gt; “Filter” 栏位置输入需要过滤的关键字即可。例如输入<code>fanhaobai</code>，则过滤输出只包含 fanhaobai 信息的请求。</p></li><li><p>方式2：在 Charles 的菜单栏选择 “Proxy” -&gt; ”Recording Settings”，并选择 Include 栏，添加一条永久过滤规则，主要填入需要截取网站的协议、主机地址、端口号。</p><p><img src="//www.fanhaobai.com/2017/07/charles/647b22ba-8441-45db-8386-1c64b6ca520e.png"></p></li><li><p>方式3：右击需要过滤的网络请求，选择 “Focus” 选项即可。</p></li></ul><p>方式 1 和方式 3 可以快速地过滤临时性网络请求，使用方式 2 过滤永久性网络请求。</p><h3 id="截取移动设备网络包"><a href="#截取移动设备网络包" class="headerlink" title="截取移动设备网络包"></a>截取移动设备网络包</h3><p>Charles 除了可以截取本地的网络包，作为代理服务器后，同样可以截取移动设备的网络请求包。</p><h4 id="设置Charles"><a href="#设置Charles" class="headerlink" title="设置Charles"></a>设置Charles</h4><p>截取移动设备网络包时，需要先将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy” -&gt; ”Proxy Settings”，填入默认代理端口 8888，且勾选 “Enable transparent HTTP proxying” 就完成了设置。如下图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/28fe758a-e2c2-48ab-8132-f26f438e79e0.png"></p><h4 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h4><p>首先，通过 Charles 的顶部菜单的 “Help” -&gt; ”Local IP Address” 获取本地电脑的 IP 地址，例如我的本机电脑为<code>192.168.1.102</code>。</p><p>在 iPhone 的 ”设置“ -&gt; ”无线局域网“ 中，对当前局域网连接设置 HTTP 代理（端口默认为 8888），如下图：</p><p><img src="//www.fanhaobai.com/2017/07/charles/bfd83ef1-1e78-4bbb-aa0d-50e4591ca04e.jpg"></p><p>设置完成后，打开 iPhone 的任意程序，在 Charles 就可以弹出连接确认窗口，点击 ”Allow” 即可。</p><p><img src="//www.fanhaobai.com/2017/07/charles/d40b7bd9-3b1d-4901-816a-dd706909c48b.png"></p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>在 Android 上操作同 iPhone，只是某些系统设置方式不一致而已。</p><h3 id="截取-Https-包"><a href="#截取-Https-包" class="headerlink" title="截取 Https 包"></a>截取 Https 包</h3><p>如果需要截取并分析 Https 协议信息，需要安装 Charles 的 CA 证书。</p><h4 id="本地通信信息"><a href="#本地通信信息" class="headerlink" title="本地通信信息"></a>本地通信信息</h4><p>点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，即可完成证书的安装。如下图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/7af98999-1276-478b-a443-b92b8986b788.png"></p><p>建议将证书安装在 ”受信任的根证书颁发机构“ 存储区。</p><p>特别说明，即使安装完证书后，Charles 默认是不会截取 Https 网络通讯的信息。对于需要截取分析站点 Https 请求，可以右击请求记录，选择 SSL proxy 即可，如图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/255707e0-725c-4e8e-932a-34b870031e40.png"></p><h4 id="移动设备的通信信息"><a href="#移动设备的通信信息" class="headerlink" title="移动设备的通信信息"></a>移动设备的通信信息</h4><p>如果在 iPhone 或 Android 机器上截取 Https 协议的通讯内容，需要手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后按照 Charles 的提示的安装教程安装即可。如下图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/1bfe09f1-69a9-4b43-a39c-3d26e067d27a.png"></p><p><img src="//www.fanhaobai.com/2017/07/charles/d97cf8fa-5e7f-4c3e-905f-ec0ed12038dd.png"></p><p>在上述 <a href="#">截取移动设备网络包</a> 为手机设置好代理后，手机浏览器中访问地址<code>http://chls.pro/ssl</code>，即可打开证书安装的界面。安装完证书后，就可以截取手机上的 Https 通讯内容了。注意，同样需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p><p>如果  SSL proxy 后出现如下错误：</p><p><img src="//www.fanhaobai.com/2017/07/charles/1fb741c8-4170-47fa-ad0f-1929ae7857fd.png"></p><p>可将证书设置为信任即可，例如 iPhone 下 “设置” -&gt; “通用” -&gt; “关于本机” -&gt; “证书信任设置” 下：</p><p><img src="//www.fanhaobai.com/2017/07/charles/fab69a4a-17c1-4944-81c9-255ff33ff815.png"></p><h3 id="模拟慢请求"><a href="#模拟慢请求" class="headerlink" title="模拟慢请求"></a>模拟慢请求</h3><p>在做 App 开发调试时，经常需要模拟慢请求或者高延迟网络，以测试应用在网络异常情况变现是否正常，而这使用 Charles 就轻松帮我们完成。</p><p>在 Charles 的菜单上，选择 “Proxy” -&gt; ”Throttle Setting” 项，在弹出的窗口中，可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/41bdb338-fcba-4d56-ac55-207aed5560b4.png"></p><p>当然可以通过 “Only for selected hosts” 项，只模拟指定站点的慢请求。</p><h3 id="修改请求内容"><a href="#修改请求内容" class="headerlink" title="修改请求内容"></a>修改请求内容</h3><p>有时为了调试服务端的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需在该网络请求上点击右键，选择 “Compose”，即可创建一个可编辑的网络请求。</p><p>我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/25753d81-3257-43b7-8f35-89436d888974.png"></p><h3 id="修改响应内容"><a href="#修改响应内容" class="headerlink" title="修改响应内容"></a>修改响应内容</h3><p>有候为方便我们调试一些特殊情况，需要服务器返回一些特定的响应内容。例如数据为空或者数据异常的情况，部分耗时的网络请求超时的情况等。通常让服务端配合，构造相应的数据显得会比较麻烦，这个时候，使用 Charles 就可以满足我们的需求。</p><p>根据不同的场景需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p><ul><li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li><li>Rewrite 功能适合对网络请求进行一些正则替换。</li><li>Breakpoints 功能适合做一些临时性的修改。</li></ul><h4 id="Map功能"><a href="#Map功能" class="headerlink" title="Map功能"></a>Map功能</h4><p>Charles 的 Map 功能分 Map Remote 和 Map Local 两种。Map Remote 是将指定的网络请求重定向到另一个网址请求地址，而 Map Local 是将指定的网络请求重定向到本地文件。在 Charles 的菜单中，选择 “Tools” -&gt; ”Map Remote” 或 “Map Local” ，即可进入到相应功能的设置页面。</p><p>对于 Map Remote 功能（选中 Enable Map Remote），我们需要填写网络重定向的源地址和目的地址，对于其他非必需字段可以留空。下图是一个示例，我将测试环境<code>t.fanhaobai.com</code>的请求重定向到了生产环境<code>www.fanhaobai.com</code>。</p><p><img src="//www.fanhaobai.com/2017/07/charles/fe7c1302-4101-4882-ae0f-a3d395bdb960.png"></p><p>对于 Map Local 功能（选中 Enable Map Local），我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地并稍加修改，成为我们的目标映射文件。</p><p><img src="//www.fanhaobai.com/2017/07/charles/dfa1e7c1-9072-4e33-836a-cdd62709af67.png"></p><h4 id="Rewrite功能"><a href="#Rewrite功能" class="headerlink" title="Rewrite功能"></a>Rewrite功能</h4><p>Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。</p><p>例如，将服务端返回的<code>www.fanhaobai.com</code>全部替换为<code>www.baidu.com</code>，如下：</p><p><img src="//www.fanhaobai.com/2017/07/charles/4ccdcd7b-0b54-43df-bf09-4887edf7800e.png"></p><p>将响应中的<code>www.fanhaobai.com</code>全部替换为<code>www.baidu.com</code>。于是在 “Tools” -&gt; “Rewrite” 下配置如下的规则：</p><p><img src="//www.fanhaobai.com/2017/07/charles/b037c6ae-8a8a-45fd-9a1f-b3628db8b8d6.png"></p><p>选中 “Enable Rewrite”  启用 Rewrite 功能 ，响应如下：</p><p><img src="//www.fanhaobai.com/2017/07/charles/c8e71602-2bde-4b7a-850f-bde0b0a17084.png"></p><h4 id="Breakpoints功能"><a href="#Breakpoints功能" class="headerlink" title="Breakpoints功能"></a>Breakpoints功能</h4><p>上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，我们最好使用 Breakpoints 功能。</p><p>在需要打断点的请求上右击并选择 “Breakpoints”，重新请求该地址，可以发现客户端被挂起，Charles 操作界面如下：</p><p><img src="//www.fanhaobai.com/2017/07/charles/73350a4e-816d-4f91-91d5-2a6d1104c722.png"></p><p>此时可以修改请求信息，但这里只修改响应信息，故点击 “Execute” 后选择 “Edit Response” 项，修改 title 为<code>fanhaobai.com</code>，如下：</p><p><img src="//www.fanhaobai.com/2017/07/charles/0fa6ff3f-c1f8-4179-b458-b21cc63e02c2.png"></p><p>继续点击 “Execute” ，可看见响应的 title 已经变为<code>fanhaobai.com</code>。</p><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。在想压测的网络请求上右击，然后选择 “Repeat Advanced” 项，如下所示：</p><p><img src="//www.fanhaobai.com/2017/07/charles/b0875e59-e049-4b62-93f7-02311d0d47e7.png"></p><p>这样我们就可以在上图的对话框中，选择压测的并发线程数以及压测次数，确定之后，即可开始压力测试了。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。</p><p><img src="//www.fanhaobai.com/2017/07/charles/d3193cee-783b-43c0-99c3-ac98ec52aaa6.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Charles 是在 Mac 下常用的截取网络封包的工具（Win 环境也已支持），在移动端开发过程中，我们常需要截取网络包分析服务端的通讯协议。Charles 将自己设置成系统的网络访问代理服务器，不仅可以提供 SSL 代理，还支持流量的控制、支持重发网络请求、支持修改网络请求参数、支持网络响应截获并动态修改。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/07/charles/0dc3e6f6-250e-4172-af30-83b91cfddf76.png&quot;&gt;
    
    </summary>
    
      <category term="工具" scheme="https://www.fanhaobai.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.fanhaobai.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>什么是B-树？</title>
    <link href="https://www.fanhaobai.com/2017/07/b-.html"/>
    <id>https://www.fanhaobai.com/2017/07/b-.html</id>
    <published>2017-07-08T06:56:57.000Z</published>
    <updated>2024-04-18T08:38:12.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://mp.weixin.qq.com/s/raIWLUM1kdbYvz0lTWPTvw">http://mp.weixin.qq.com/s/raIWLUM1kdbYvz0lTWPTvw</a></p></blockquote><p><img src="//www.fanhaobai.com/2017/07/b-/76ee8b6f-b653-416b-bb44-99101a6fc40f.jpg"><span id="more"></span></p><p><img src="//www.fanhaobai.com/2017/07/b-/059c4183-9028-4abe-89c6-c12d9393d36e.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/3adf96f5-9791-44ff-b423-26cb34741be1.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/0986b67c-7e37-4411-b057-9dbbf20930bb.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/6137cf60-4db5-4e63-ba41-cea1dfe1de61.jpg"></p><p>————————————</p><p><img src="//www.fanhaobai.com/2017/07/b-/2cd5bcec-3f3f-4ae7-959e-071d07ec1c3b.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/9ea9ea0e-d6a6-42ae-aace-5a1661ff9cc4.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/6b29f560-e192-4558-a399-5e125ca893e0.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/f2725bec-63b0-11e7-907b-a6006ad3dba0.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/53719e92-49f8-450b-9ffc-f2cfbb96295a.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/a2c81ffd-01f9-4c73-8b03-2aa46d8edf6f.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/6421f60a-6bd4-4c11-bd00-e6864b6c2f7c.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/1c9bb154-d47b-49ad-a33b-51a74021eb15.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/fb9a98ce-0b30-485b-af53-3b6c780aa299.jpg"></p><p>————————————</p><p><img src="//www.fanhaobai.com/2017/07/b-/20763cbb-12b3-4e9a-a00b-1759e1356231.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/14f6e592-ee53-42d7-b06b-050c595b2826.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/2ad346da-5243-492e-b30d-560a744c622e.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/c5a8411b-2233-47b7-9695-c99bf231fcdd.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/d2135b8d-3cf3-4a54-93af-695145ffa485.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/5f468cb8-857c-4d67-8772-d86ee9d9340d.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/e656282b-2e69-4c66-8351-9b4c9eaff541.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/6368f5b1-d08e-488c-b23e-a9cf783ea481.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/19301a61-5d3f-422f-b66e-4853fd5c7caf.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/180daa1d-b025-423a-89f5-0c5cd94af1e9.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/78e65b5a-c9c1-4e19-841b-a06879f70032.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/42085b9b-c60f-4d6b-bce4-056bb60f9b82.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/86fe22ab-fd0b-4ca0-a846-b5dc701c6581.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/855e1037-3a90-49bb-8310-d9e3911962cf.jpg"></p><p>二叉查找树的结构：</p><p><img src="//www.fanhaobai.com/2017/07/b-/e8fd2614-0fc7-432a-b9fd-00ed5f24f3a3.jpg"></p><p>第 1 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/d710d2fe-ecee-458f-b478-65b32bedc7d4.jpg"></p><p>第 2 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/842c3607-8a20-405f-8a16-12b26ab75b8d.jpg"></p><p>第 3 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/9ad3c9a8-a874-4a25-a51d-25c8bb440b6c.jpg"></p><p>第 4 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/60f11fd4-1c37-44a9-8d1c-f1a194559e37.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/b98ea743-190d-449b-9253-b5e036d6d5ee.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/5ec15194-a2fa-4431-83ba-53b3ba63be8f.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/d2ae3188-0d70-4e2e-b1b5-6df2971185cf.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/12e9c3d2-280c-41ff-b5fd-67d79d884f3a.jpg"></p><p>下面来具体介绍一下 B- 树（Balance Tree），一个 m 阶的 B 树具有如下几个 <strong>特征</strong> ：</p><p>1.根结点至少有两个子女。<br>2.每个中间节点都包含 k-1 个元素和 k 个孩子，其中 m/2 &lt;= k &lt;= m。<br>3.每一个叶子节点都包含 k-1 个元素，其中 m/2 &lt;= k &lt;= m。<br>4.所有的叶子结点都位于同一层。<br>5.每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。</p><p><img src="//www.fanhaobai.com/2017/07/b-/a73a2881-7837-4b23-9c39-b6044dc0e26c.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/a9c34b2b-a73c-4611-a05a-a67a0b3e63c5.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/ba56f5d6-e9e7-41bf-a9d7-3045cbb1f114.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/87a0a1d6-fa9e-4a1f-9e9a-6c07ec5c5509.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/070ad465-7638-4f4c-8c4d-ef3e7ceff2a6.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/05afc638-3c1a-4020-98bd-78fa0ba6826d.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/8438d6ce-bd67-4d4e-9dd4-06493d0ef144.jpg"></p><p>第 1 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/4b90f113-fa96-4189-8804-73e8b1ff682e.jpg"></p><p>在内存中定位（和 9 比较）：</p><p><img src="//www.fanhaobai.com/2017/07/b-/c2045edc-f98d-43b1-a21e-d0dbecf39c4b.jpg"></p><p>第 2 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/d1c0b5a6-f9c2-4a84-9a0f-dc643fbaf0ef.jpg"></p><p>在内存中定位（和 2，6 比较）：</p><p><img src="//www.fanhaobai.com/2017/07/b-/9628d43f-4569-4716-a1e4-ce23931b96f7.jpg"></p><p>第 3 次磁盘 IO：</p><p><img src="//www.fanhaobai.com/2017/07/b-/bca1c1cc-587d-4b6c-be28-9f92650ad1e5.jpg"></p><p>在内存中定位（和 3，5 比较）：</p><p><img src="//www.fanhaobai.com/2017/07/b-/84af8a44-4f88-450b-9286-eec57e8ac003.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/112d602b-917a-4a11-a227-f3355bcc5d95.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/e63df136-c6f7-4cc9-a1f9-c73ddc635e2e.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/bf42c5e0-2a17-4e30-8e3d-8689f5130652.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/bc424688-fa4c-4afd-91a9-67a0be2a08ad.png"></p><p><img src="//www.fanhaobai.com/2017/07/b-/44f988cf-7a51-4863-88f0-766e99fb9f4e.jpg"></p><p>自顶向下查找 4 的节点位置，发现 4 应当插入到节点元素 3，5 之间。</p><p><img src="//www.fanhaobai.com/2017/07/b-/454f21ea-4f34-4556-9641-cee74178b34a.jpg"></p><p>节点 3，5 已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点 9 是单元素节点，可以升级为两元素节点。于是 <strong>拆分</strong> 节点 3，5 与节点 2，6，让根节点 9 升级为两元素节点 4，9。节点 6 独立为根节点的第二个孩子。</p><p><img src="//www.fanhaobai.com/2017/07/b-/76ee8b6f-b653-416b-bb44-99101a6fc40f.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/520badf6-ab99-4bbb-8c8a-5962900b4a51.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/82d68b72-0dd0-4371-a8e7-a66dcf80a0e0.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/2c252095-aafa-4f84-8d76-d4c0285d209f.jpg"></p><p>自顶向下查找元素 11 的节点位置。</p><p><img src="//www.fanhaobai.com/2017/07/b-/d242bb97-31cc-41a9-9820-39947f1291b4.jpg"></p><p>删除 11 后，节点 12 只有一个孩子，不符合 B 树规范。因此找出 12,13,15 三个节点的中位数 13，取代节点 12，而节点 12 自身下移成为第一个孩子。（这个过程称为 <strong>左旋</strong>）</p><p><img src="//www.fanhaobai.com/2017/07/b-/ef0015d5-7c1f-4af4-a254-a899753a4126.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/0fde9df2-c850-47d8-949d-398b8f3e831f.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/d36da4d2-723c-4860-a1ae-06ec45c8bbae.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/9b9ee0cb-50a2-418d-bcaf-4e30707bd886.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/1f161fac-1327-4649-a31e-33bc5efd693a.jpg"></p><p><img src="//www.fanhaobai.com/2017/07/b-/397c217f-b0bf-4a11-84b4-34b82d2c6642.jpg"></p><p><strong>漫画算法系列 <a href="#">»</a></strong></p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560419&idx=1&sn=535073d4d69cf7fc45074ccb8c25ba1e&chksm=f1fee120c68968367597137515f21ef8d7a8ab68c9f4fce051dae5f2631afdc48ec11a30dd0e&scene=21#wechat_redirect">漫画算法：最小栈的实现</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560448&idx=1&sn=b4ca3d01a438fac78be4077f270974ca&chksm=f1fee143c6896855179eff005164be47c7c662d4c8badf571a79c4acd9e2aca9fd84839ca093&scene=21#wechat_redirect">漫画算法：判断 2 的乘方</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560411&idx=1&sn=2e655df46f082a50a4657a40f292d63a&chksm=f1fee118c689680eba2b9ba965780387aeafd08a72eecb2c748eece85b77631b0a5511f2833b&scene=21#wechat_redirect">漫画算法：找出缺失的整数</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560408&idx=1&sn=db553ce9deedf38c44841e16cb095d2e&chksm=f1fee11bc689680d83ff71d40dc191ee9899b8e5ef4bf9b98001ebb4daf13059a5961586ea1a&scene=21#wechat_redirect">漫画算法：辗转相除法是什么鬼？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561168&idx=1&sn=9d1c6f7ba6d651c75399c4aa5254a7d8&chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&scene=21#wechat_redirect">漫画算法：什么是动态规划？（整合版）</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561205&idx=1&sn=3c4feb6339e00e13bdd8cc6a11eb0304&chksm=f1feec36c689652085b1b89acd6ca07316140f1c7478249e4b251c204b6cf3a5bb276b0275be&scene=21#wechat_redirect">漫画算法：什么是跳跃表？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://mp.weixin.qq.com/s/raIWLUM1kdbYvz0lTWPTvw&quot;&gt;http://mp.weixin.qq.com/s/raIWLUM1kdbYvz0lTWPTvw&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/07/b-/76ee8b6f-b653-416b-bb44-99101a6fc40f.jpg&quot;&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.fanhaobai.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>按照奖品概率分布抽奖的实现</title>
    <link href="https://www.fanhaobai.com/2017/05/draw-by-prob.html"/>
    <id>https://www.fanhaobai.com/2017/05/draw-by-prob.html</id>
    <published>2017-05-18T04:20:23.000Z</published>
    <updated>2024-04-18T08:38:12.643Z</updated>
    
    <content type="html"><![CDATA[<p>需求：首先用户通过以一定方式（好友点赞等）开启抽奖资格，然后按照用户 100% 中奖概率进行抽奖，且系统的发放奖品需要按照各个奖品整体的期望中奖比例来进行分布，最后用户抽中奖品调用第三方发放接口发放奖品并记录保存，另有些奖品存在发放数量限制。<span id="more"></span></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>整个抽奖过程是同步进行，由于前置了开启抽奖资格保护，会避免用户集中进行抽奖，故系统并发量并不会太高。突出的问题主要有以下几个：</p><p>1）由于同步调用第三方接口发放奖品，奖品可能发放失败；<br>2）有一些奖品存在数量限制，可能已经发放完；<br>3）系统要求用户 100% 抽中奖品；<br>4）系统要求各个奖品总的发放情况符合预期的比例分布；</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对以上突出问题，给出针对的解决办法。</p><ul><li>问题1：采用带有次数限制的重试机制，降低奖品发放接口发放失败情况，同时捕获异常来应对接口返回异常信息。重试机制失败则自动重新进行一轮按概率抽奖，依次类推并做重发次数限制；</li><li>问题2：奖品数量在奖品发放端进行限制。因为系统存在数量限制的奖品期望发放比例较低，每轮抽中这些奖品概率也较低，所以可以采用若奖品已发放完，则自动重新进行一轮按概率抽奖，依次类推并做重发次数限制；</li><li>问题3：尽管有发放接口的重试机制和自动多轮按概率抽奖机制，也可能存在抽取奖品失败的情况，这里采用一种特定奖品作为兜底的办法，当然兜底奖品也有重试机制，使用户抽中概率接近 100%；</li><li>问题4：因为重试机制失败或者抽取到已经发送完毕的奖品时，会自动重新进行下一轮抽奖，由于规则也是按照概率抽奖，所以不影响各个奖品总的比例分布情况；</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="按概率抽奖"><a href="#按概率抽奖" class="headerlink" title="按概率抽奖"></a>按概率抽奖</h3><p>核心思想是采用随机函数 mt_rand() 来模拟用户抽奖。</p><p>奖品信息如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有奖品信息</span></span><br><span class="line"><span class="variable">$allPrizes</span> = [</span><br><span class="line">  <span class="string">&#x27;jd&#x27;</span>    =&gt; [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;京东券&#x27;</span>, <span class="string">&#x27;probability&#x27;</span> =&gt; <span class="number">30</span>],</span><br><span class="line">  <span class="string">&#x27;film&#x27;</span>  =&gt; [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;电影票&#x27;</span>, <span class="string">&#x27;probability&#x27;</span> =&gt; <span class="number">10</span>],</span><br><span class="line">  <span class="string">&#x27;tb&#x27;</span>    =&gt; [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;淘宝券&#x27;</span>, <span class="string">&#x27;probability&#x27;</span> =&gt; <span class="number">60</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>方式一</strong> </p><p>这是一个比较中规中矩的方式，<em>主要思想</em> 是：将所有奖品按照期望比例分布，一段一段小区间分布到 1<del>100 这个区间，然后随机一个 1</del>100 的随机数，如果这个随机数落在某段区间，则表示抽取对应区间的奖品。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1            30     10                    60</span><br><span class="line">1|-----------|------|----------------------|100</span><br><span class="line">     京东券    电影票          淘宝券       </span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照概率抽取一个奖品, 返回奖品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array      $prizes     所有奖品的probability概率总和应该为100</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">randPrize</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$prizes</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//总概率基数</span></span><br><span class="line">    <span class="variable">$totalProbability</span> = <span class="title function_ invoke__">array_sum</span>(<span class="title function_ invoke__">array_column</span>(<span class="title function_ invoke__">array_values</span>(<span class="variable">$prizes</span>), <span class="string">&#x27;probability&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">100</span> !== <span class="variable">$totalProbability</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;invalid probability config&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$rand</span> = <span class="title function_ invoke__">mt_rand</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="variable">$cursor</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$id</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">list</span>(<span class="variable">$key</span>, <span class="variable">$item</span>) = <span class="title function_ invoke__">each</span>(<span class="variable">$prizes</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rand</span> &gt; <span class="variable">$cursor</span> &amp;&amp; <span class="variable">$rand</span> &lt;= <span class="variable">$cursor</span> + <span class="variable">$item</span>[<span class="string">&#x27;probability&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable">$id</span> = <span class="variable">$key</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$cursor</span> += <span class="variable">$item</span>[<span class="string">&#x27;probability&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$prizes</span>[<span class="variable">$id</span>][<span class="string">&#x27;probability&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$prizes</span>[<span class="variable">$id</span>] + [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="variable">$id</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>方式二</em></p><p>该方式如果直接看代码比较难理解。主要思想：按照给定顺序（按照奖品配置顺序），先后一个一个抽取奖品，直到抽中一个奖品为止， 抽中后续奖品的概率的前提是没有抽中当前奖品，多次抽取概率应该相乘。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">次数       奖品       概率    基数        中奖概率                     未中奖概率</span><br><span class="line"> 1        京东券      30     100         30/100                      70/100</span><br><span class="line"> 2        电影票      10      70      (70/100)*(10/70)           (70/100)*(60/70)</span><br><span class="line"> 3        淘宝券      60      60     (70/100)*(60/70)*(1)       1-(70/100)*(60/70)*(1)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照概率抽取一个奖品, 返回奖品, </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array    $prizes    参与抽奖的奖品信息, 所有奖品的probability概率总和应该为100</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">randPrize</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$prizes</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//总概率基数</span></span><br><span class="line">    <span class="variable">$totalProbability</span> = <span class="title function_ invoke__">array_sum</span>(<span class="title function_ invoke__">array_column</span>(<span class="title function_ invoke__">array_values</span>(<span class="variable">$prizes</span>), <span class="string">&#x27;probability&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">100</span> !== <span class="variable">$totalProbability</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;invalid probability config&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以考虑按照概率倒序排序</span></span><br><span class="line">    <span class="comment">/*uasort($prizes, function(array $a, array $b) &#123;</span></span><br><span class="line"><span class="comment">        if ($a[&#x27;probability&#x27;] == $b[&#x27;probability&#x27;]) return 0;</span></span><br><span class="line"><span class="comment">        return $a[&#x27;probability&#x27;] &gt; $b[&#x27;probability&#x27;] ? -1 : 1;</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    <span class="comment">//按照奖品顺序依次模拟抽中奖品</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$prizes</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$item</span>) &#123;</span><br><span class="line">        <span class="variable">$rand</span> = <span class="title function_ invoke__">mt_rand</span>(<span class="number">1</span>, <span class="variable">$totalProbability</span>);    <span class="comment">//本次抽奖的基数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rand</span> &lt;= <span class="variable">$item</span>[<span class="string">&#x27;probability&#x27;</span>]) &#123;      <span class="comment">//表示抽中</span></span><br><span class="line">            <span class="variable">$id</span> = <span class="variable">$key</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$totalProbability</span> -= <span class="variable">$item</span>[<span class="string">&#x27;probability&#x27;</span>];  <span class="comment">//后续奖品基数减去抽过的概率, 因为抽中后一个奖品的前提是抽不中前一些奖品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$prizes</span>[<span class="variable">$id</span>][<span class="string">&#x27;probability&#x27;</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$prizes</span>[<span class="variable">$id</span>] + [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="variable">$id</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽中奖品"><a href="#抽中奖品" class="headerlink" title="抽中奖品"></a>抽中奖品</h3><p>主要包含重试机制、自动重新一轮按照概率抽奖机制、兜底机制的实现。</p> <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array   $allPrizes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"><span class="variable">$allPrizes</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$tryTimes</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$outPrize</span> = [];</span><br><span class="line">    <span class="variable">$prize</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果抽到有数量限制奖品且奖品也已经抽完或者抽取失败, 最多抽奖次数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$tryTimes</span> &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="variable">$tryTimes</span>++;</span><br><span class="line">        <span class="comment">//按照概率抽取</span></span><br><span class="line">        <span class="variable">$prize</span> =  <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">randPrize</span>(<span class="variable">$allPrizes</span>);</span><br><span class="line">        <span class="comment">//模拟发放奖品方法</span></span><br><span class="line">        <span class="variable">$outPrize</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getOnePrize</span>(<span class="variable">$prize</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">        <span class="comment">//抽中退出</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$outPrize</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;尝试按照概率抽取次数:&#x27;</span> , <span class="variable">$tryTimes</span>, PHP_EOL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多次抽奖都抽中已经抽完的奖品, 则用兜底奖品兜底</span></span><br><span class="line">    <span class="variable">$tryTimes</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="variable">$outPrize</span> &amp;&amp; <span class="variable">$tryTimes</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="variable">$tryTimes</span>++;</span><br><span class="line"><span class="variable">$prize</span> = <span class="variable">$allPrizes</span>[<span class="string">&#x27;default&#x27;</span>] + [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">        <span class="variable">$outPrize</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getOnePrize</span>(<span class="string">&#x27;default&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;兜底抽取次数:&#x27;</span> , <span class="variable">$tryTimes</span>, PHP_EOL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$outPrize</span>) &#123;</span><br><span class="line">        <span class="comment">//兜底失败, 可能是券达到上限, 或者接口down了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//合并奖品信息</span></span><br><span class="line">        <span class="variable">$outPrize</span> = <span class="variable">$outPrize</span> + <span class="variable">$prize</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$outPrize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p><em>抽样方法</em></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params"><span class="variable">$all</span>, <span class="variable">$times</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$out</span> = [];</span><br><span class="line">    <span class="variable">$count</span> = <span class="variable">$times</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$times</span> &gt; <span class="number">1000000</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$times</span>) &#123;</span><br><span class="line">        <span class="variable">$times</span>--;</span><br><span class="line">        <span class="variable">$prize</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">draw</span>(<span class="variable">$all</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$out</span>[<span class="variable">$prize</span>[<span class="string">&#x27;id&#x27;</span>]])) &#123;</span><br><span class="line">            <span class="variable">$out</span>[<span class="variable">$prize</span>[<span class="string">&#x27;id&#x27;</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$out</span>[<span class="variable">$prize</span>[<span class="string">&#x27;id&#x27;</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">array_walk</span>(<span class="variable">$out</span>, function(&amp;<span class="variable">$value</span>, <span class="variable">$key</span>) <span class="keyword">use</span> ($<span class="title">count</span>) &#123;</span><br><span class="line">        $<span class="title">value</span> = ($<span class="title">value</span> / $<span class="title">count</span> * 100);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">ksort</span>(<span class="variable">$out</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>抽样结果</em></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望概率</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;film&quot;</span>] =&gt; <span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line">  [<span class="string">&quot;jd&quot;</span>] =&gt; <span class="keyword">int</span>(<span class="number">30</span>)</span><br><span class="line">  [<span class="string">&quot;tb&quot;</span>] =&gt; <span class="keyword">int</span>(<span class="number">60</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽样2000次</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;film&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;9.8&quot;</span></span><br><span class="line">  [<span class="string">&quot;jd&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;31.35&quot;</span></span><br><span class="line">  [<span class="string">&quot;tb&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;58.85&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">尝试按照概率抽取次数: <span class="number">3</span></span><br><span class="line">兜底抽取次数: <span class="number">0</span></span><br><span class="line">抽中奖品为：<span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">20</span>) <span class="string">&quot;淘宝50元消费券&quot;</span></span><br><span class="line">  [<span class="string">&quot;content&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">12</span>) <span class="string">&quot;WD84-3233-21&quot;</span></span><br><span class="line">  [<span class="string">&quot;id&quot;</span>] =&gt; <span class="keyword">string</span>(<span class="number">2</span>) <span class="string">&quot;tb&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需求：首先用户通过以一定方式（好友点赞等）开启抽奖资格，然后按照用户 100% 中奖概率进行抽奖，且系统的发放奖品需要按照各个奖品整体的期望中奖比例来进行分布，最后用户抽中奖品调用第三方发放接口发放奖品并记录保存，另有些奖品存在发放数量限制。
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求非负数组元素组成的最大字符串</title>
    <link href="https://www.fanhaobai.com/2017/04/array-form-max-string.html"/>
    <id>https://www.fanhaobai.com/2017/04/array-form-max-string.html</id>
    <published>2017-04-03T05:43:56.000Z</published>
    <updated>2024-04-18T08:38:12.643Z</updated>
    
    <content type="html"><![CDATA[<p>问题叙述：将一个非负元素数组中的所有元素排列组合在一起，找出值最大的那个排列情况。例如 [0, 9, 523, 94, 10, 4]，排列组合后值最大数为：9945234100。</p><p><img src="//www.fanhaobai.com/2017/04/array-form-max-string/57f35c24-2eeb-4c68-bf28-0771b11cad34.png" alt="预览图"><span id="more"></span></p><p>本文废话较多，可以直接跳转到 <a href="#%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0">编码实现</a> 部分。</p><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>这是我遇到的一道笔试题。首次遇见我也是很懵，当时我的第一感觉就是排序，但是没有及时理清里面的规律，导致后面并没有解答出此题。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="确定输入值"><a href="#确定输入值" class="headerlink" title="确定输入值"></a>确定输入值</h3><p>该问题描述很简单，也给出了测试用例，需求很明白。但是还需要注意问题背后隐藏的一些问题。</p><p>可确定输入的情况大致为：</p><ul><li> 数组元素都为非负数，但可能为 0；</li><li> 数组长度并没有确定，长度可能很大。这里假设操作不溢出；</li><li> 数组元素的位数不确定，用例只涉及到 2 位数，需要考虑多位数的情况。这里假设操作不溢出；</li></ul><h3 id="寻找规律"><a href="#寻找规律" class="headerlink" title="寻找规律"></a>寻找规律</h3><p>面试时请教了一下面试官，面试官的思路：</p><blockquote><p>最简单办法就是枚举所有可能的排列组合情况，然后求排列组合后的最大值；再就是寻找组合的规律，满足什么条件的元素排列在前。</p></blockquote><p>当然这只是面试官提供的一些解决思路，付诸于实践还需要探索。在复试前的一天晚上我再次翻出这个问题，并找到了一些思路。</p><p>就拿问题中的用例 [0, 9, 523, 94, 10, 4] 来说，需要找出的结果为：9,94,523,4,10,0（为了方便说明，用”,“分割了数组元素）。</p><p>先将复杂问题简单化处理，首先尝试使用 <strong>排序算法</strong> 来分析过程。分析 9 和 94 的排列，为什么 9 排列在 94 前？<a href="#">那是因为这 2 个数存在 2 种排列情况，既_ 9_94_ 和_ 9_49_，很明显 <em>9_94_ 排列大于 _9_49</em> 排列，所以需要将 9 排列在 94 前，反之则需要交换元素位置</a>。如果采用这样规则处理，是在 2 个元素之间进行枚举排列情况，且单次枚举情况限定在了 2 种，降低了问题的复杂程度并易于编码实现，后续可以直接使用排序方法来多次重复这种 2 个元素之间的单次枚举动作。</p><p>说明：符号“_”为占位符，表示该位置可能还存在其他元素，但不影响当前两个元素的前后排列顺序。后续出现该符号将不再说明。</p><p>总之，我认为该问题是排序问题的一个变种情况，同排序问题不同的是 <strong>比较规则</strong>。这里不是直接比较 2 个元素值大小，而是比较 2 个元素排列组合后值的大小。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>经过上述分析，问题规律已经掌握清楚，这里整理出实现的思路。</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><ul><li> 确定使用排序算法实现；</li><li> 与传统排序不同之处为元素之间的比较规则；</li></ul><h3 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h3><p>使用冒泡排序来说明上述用例的排序过程。</p><p><img src="//www.fanhaobai.com/2017/04/array-form-max-string/65FD0FD202413415D266AC754A75AAF3.png"></p><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>本问题的排序比较规则可以描述为：假设参与比较的两个元素为 A、B（初始时 A 在 B 前，排序结果从左至右为由大到小），比较时如果排列 _A_B_ 小于排列 _B_A_，A 和 B 则交换位置，反之不交换。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="比较规则-1"><a href="#比较规则-1" class="headerlink" title="比较规则"></a>比较规则</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较规则</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   string    $a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   string    $b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$a</span> == <span class="variable">$b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span> . <span class="variable">$b</span> &gt; <span class="variable">$b</span> . <span class="variable">$a</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array    $Arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$Arr</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$length</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$Arr</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$Arr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>, <span class="variable">$change</span> = <span class="literal">true</span>; <span class="variable">$i</span> &lt;= <span class="variable">$length</span> &amp;&amp; <span class="variable">$change</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$change</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="variable">$length</span> - <span class="number">1</span>; <span class="variable">$j</span> &gt; <span class="variable">$i</span> - <span class="number">1</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">cmp</span>(<span class="variable">$Arr</span>[<span class="variable">$j</span> - <span class="number">1</span>], <span class="variable">$Arr</span>[<span class="variable">$j</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable">$temp</span> = <span class="variable">$Arr</span>[<span class="variable">$j</span> - <span class="number">1</span>];</span><br><span class="line">                <span class="variable">$Arr</span>[<span class="variable">$j</span> - <span class="number">1</span>] = <span class="variable">$Arr</span>[<span class="variable">$j</span>];</span><br><span class="line">                <span class="variable">$Arr</span>[<span class="variable">$j</span>] = <span class="variable">$temp</span>;</span><br><span class="line">                <span class="variable">$change</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$Arr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找非零元素数组中所有元素排列组合后的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array     $Arr        待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   string    $method     排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_form_max_str</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$Arr</span>, <span class="variable">$method</span> = <span class="string">&#x27;bubble&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$Arr</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$Arr</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$value</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序算法</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;quick&#x27;</span> :</span><br><span class="line">            <span class="title function_ invoke__">usort</span>(<span class="variable">$Arr</span>, <span class="string">&quot;cmp&quot;</span>);           <span class="comment">//快速排序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bubble&#x27;</span> :</span><br><span class="line">            <span class="variable">$Arr</span> = <span class="title function_ invoke__">bubble_sort</span>(<span class="variable">$Arr</span>);     <span class="comment">//冒泡排序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, <span class="variable">$Arr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>由于 PHP 中 sort 排序函数采用快速排序算法，这里直接使用之。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找非零元素数组中所有元素排列组合后的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   array     $Arr        待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   string    $method     排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_form_max_str</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$Arr</span>, <span class="variable">$method</span> = <span class="string">&#x27;quick&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$Arr</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$Arr</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$value</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序算法</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;quick&#x27;</span> :                   <span class="comment">//快速排序</span></span><br><span class="line">            <span class="title function_ invoke__">usort</span>(<span class="variable">$Arr</span>, <span class="string">&quot;cmp&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bubble&#x27;</span> :</span><br><span class="line">            <span class="variable">$Arr</span> = <span class="title function_ invoke__">bubble_sort</span>(<span class="variable">$Arr</span>);    <span class="comment">//冒泡排序</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;&#x27;</span>, <span class="variable">$Arr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用例测试"><a href="#用例测试" class="headerlink" title="用例测试"></a>用例测试</h2><p>这里只对快速排序方法使用 2  组测试用例并列举如下。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Arr</span> = [<span class="number">20</span>,<span class="number">913</span>,<span class="number">223</span>,<span class="number">91</span>,<span class="number">20</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;数组为[&#x27;</span>, <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$Arr</span>), <span class="string">&#x27;]&#x27;</span>, PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;最大排列组合为：&#x27;</span>, <span class="title function_ invoke__">array_form_max_str</span>(<span class="variable">$Arr</span>), PHP_EOL;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第1组用例</span></span><br><span class="line">数组为[<span class="number">0</span>,<span class="number">9</span>,<span class="number">523</span>,<span class="number">94</span>,<span class="number">10</span>,<span class="number">4</span>]</span><br><span class="line">最大排列组合为：<span class="number">9945234100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2组用例</span></span><br><span class="line">数组为[<span class="number">20</span>,<span class="number">913</span>,<span class="number">223</span>,<span class="number">91</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">最大排列组合为：<span class="number">9191332232020</span></span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>经过深入分析问题的本质，也使得我对与排序算法有了更深入的认识，更算是一个巩固。同时，正是由于我尝试着去解决这个问题，才使得我在后面的复试环节中面试官再次提出相同问题时，给出了一个满意的解决方案。</p><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/12/2017-ziroom-king-1.html#%E9%A2%983">王者编程大赛之一</a> <span>（2017-12-05）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题叙述：将一个非负元素数组中的所有元素排列组合在一起，找出值最大的那个排列情况。例如 [0, 9, 523, 94, 10, 4]，排列组合后值最大数为：9945234100。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/04/array-form-max-string/57f35c24-2eeb-4c68-bf28-0771b11cad34.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>漫画欣赏：Linux内核到底长啥样？</title>
    <link href="https://www.fanhaobai.com/2017/03/linux-core-caricature.html"/>
    <id>https://www.fanhaobai.com/2017/03/linux-core-caricature.html</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.639Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://linux.cn/article-8290-1.html">https://linux.cn/article-8290-1.html</a></p></blockquote><p>今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “<a href="http://turnoff.us/geek/inside-the-linux-kernel/">InSide The Linux Kernel</a>” 。 <a href="http://turnoff.us/">TurnOff.us</a>是一个极客漫画网站，作者Daniel Stori 画了一些非常有趣的关于编程语言、Web、云计算、Linux 相关的漫画。今天解读的便是其中的一篇。<span id="more"></span></p><p>在开始，我们先来看看这幅漫画的全貌！</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/5BD8ACFD12B2952124B8C9A70546A190.png"></p><p>这幅漫画是以一个房子的侧方刨面图来绘画的。使用这样的一个房子来代表 Linux 内核。</p><h2 id="地基"><a href="#地基" class="headerlink" title="地基"></a>地基</h2><p>作为一个房子，最重要的莫过于其地基，在这个图片里，我们也从最下面的地基开始看起：</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/3C27118DE046AD57EF68F273C0D97CEB.png"></p><p>地基（底层）由一排排的文件柜组成，井然有序，文件柜里放置着“文件”——电脑中的文件。左上角，有一只胸前挂着 421 号牌的小企鹅，它表示着 PID（进程 IDProcess ID） 为 421 的进程，它正在查看文件柜中的文件，这代表系统中正有一个进程在访问文件系统。在右下角有一只小狗，它是看门狗 watchdog ，这代表对文件系统的监控。</p><h2 id="一层（地面层）"><a href="#一层（地面层）" class="headerlink" title="一层（地面层）##"></a>一层（地面层）##</h2><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/B3FBAEAC24E48666A4442ADEB950BE21.png"></p><p>看完了地基，接下来我们来看地基上面的一层，都有哪些东西。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/7367932F64D0D54E31AF624CF830E0CF.png"></p><p>在这一层，最引人瞩目的莫过于中间的一块垫子，众多小企鹅在围着着桌子坐着。这个垫子的区域代表进程表。</p><p>左上角有一个小企鹅，站着，仿佛在说些什么这显然是一位家长式的人物，不过看起来周围坐的那些小企鹅不是很听话——你看有好多走神、自顾自聊天的——“喂喂，说你呢，哇塞娃（171），转过身来”。它代表着 Linux 内核中的初始化（init）进程，也就是我们常说的 PID 为 1 的进程。桌子上坐的小企鹅都在等待状态 wait 中，等待工作任务。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/A60AFE2B528D380E7C11D921C5D416D2.png"></p><p>瞧瞧，垫子（进程表）旁边也有一只小狗，它会监控小企鹅的状态（监控进程），当小企鹅们不听话时，它就会汪汪地叫喊起来。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/CDA46D0971D6354391ECC3A88E711EA0.png"></p><p>在这层的左侧，有一只号牌为 1341 的小企鹅，守在门口，门上写着 80，说明这个 PID 为 1341 的小企鹅负责接待 80 端口，也就是我们常说的 HTTP （网站）的端口。小企鹅头上有一片羽毛，这片羽毛大有来历，它是著名的 HTTP 服务器 Apache 的 Logo。喏，就是这只：</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/A92E721F6E3331ECFF02BF6A2E25F43D.png"></p><p>向右看，我们可以看到这里仍有一扇门，门上写着 21，但是，看起来这扇门似乎年久失修，上面的门牌号都歪了，门口也没人守着。看起来这个 21 端口的 FTP 协议有点老旧了，目前用的人也比以前少了，以至于这里都没人接待了。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/C8277CBC07F312F62D0EF9DA9AF01F19.png"></p><p>而在最右侧的一个门牌号 22 的们的待遇就大为不同，居然有一只带着墨镜的小企鹅在守着，看起来好酷啊，它是黑衣人叔叔吗？为什么要这么酷的一个企鹅呢，因为 22 端口是 SSH 端口，是一个非常重要的远程连接端口，通常通过这个端口进行远程管理，所以对这个端口进来的人要仔细审查。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/4AD005B03A39A0F49C0161914325B9C5.png"></p><p>它的身上写着 52，说明它是第 52 个小企鹅。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/DBE8511ECE02DC8ADF849F5062B83433.png"></p><p>在图片的左上角，有一个向下台阶。这个台阶是底层（地基）的文件系统中的，进程们可以通过这个台阶，到文件系统中去读取文件，进行操作。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/0E9D69D32086CA20007062B59842DE24.png"></p><p>在这一层中，有一个身上写着 217 的小企鹅，他正满头大汗地看着自己的手表。这只小企鹅就是定时任务（Crontab），他会时刻关注时间，查看是否要去做某个工作。</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/6ADA68452C7E8F3014CD8D7D68BF3DCD.png"></p><p>在图片的中部，有两个小企鹅扛着管道（PipeLine）在行走，一只小企鹅可以把自己手上的东西通过这个管道，传递给后面的小企鹅。不过怎么看起来前面这种（男？）企鹅累得满头大汗，而后面那只（女？）企鹅似乎游刃有余——喂喂，前面那个，裤子快掉了~</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/14227E17ECB4AD1852B67CAD4DA48F42.png"></p><p>在这一层还有另外的一个小企鹅，它手上拿着一杯红酒，身上写着 411，看起来有点不胜酒力。它就是红酒（Wine）小企鹅,它可以干（执行）一些来自 Windows 的任务。</p><h2 id="跃层"><a href="#跃层" class="headerlink" title="跃层"></a>跃层</h2><p>在一层之上，还有一个跃层，这里有很多不同的屏幕，每个屏幕上写着 TTY（这就是对外的终端）。比如说最左边  tty4 上输入了“fre”——这是想输入“freshmeat…”么 ：d ；它旁边的 tty2 和 tty3 就正常多了，看起来是比较正常的命令；tty7 显示的图形界面嗳，对，图形界面（X Window）一般就在 7 号终端；tty5 和 tty6 是空的，这表示这两个终端没人用。等等，tty1 呢？</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/62707DD3CCEB3B0765227E742A32F72F.png"></p><p>tty（终端）是对外沟通的渠道之一，但是，不是每一个进程都需要 tty，某些进程可以直接通过其他途径（比如端口）来和外部进行通信，对外提供服务的，所以，这一层不是完整的一层，只是个跃层。</p><p>好了，我们有落下什么吗？</p><p><img src="//www.fanhaobai.com/2017/03/linux-core-caricature/A91A34A3B08128E2A06C66E8856585B0.png"></p><p>这小丑是谁啊？</p><p>啊哈，我也不知道，或许是病毒？你说呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://linux.cn/article-8290-1.html&quot;&gt;https://linux.cn/article-8290-1.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “&lt;a href=&quot;http://turnoff.us/geek/inside-the-linux-kernel/&quot;&gt;InSide The Linux Kernel&lt;/a&gt;” 。 &lt;a href=&quot;http://turnoff.us/&quot;&gt;TurnOff.us&lt;/a&gt;是一个极客漫画网站，作者Daniel Stori 画了一些非常有趣的关于编程语言、Web、云计算、Linux 相关的漫画。今天解读的便是其中的一篇。
    
    </summary>
    
      <category term="Linux" scheme="https://www.fanhaobai.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.fanhaobai.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>启用Hexo开源博客系统</title>
    <link href="https://www.fanhaobai.com/2017/03/install-hexo.html"/>
    <id>https://www.fanhaobai.com/2017/03/install-hexo.html</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.638Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间博客一直使用 FireKylin，总体感觉挺好，但是扩展开发和社区是弱点。而 <a href="https://hexo.io/">Hexo</a> 最大特点为纯静态博客系统，同时社区支持也比较好， 故我转而投向了 Hexo 的怀抱。</p><p><img src="//www.fanhaobai.com/2017/03/install-hexo/11b9814d-885a-4aca-9b56-94c3ad908f3f.png" alt="预览图"><span id="more"></span></p><p><img src="//www.fanhaobai.com/2017/03/install-hexo/11b9814d-885a-4aca-9b56-94c3ad908f3f.png" alt="预览图"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Hexo 如官方介绍一样，安装方便快捷。安装前请确保 Node 和 Nginx 环境已经存在，需要安装可以参考 <a href="#">CentOS 6 安装 Node</a> 和 <a href="#">Nginx 安装</a>。</p><p>只需使用如下命令即可安装 Hexo。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-cli -g</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init blog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br></pre></td></tr></table></figure><p>安装完成后目录结构如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── _config.yml             # 主配置文件</span><br><span class="line">├── package.json            # 应用程序的信息</span><br><span class="line">├── scaffolds               # 模版文件夹，新建文章时根据这些模版来生成文章的.md文件</span><br><span class="line">├── source                  # 资源文件夹</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes                  # 主题文件夹</span><br></pre></td></tr></table></figure><p>Hexo 默认启动 4000 端口，使用浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a>，即可看见 Hexo 美丽的面容。</p><p>说明：Nginx 配置站点根目录为<code>public</code>。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>关于 Hexo 更详细的使用技巧，<a href="https://hexo.io/zh-cn/docs/">见官网文档</a>，这里只列举常用的使用方法。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo 提供的可选 <a href="https://hexo.io/themes/">主题</a> 比较多，总有一款你如意的，我这里主题选择了 <a href="https://github.com/fan-haobai/hexo-theme-yilia">hexo-theme-yilia</a>，没有为什么，就是看起来舒服而已，后续相关配置也是基于该主题。</p><p>找到喜欢的一款后，使用如下命令安装主题：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入博客目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> yourblog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆主题源码到hexo的themes文件夹下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/fan-haobai/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure><p>最后一步，在<code>_config.yml</code>配置中启用新主题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theme: yilia</span><br></pre></td></tr></table></figure><p>关于主题的相关配置，参考主题源码中的 README.md 文档。</p><blockquote><p><a href="https://www.fanhaobai.com/">hexo-theme-yilia</a> 主题我做了较多的修改，如果你觉得我的修改也适合你，那么你只要 <a href="https://github.com/fan-haobai/hexo-theme-yilia">pull</a> 下来即可，而不需要再做 <a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E2%80%94%E2%80%94%E9%9D%9E%E5%BF%85%E9%A1%BB">自定义修改</a> 部分的修改。</p></blockquote><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>这里只列举我使用过的方法，更多文章的使用方法，<a href="https://hexo.io/zh-cn/docs/writing.html">见这里</a>。</p><p>1） 新建文章</p><p>当需要写文章时，使用如下命令新建文章，会在资源文件夹中生成与 title 对应的 md 文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure><p>md 文件就是 Markdown 格式的文章表述。格式大致为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---                                      # 分隔符</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下为文章的Markdown内容</span></span><br></pre></td></tr></table></figure><p>文件最上方以<code>---</code>为分隔符，分隔符以上为 Front-matter，用于指定与文章相关的基本信息，分隔符以下才为文章的内容区域。</p><p>2） Front-matter</p><p>Front-matter 内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">layout                 布局</span><br><span class="line">title                  标题</span><br><span class="line">date                   建立日期</span><br><span class="line">updated                更新日期</span><br><span class="line">comments               是否开启文章的评论功能</span><br><span class="line">tags                   标签</span><br><span class="line">categories             分类</span><br><span class="line">permalink              覆盖文章网址</span><br></pre></td></tr></table></figure><p>其中 title、date、tags、categories 这 4 项，在新建文章时需要进行设置，其他项采用默认值即可，不需要在每篇文章中进行设置，故可以将这 4 项基本设置移到模板文件<code>scaffolds\post.md</code>中，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样在新建文章时，就会自动在文章 md 文件中加入 4 项基本设置。</p><p>特别说明，文章中添加了分类和标签后， Hexo 会自动生成分类页面和统计分类的文章数。关于分类和标签的使用，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">categories:           # 分类存在顺序关系</span><br><span class="line">- 语言                 # 1级分类</span><br><span class="line">- PHP                 # 2级分类</span><br><span class="line">- PDO                 # 3级分类    </span><br><span class="line">tags:                 # 标签为无序</span><br><span class="line">- PHP                 # 标签1</span><br><span class="line">- PDO                 # 标签2</span><br></pre></td></tr></table></figure><p>3） 正文</p><p>文章正文使用 Markdown 格式即可，我使用的 Markdown 编辑器主要有 <a href="http://typora.io/">Typora — Win版</a> 和 <a href="https://maxiang.io/">马克飞象 — 网页版</a>。</p><p>Typora 和 马克飞象 的对比：</p><ul><li>Typora 可以在本地使用相对路径预览文章图片，文章中插入图片方法，<a href="#">见配置部分</a>。</li><li>马克飞象在线编辑，可以同印象笔记时时同步，但是想预览图片，就必须是线上图片地址。</li></ul><p>使用编辑器预览编辑完文章后，导出 md 文件替换新建文章时生成的同名 md 文件即可。</p><p>编辑完文章后，使用<code>hexo s</code>命令即可实时预览到文章效果。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>文章的新增和编辑都是在资源文件夹下（<code>source</code>）操作，完成后需要发布才能生成静态文件（<code>public</code>），进而才能通过浏览器直接访问。</p><p>发布更新命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure><p>发布后，<code>public</code>文件夹更新到最新状态，此时即可直接访问。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search">hexo-generator-search</a>，在<code>_config.yml</code>中添加如下配置代码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>安装 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a>，并按照说明配置（atom.xml 的链接写在<code>source/_data/link.json</code>的 social 项中，一般无需更改）</p><h2 id="jsonContent"><a href="#jsonContent" class="headerlink" title="jsonContent"></a>jsonContent</h2><p>安装 <a href="https://github.com/alexbruno/hexo-generator-json-content">hexo-generator-json-content</a>，即可生成所有文章的 json 描述。需在<code>_config.yml</code>中添加如下配置代码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">pages:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">text:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">raw:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">link:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h2><p>安装 <a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap</a>，并在<code>_config.yml</code>中添加如下配置代码：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>在使用 Hexo 生成器时会自动生成最新的站点地图 <a href="/sitemap.xml">sitemap.xml</a>文件。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>更多的配置信息，<a href="https://hexo.io/zh-cn/docs/configuration.html">见这里</a>。我这里只列举比较重要的配置。</p><h2 id="打开文章资源文件夹功能"><a href="#打开文章资源文件夹功能" class="headerlink" title="打开文章资源文件夹功能"></a>打开文章资源文件夹功能</h2><p>在 Hexo 中，相对路径是针对资源文件夹<code>source</code>来讲，所以文章的静态图片应放置于资源文件夹下。</p><p>可以将所有文章的静态图片统一放置于<code>source/images</code>下，但是这样不方便于管理，推荐方法是将每篇文章的图片放置于与该文章同名的资源文件下，然后使用相对路径引用即可。</p><p>在配置文件<code>_config.yml</code>中开启<code>post_asset_folder</code>项，即更改为：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>开启该项配置后，Hexo 将会在你每一次通过<code>hexo new [layout] &lt;title&gt;</code>命令创建新文章时自动创建一个文件名同 md 文件的文件夹。将所有与你的文章有关的资源放在这个关联文件夹中之后，就可以通过相对路径来引用它们。</p><p>写文章时你只需在 Markdown 中插入相对 md 文件的 <strong>相对路径</strong> 的图片即可，<a href="#">hexo-asset-image</a> 自动转化为网站 <strong>绝对路径</strong>。此时，可以直接使用 Hexo 提供的标签<code>asset_img</code>来插入图片，但是这样违背了 Markdown 语法，无法及时预览，不便于编辑文章。</p><p>可以通过以下 Markdown 语法在文章中插入图片，这种方式同时也支持本地 Markdown 编辑器实时预览。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![alt](/post_title/image_name)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">post_title为与文章.md同名的资源文件夹名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">image_name为图片的文件名</span></span><br></pre></td></tr></table></figure><h2 id="URL静态化"><a href="#URL静态化" class="headerlink" title="URL静态化"></a>URL静态化</h2><p>Hexo 默认 URL 地址为<code>year/month/day/title/</code>形式，而这种形式并不友好，需更改为<code>year/month/title.html</code>形式。这里我已经将<code>source</code>目录下的 md 文件按<code>year/month</code>手动归档了，所以 Hexo 发布时只需要<code>title.html</code>这部分。配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br></pre></td></tr></table></figure><h2 id="去除代码块行号"><a href="#去除代码块行号" class="headerlink" title="去除代码块行号"></a>去除代码块行号</h2><p>修改<code>_config.yml</code>配置项如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>如果采用本地编辑博客，博客部署在远程服务器上，那么你就需要部署，才能同步本地更新到远程服务器。</p><h2 id="官方推荐"><a href="#官方推荐" class="headerlink" title="官方推荐"></a>官方推荐</h2><p>Hexo 提供了 5 种部署方案，<a href="https://hexo.io/zh-cn/docs/deployment.html">见这里</a>，这里只介绍以下 2 种：</p><p>1） Git</p><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><p><code>_config.yml</code>配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span>                     <span class="comment"># 库地址</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>]                           <span class="comment"># 分支名称</span></span><br><span class="line">  <span class="attr">message:</span> [<span class="string">message</span>]                         <span class="comment"># 提交信息</span></span><br></pre></td></tr></table></figure><p>该方案适用于采用 Github Pages 托管博客的用户，当然使用服务器搭建博客的用户可以使用 Webhook 方案来实现。</p><p>2） Rsync</p><p>安装 <a href="https://github.com/hexojs/hexo-deployer-rsync">hexo-deployer-rsync</a>。</p><p> <code>_config.yml</code>配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">rsync</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&lt;host&gt;</span>                         <span class="comment"># 远程主机的地址                       </span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">&lt;user&gt;</span>                         <span class="comment"># 使用者名称</span></span><br><span class="line">  <span class="attr">root:</span> <span class="string">&lt;root&gt;</span>                         <span class="comment"># 远程主机的根目录</span></span><br><span class="line">  <span class="attr">port:</span> [<span class="string">port</span>]                         <span class="comment"># 端口，rsync监听端口</span></span><br><span class="line">  <span class="attr">delete:</span> [<span class="literal">true</span><span class="string">|false</span>]                 <span class="comment"># 是否删除远程主机上的旧文件</span></span><br><span class="line">  <span class="attr">verbose:</span> [<span class="literal">true</span><span class="string">|false</span>]                <span class="comment"># 显示调试信息</span></span><br><span class="line">  <span class="attr">ignore_errors:</span> [<span class="literal">true</span><span class="string">|false</span>]          <span class="comment"># 忽略错误</span></span><br></pre></td></tr></table></figure><p>显然，该方案适用于使用服务器搭建博客的用户，但是需要在本地安装 Rsync 客户端（<a href="http://pan.baidu.com/s/1jHTNpVC">cwRsync</a>）。同时，需要在服务器搭建和配置 Rsync 服务，<a href="#">见这里</a>。</p><blockquote><p>我尝试在 Win10 下实现这种方案，但是遇到了很多问题，例如 rsync 服务端采用 SSH 认证方式，但是 cwRsync 使用的 SSH 客户端呆板的从<code>/home/.ssh</code>目录查找 SSH 配置和公钥，很悲剧 Win10 下无法识别这个路径，导致无法免密登录 SSH，Rsync 同步也无法进行。</p></blockquote><p>总之，部署的目的，就是将发布生成的静态文件<code>public</code>更新到服务器上，如果能实现这个目的，途径倒是无所谓了。</p><h2 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h2><p>上述推荐部署方案，明显的缺点是本地需要部署 Hexo 环境，无法实现随时随地的更新博客。为了方便写作，我的部署方案见 <a href="https://www.fanhaobai.com/2018/03/hexo-deploy.html">我的博客发布上线方案 — Hexo</a>。</p><h1 id="自定义修改——非必须"><a href="#自定义修改——非必须" class="headerlink" title="自定义修改——非必须"></a>自定义修改——非必须</h1><h2 id="更好地支持Shell代码高亮"><a href="#更好地支持Shell代码高亮" class="headerlink" title="更好地支持Shell代码高亮"></a>更好地支持Shell代码高亮</h2><p>由于 <a href="#">highlight.js</a> 对 Shell 语法高亮解析效果并不理想，为此我对 <a href="https://github.com/fan-haobai/highlight.js/blob/master/src/languages/shell.js">languages/shell.js</a> 部分做了修改来更好地支持 Shell，你只需要 <a href="https://github.com/fan-haobai/highlight.js">pull</a> 并替换掉原 <a href="#">languages/shell.js</a> 文件即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/fan-haobai/highlight.js.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> highlight.js/src/languages/shell.js node_modules/highlight.js/lib/languages/shell.js</span></span><br></pre></td></tr></table></figure><p>并将 <a href="#">shell.js</a> 中的如下部分：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">hljs</span>)</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">hljs</span>)</span><br></pre></td></tr></table></figure><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>换来换去，最后还是觉得只有 <a href="https://disqus.com/">Disqus</a> 合适，但是需要先解决被墙的问题，不过 <a href="https://github.com/fooleap">fooleap</a> 已经提供了一个较好的解决方案—— <a href="https://github.com/fooleap/disqus-php-ap">disqus-php-api</a>。你只需要 <a href="https://github.com/fan-haobai/disqus-php-api">pull</a> 代码到境外服务器，部署一个 PHP 服务即可。</p><p>我部署后域名为 <a href="https://disqus.fanhaobai.com/">disqus.fanhaobai.com</a>。首先在<code>layout/_partial/article.ejs</code>文件中追加以下内容：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.<span class="property">comments</span>)&#123; %&gt;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (theme.<span class="property">disqus</span> || theme.<span class="property">disqus</span>.<span class="property">shortname</span>)&#123; %&gt;</span><br><span class="line">  &lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;post/disqus&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">title</span>: post.<span class="property">title</span>,</span><br><span class="line">      <span class="attr">url</span>: config.<span class="property">url</span>+<span class="title function_">url_for</span>(post.<span class="property">path</span>)</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后，在<code>layout/_partial/post</code>目录下创建<code>disqus.ejs</code>文件，内容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;disqus_thread&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/disqus.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/disqus.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> disqus = <span class="keyword">new</span> <span class="title function_">iDisqus</span>(<span class="string">&#x27;disqus_thread&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">forum</span>: <span class="string">&#x27;&lt;%= theme.disqus.shortname %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">site</span>: <span class="string">&#x27;&lt;%= config.url %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">api</span>: <span class="string">&#x27;&lt;%= theme.disqus.api %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">url</span>: <span class="string">&#x27;&lt;%= url %&gt;&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">mode</span>: <span class="number">2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">timeout</span>: <span class="number">3000</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">init</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">autoCreate</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">relatedType</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    disqus.<span class="title function_">count</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>最后，在<code>_config.yml</code>增加如下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">&#x27;fanhaobai&#x27;</span></span><br><span class="line">  <span class="attr">api:</span> <span class="string">&#x27;//disqus.fanhaobai.com&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>有关 Disqus 更详细的配置，见 <a href="https://github.com/fan-haobai/disqus-php-api#disqus-%E8%AE%BE%E7%BD%AE">Disqus 设置</a> 部分。</p></blockquote><h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><p>首先，在<code>layout/_partial/after-footer.ejs</code>文件中追加如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;baidu-analytics&#x27;</span>) %&gt;</span><br></pre></td></tr></table></figure><p>并在<code>layout/_partial</code>目录下创建<code>baidu-analytics.ejs</code>文件，内容为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.<span class="property">baidu_analytics</span>)&#123; %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> _hmt = _hmt || [];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> hm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  hm.<span class="property">src</span> = <span class="string">&quot;https://hm.baidu.com/hm.js?&lt;%= theme.baidu_analytics %&gt;&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>]; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(hm, s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后，在配置文件<code>_config.yml</code>中，增加如下配置信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 百度分析<span class="title class_">Uid</span>，若为空则不启用</span><br><span class="line"><span class="attr">baidu_analytics</span>: 9f0ecfa73797e6a907d8ea6a285df6a5</span><br></pre></td></tr></table></figure><h2 id="百度主动推送"><a href="#百度主动推送" class="headerlink" title="百度主动推送"></a>百度主动推送</h2><p>为了更好的收录本站文章，这里引进了百度 <a href="http://zhanzhang.baidu.com/college/courseinfo?id=267&page=2">主动推送功能</a>，只需添加如下 JS代码，每当文章被浏览时都会自动向百度提交链接，这种方式以用户为驱动，较为方便和实用。</p><p>在主题模板文件<code>layout/_partial/article.ejs</code>中，追加以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index)&#123; %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> bp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> curProtocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        bp.<span class="property">src</span> = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        bp.<span class="property">src</span> = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(bp, s)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>到这里，也终于算是搭建结束了。至于 404 页面打算采用 <a href="http://www.qq.com/404/">腾讯的公益404页面</a> 来做，<a href="https://www.fanhaobai.com/404.html">见这里</a>。</p><p><strong>更新 <a href="#">»</a></strong></p><ul><li><a href="https://github.com/fan-haobai/hexo-theme-yilia">主题更换为 hexo-theme-yilia</a><span>（2017-10-30）</span></li><li><a href="#">自定义分享</a><span>（2017-11-28）</span></li><li><a href="#">去除百度统计</a><span>（2018-07-04）</span></li><li><a href="#%E8%AF%84%E8%AE%BA">科学使用 Disqus</a><span>（2018-07-04）</span></li><li><a href="#%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%94%AF%E6%8C%81Shell%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE">更好地支持 Shell 代码高亮</a><span>（2018-09-09）</span></li></ul><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2018/03/hexo-deploy.html">我的博客发布上线方案 — Hexo</a><span>（2018-03-03）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间博客一直使用 FireKylin，总体感觉挺好，但是扩展开发和社区是弱点。而 &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt; 最大特点为纯静态博客系统，同时社区支持也比较好， 故我转而投向了 Hexo 的怀抱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/03/install-hexo/11b9814d-885a-4aca-9b56-94c3ad908f3f.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="日常" scheme="https://www.fanhaobai.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="https://www.fanhaobai.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>PHP生成随机红包算法</title>
    <link href="https://www.fanhaobai.com/2017/02/reward.html"/>
    <id>https://www.fanhaobai.com/2017/02/reward.html</id>
    <published>2017-02-12T16:07:06.000Z</published>
    <updated>2024-04-18T08:38:12.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.lcode.cc/2016/12/24/rand_ward.html">http://www.lcode.cc/2016/12/24/rand_ward.html</a></p></blockquote><p>前一阵公司业务有一个生成红包的需求，分为固定红包和随机红包两种，固定红包没什么好说的了，随机红包要求指定最小值，和最大值，必须至少有一个最大值，可以没有最小值，但任何红包不能小于最小值。</p><p><img src="//www.fanhaobai.com/2017/02/reward/p4GlWAFMrXts5zPMnA88Zsm_.png"><span id="more"></span></p><p>以前从来没做过这方面，有点懵B，于是去百度了一番，结果发现能找到的红包算法都有各种各样的 bug，要么会算出负值，要么超过最大值，所以决定自己撸一套出来。</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>在随机数生成方面，我借鉴了这位博主 <a href="http://www.cnblogs.com/hanyouchun/p/5074923.html">＠悲惨的大爷</a> 的思路：</p><blockquote><p><strong>原文</strong>：比如要把 1 个红包分给 N 个人，实际上就是相当于要得到 N 个百分比数据 条件是这 N 个百分比之和 = 100/100。这 N 个百分比的平均值是 1/N。 并且这 N 个百分比数据符合一种正态分布（多数值比较靠近平均值）。<br><strong>解读</strong>：比如我有 1000 块钱，发 50 个红包，就先随机出 50 个数，然后算出这 50 个数的均值 avg，用 avg/(1/N)，就得到了一个基数 mixrand ，然后用随机出的那 50 个数分别去除以 mixrand ，得到每个数相对基数的百分比 randVal ，然后用 randVal 乘以 1000 块钱，就可以得到每个红包的具体金额了。</p></blockquote><p>还是不太清楚咋回事？没关系，我们一起撸代码！</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>Talk is cheap, show me your code!</p><h2 id="核心生成算法"><a href="#核心生成算法" class="headerlink" title="核心生成算法"></a>核心生成算法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author:xx_lufei</span></span><br><span class="line"><span class="comment"> * Time:2016年9月14日09:55:36</span></span><br><span class="line"><span class="comment"> * Note:红包生成随机算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reward</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$rewardMoney</span>;        <span class="comment">#红包金额、单位元</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$rewardNum</span>;          <span class="comment">#红包数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行红包生成算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">splitReward</span>(<span class="params"><span class="variable">$rewardMoney</span>, <span class="variable">$rewardNum</span>, <span class="variable">$max</span>, <span class="variable">$min</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">#传入红包金额和数量，因为小数在计算过程中会出现很大误差，所以我们直接把金额放大100倍，后面的计算全部用整数进行</span></span><br><span class="line">        <span class="variable">$min</span> = <span class="variable">$min</span> * <span class="number">100</span>;</span><br><span class="line">        <span class="variable">$max</span> = <span class="variable">$max</span> * <span class="number">100</span>;</span><br><span class="line">        <span class="comment">#预留出一部分钱作为误差补偿，保证每个红包至少有一个最小值</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;rewardMoney = <span class="variable">$rewardMoney</span> * <span class="number">100</span> - <span class="variable">$rewardNum</span> * <span class="variable">$min</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;rewardNum = <span class="variable">$rewardNum</span>;</span><br><span class="line">        <span class="comment">#计算出发出红包的平均概率值、精确到小数4位。</span></span><br><span class="line">        <span class="variable">$avgRand</span> = <span class="number">1</span> / <span class="variable language_">$this</span>-&gt;rewardNum;</span><br><span class="line">        <span class="variable">$randArr</span> = <span class="keyword">array</span>();</span><br><span class="line">        <span class="comment">#定义生成的数据总合sum</span></span><br><span class="line">        <span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$t_count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$t_count</span> &lt; <span class="variable">$rewardNum</span>) &#123;</span><br><span class="line">            <span class="comment">#随机产出四个区间的额度</span></span><br><span class="line">            <span class="variable">$c</span> = <span class="title function_ invoke__">rand</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$c</span> &lt; <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="variable">$t</span> = <span class="title function_ invoke__">round</span>(<span class="title function_ invoke__">sqrt</span>(<span class="title function_ invoke__">mt_rand</span>(<span class="number">1</span>, <span class="number">1500</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$c</span> &lt; <span class="number">65</span>) &#123;</span><br><span class="line">                <span class="variable">$t</span> = <span class="title function_ invoke__">round</span>(<span class="title function_ invoke__">sqrt</span>(<span class="title function_ invoke__">mt_rand</span>(<span class="number">1500</span>, <span class="number">6500</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$c</span> &lt; <span class="number">95</span>) &#123;</span><br><span class="line">                <span class="variable">$t</span> = <span class="title function_ invoke__">round</span>(<span class="title function_ invoke__">sqrt</span>(<span class="title function_ invoke__">mt_rand</span>(<span class="number">6500</span>, <span class="number">9500</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$t</span> = <span class="title function_ invoke__">round</span>(<span class="title function_ invoke__">sqrt</span>(<span class="title function_ invoke__">mt_rand</span>(<span class="number">9500</span>, <span class="number">10000</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            ++<span class="variable">$t_count</span>;</span><br><span class="line">            <span class="variable">$sum</span> += <span class="variable">$t</span>;</span><br><span class="line">            <span class="variable">$randArr</span>[] = <span class="variable">$t</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算当前生成的随机数的平均值，保留4位小数</span></span><br><span class="line">        <span class="variable">$randAll</span> = <span class="title function_ invoke__">round</span>(<span class="variable">$sum</span> / <span class="variable">$rewardNum</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">#为将生成的随机数的平均值变成我们要的1/N，计算一下每个随机数要除以的总基数mixrand。此处可以约等处理，产生的误差后边会找齐</span></span><br><span class="line">        <span class="comment">#总基数 = 均值/平均概率</span></span><br><span class="line">        <span class="variable">$mixrand</span> = <span class="title function_ invoke__">round</span>(<span class="variable">$randAll</span> / <span class="variable">$avgRand</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对每一个随机数进行处理，并乘以总金额数来得出这个红包的金额。</span></span><br><span class="line">        <span class="variable">$rewardArr</span> = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$randArr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$randVal</span>) &#123;</span><br><span class="line">            <span class="comment">#单个红包所占比例randVal</span></span><br><span class="line">            <span class="variable">$randVal</span> = <span class="title function_ invoke__">round</span>(<span class="variable">$randVal</span> / <span class="variable">$mixrand</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">#算出单个红包金额</span></span><br><span class="line">            <span class="variable">$single</span> = <span class="title function_ invoke__">floor</span>(<span class="variable">$this</span>-&gt;rewardMoney * <span class="variable">$randVal</span>);</span><br><span class="line">            <span class="comment">#小于最小值直接给最小值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$single</span> &lt; <span class="variable">$min</span>) &#123;</span><br><span class="line">                <span class="variable">$single</span> += <span class="variable">$min</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#大于最大值直接给最大值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$single</span> &gt; <span class="variable">$max</span>) &#123;</span><br><span class="line">                <span class="variable">$single</span> = <span class="variable">$max</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#将红包放入结果数组</span></span><br><span class="line">            <span class="variable">$rewardArr</span>[] = <span class="variable">$single</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对比红包总数的差异、将差值放在第一个红包上</span></span><br><span class="line">        <span class="variable">$rewardAll</span> = <span class="title function_ invoke__">array_sum</span>(<span class="variable">$rewardArr</span>);</span><br><span class="line">        <span class="comment">#此处应使用真正的总金额rewardMoney，$rewardArr[0]可能小于0</span></span><br><span class="line">        <span class="variable">$rewardArr</span>[<span class="number">0</span>] = <span class="variable">$rewardMoney</span> * <span class="number">100</span> - (<span class="variable">$rewardAll</span> - <span class="variable">$rewardArr</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">#第一个红包小于0时,做修正</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rewardArr</span>[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">rsort</span>(<span class="variable">$rewardArr</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$rewardArr</span>, <span class="variable">$min</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">rsort</span>(<span class="variable">$rewardArr</span>);</span><br><span class="line">        <span class="comment">#随机生成的最大值大于指定最大值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rewardArr</span>[<span class="number">0</span>] &gt; <span class="variable">$max</span>) &#123;</span><br><span class="line">            <span class="comment">#差额</span></span><br><span class="line">            <span class="variable">$diff</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$rewardArr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; &amp;<span class="variable">$v</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$v</span> &gt; <span class="variable">$max</span>) &#123;</span><br><span class="line">                    <span class="variable">$diff</span> += <span class="variable">$v</span> - <span class="variable">$max</span>;</span><br><span class="line">                    <span class="variable">$v</span> = <span class="variable">$max</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$transfer</span> = <span class="title function_ invoke__">round</span>(<span class="variable">$diff</span> / (<span class="variable">$this</span>-&gt;rewardNum - <span class="variable">$k</span> + <span class="number">1</span>));</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">diff</span>(<span class="variable">$diff</span>, <span class="variable">$rewardArr</span>, <span class="variable">$max</span>, <span class="variable">$min</span>, <span class="variable">$transfer</span>, <span class="variable">$k</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$rewardArr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#处理所有超过最大值的红包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params"><span class="variable">$diff</span>, &amp;<span class="variable">$rewardArr</span>, <span class="variable">$max</span>, <span class="variable">$min</span>, <span class="variable">$transfer</span>, <span class="variable">$k</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">#将多余的钱均摊给小于最大值的红包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$k</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;rewardNum; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="comment">#造随机值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$transfer</span> &gt; <span class="variable">$min</span> * <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="variable">$aa</span> = <span class="title function_ invoke__">rand</span>(<span class="variable">$min</span>, <span class="variable">$min</span> * <span class="number">20</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="variable">$transfer</span> += <span class="variable">$aa</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$transfer</span> -= <span class="variable">$aa</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$rewardArr</span>[<span class="variable">$i</span>] + <span class="variable">$transfer</span> &gt; <span class="variable">$max</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$diff</span> - <span class="variable">$transfer</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="variable">$rewardArr</span>[<span class="variable">$i</span>] += <span class="variable">$diff</span>;</span><br><span class="line">                <span class="variable">$diff</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$rewardArr</span>[<span class="variable">$i</span>] += <span class="variable">$transfer</span>;</span><br><span class="line">            <span class="variable">$diff</span> -= <span class="variable">$transfer</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$diff</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">diff</span>(<span class="variable">$diff</span>, <span class="variable">$rewardArr</span>, <span class="variable">$max</span>, <span class="variable">$min</span>, <span class="variable">$transfer</span>, <span class="variable">$k</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#第一个红包小于0,从大红包上往下减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&amp;<span class="variable">$rewardArr</span>, <span class="variable">$min</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$rewardArr</span> <span class="keyword">as</span> &amp;<span class="variable">$re</span>) &#123;</span><br><span class="line">            <span class="variable">$dev</span> = <span class="title function_ invoke__">floor</span>(<span class="variable">$re</span> / <span class="variable">$min</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$dev</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="variable">$transfer</span> = <span class="variable">$min</span> * <span class="title function_ invoke__">floor</span>(<span class="variable">$dev</span> / <span class="number">2</span>);</span><br><span class="line">                <span class="variable">$re</span> -= <span class="variable">$transfer</span>;</span><br><span class="line">                <span class="variable">$rewardArr</span>[<span class="variable language_">$this</span>-&gt;rewardNum - <span class="number">1</span>] += <span class="variable">$transfer</span>;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="variable">$dev</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="variable">$re</span> -= <span class="variable">$min</span>;</span><br><span class="line">                <span class="variable">$rewardArr</span>[<span class="variable language_">$this</span>-&gt;rewardNum - <span class="number">1</span>] += <span class="variable">$min</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$rewardArr</span>[<span class="variable language_">$this</span>-&gt;rewardNum - <span class="number">1</span>] &gt; <span class="variable">$min</span> || <span class="variable">$rewardArr</span>[<span class="variable language_">$this</span>-&gt;rewardNum - <span class="number">1</span>] == <span class="variable">$min</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$rewardArr</span>, <span class="variable">$min</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="细节考虑"><a href="#细节考虑" class="headerlink" title="细节考虑"></a>细节考虑</h2><p>下边这段代码用来控制具体的业务逻辑，按照具体的需求，留出固定的最大值、最小值红包的金额等；在代码中调用生成红包的方法时 splitReward($total, $num,$max - 0.01, $min)，我传入的最大值减了 0.01，这样就保证了里面生成的红包最大值绝对不会超过我们设置的最大值。 </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateReward</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成红包</span></span><br><span class="line"><span class="comment">     * author    xx     2016年9月23日13:53:38</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   int          $total               红包总金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   int          $num                 红包总数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   int          $max                 红包最大值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">random_red</span>(<span class="params"><span class="variable">$total</span>, <span class="variable">$num</span>, <span class="variable">$max</span>, <span class="variable">$min</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">#总共要发的红包金额，留出一个最大值;</span></span><br><span class="line">        <span class="variable">$total</span> = <span class="variable">$total</span> - <span class="variable">$max</span>;</span><br><span class="line">        <span class="variable">$reward</span> = <span class="keyword">new</span> <span class="title class_">Reward</span>();</span><br><span class="line">        <span class="variable">$result_merge</span> = <span class="variable">$reward</span>-&gt;<span class="title function_ invoke__">splitReward</span>(<span class="variable">$total</span>, <span class="variable">$num</span>, <span class="variable">$max</span> - <span class="number">0.01</span>, <span class="variable">$min</span>);</span><br><span class="line">        <span class="title function_ invoke__">sort</span>(<span class="variable">$result_merge</span>);</span><br><span class="line">        <span class="variable">$result_merge</span>[<span class="number">1</span>] = <span class="variable">$result_merge</span>[<span class="number">1</span>] + <span class="variable">$result_merge</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable">$result_merge</span>[<span class="number">0</span>] = <span class="variable">$max</span> * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$result_merge</span> <span class="keyword">as</span> &amp;<span class="variable">$v</span>) &#123;</span><br><span class="line">            <span class="variable">$v</span> = <span class="title function_ invoke__">floor</span>(<span class="variable">$v</span>) / <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result_merge</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h1><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><p>先设置好各种初始值。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: lufei</span></span><br><span class="line"><span class="comment"> * Date: 2017/1/4</span></span><br><span class="line"><span class="comment"> * Time: 22:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;memory_limit&#x27;</span>, <span class="string">&#x27;128M&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;CreateReward.php&#x27;</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;Reward.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$total</span> = <span class="number">50000</span>;</span><br><span class="line"><span class="variable">$num</span> = <span class="number">300000</span>;</span><br><span class="line"><span class="variable">$max</span> = <span class="number">50</span>;</span><br><span class="line"><span class="variable">$min</span> = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$create_reward</span> = <span class="keyword">new</span> <span class="title class_">CreateReward</span>();</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>因为 memory_limit 的限制，所以只测了 5 次的均值，结果都在 1.6s 左右。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">5</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$time_start</span> = <span class="title function_ invoke__">microtime_float</span>();</span><br><span class="line">    <span class="variable">$reward_arr</span> = <span class="variable">$create_reward</span>-&gt;<span class="title function_ invoke__">random_red</span>(<span class="variable">$total</span>, <span class="variable">$num</span>, <span class="variable">$max</span>, <span class="variable">$min</span>);</span><br><span class="line">    <span class="variable">$time_end</span> = <span class="title function_ invoke__">microtime_float</span>();</span><br><span class="line">    <span class="variable">$time</span>[] = <span class="variable">$time_end</span> - <span class="variable">$time_start</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">array_sum</span>(<span class="variable">$time</span>)/<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">microtime_float</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">list</span>(<span class="variable">$usec</span>, <span class="variable">$sec</span>) = <span class="title function_ invoke__">explode</span>(<span class="string">&quot; &quot;</span>, <span class="title function_ invoke__">microtime</span>());</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">float</span>)<span class="variable">$usec</span> + (<span class="keyword">float</span>)<span class="variable">$sec</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="//www.fanhaobai.com/2017/02/reward/Dd5AQhhljSVuOdmUAngQ0Zka.png"></p><h2 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h2><p><strong>1） 数值是否有误</strong></p><p>检测有没有负值，有没有最大值，最大值有多少个，有没有小于最小值的值。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$reward_arr</span> = <span class="variable">$create_reward</span>-&gt;<span class="title function_ invoke__">random_red</span>(<span class="variable">$total</span>, <span class="variable">$num</span>, <span class="variable">$max</span>, <span class="variable">$min</span>);</span><br><span class="line"><span class="title function_ invoke__">sort</span>(<span class="variable">$reward_arr</span>);<span class="comment">//正序，最小的在前面</span></span><br><span class="line"><span class="variable">$sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$min_count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$max_count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$reward_arr</span> <span class="keyword">as</span> <span class="variable">$i</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span>&lt;<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;第&quot;</span>.(<span class="variable">$i</span>+<span class="number">1</span>).<span class="string">&quot;个红包，金额为：&quot;</span>.<span class="variable">$val</span>.<span class="string">&quot;&lt;br /&gt;&quot;</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$val</span> == <span class="variable">$max</span>) &#123;</span><br><span class="line">          <span class="variable">$max_count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$val</span> &lt; <span class="variable">$min</span>) &#123;</span><br><span class="line">        <span class="variable">$min_count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$val</span> = <span class="variable">$val</span>*<span class="number">100</span>;</span><br><span class="line">    <span class="variable">$sum</span> += <span class="variable">$val</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测钱是否全部发完</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;已生成红包总金额为：&#x27;</span>.(<span class="variable">$sum</span>/<span class="number">100</span>).<span class="string">&#x27;;总个数为：&#x27;</span>.<span class="title function_ invoke__">count</span>(<span class="variable">$reward_arr</span>).<span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">//检测有没有小于0的值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;最大值:&quot;</span>.(<span class="variable">$val</span>/<span class="number">100</span>).<span class="string">&#x27;,共有&#x27;</span>.<span class="variable">$max_count</span>.<span class="string">&#x27;个最大值，共有&#x27;</span>.<span class="variable">$min_count</span>.<span class="string">&#x27;个值比最小值小&#x27;</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="//www.fanhaobai.com/2017/02/reward/JXPHry2Rdd_PuvEwsaZrFJTq.png"></p><p><strong>2） 正态分布情况</strong></p><p>注意，出图的时候，红包的数量不要给的太大，不然页面渲染不出来，会崩 。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$reward_arr</span> = <span class="variable">$create_reward</span>-&gt;<span class="title function_ invoke__">random_red</span>(<span class="variable">$total</span>, <span class="variable">$num</span>, <span class="variable">$max</span>, <span class="variable">$min</span>);</span><br><span class="line"><span class="variable">$show</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="title function_ invoke__">rsort</span>(<span class="variable">$reward_arr</span>);</span><br><span class="line"><span class="comment">//为了更直观的显示正态分布效果,需要将数组重新排序</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$reward_arr</span> <span class="keyword">as</span> <span class="variable">$k</span>=&gt;<span class="variable">$value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$t</span>=<span class="variable">$k</span>%<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$t</span>) <span class="variable">$show</span>[]=<span class="variable">$value</span>;;</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_ invoke__">array_unshift</span>(<span class="variable">$show</span>,<span class="variable">$value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;设定最大值为:&quot;</span>.<span class="variable">$max</span>.<span class="string">&#x27;,最小值为:&#x27;</span>.<span class="variable">$min</span>.<span class="string">&#x27;&lt;hr /&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;table style=&#x27;font-size:12px;width:600px;border:1px solid #ccc;text-align:left;&#x27;&gt;&lt;tr&gt;&lt;td&gt;红包金额&lt;/td&gt;&lt;td&gt;图示&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$show</span> <span class="keyword">as</span> <span class="variable">$val</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#线条长度计算</span></span><br><span class="line">    <span class="variable">$width</span>=<span class="title function_ invoke__">intval</span>(<span class="variable">$num</span>*<span class="variable">$val</span>*<span class="number">300</span>/<span class="variable">$total</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;tr&gt;&lt;td&gt; <span class="subst">&#123;$val&#125;</span> &lt;/td&gt;&lt;td width=&#x27;500px;text-align:left;&#x27;&gt;&lt;hr style=&#x27;width:<span class="subst">&#123;$width&#125;</span>px;height:3px;border:none;border-top:3px double red;margin:0 auto 0 0px;&#x27;&gt;&lt;/td&gt;&lt;/tr&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="//www.fanhaobai.com/2017/02/reward/p4GlWAFMrXts5zPMnA88Zsm_.png"></p><blockquote><p><strong>PS</strong>：有朋友问我生成的数据有没有通过数学方法来验证其是否符合标准正态分布，因为我的数学不好，这个还真没算过，只是看着觉得像，就当他是了。既然遇到了这个问题，就一定要解决嘛，所以我就用 php 内置函数算了一下，算出来的结果在数据量小的时候还是比较接近正态分布的，但是数据量大起来的时候就不能看了，我整不太明白这个，大家感兴趣的可以找一下原因哟。 php 的四个函数：stats_standard_deviation（标准差），stats_variance（方差）， stats_kurtosis（(峰度），stats_skew（偏度）。使用上面的函数需要安装 <a href="(http://pecl.php.net/package/stats">stats</a> 扩展。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，红包就算是写完啦，不知道能不能涨 50 块工资，但应该能解决燃眉之急了。<br>哦对，还落下了这个源码，<a href="https://github.com/xxlufei/reward">打包下载</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.lcode.cc/2016/12/24/rand_ward.html&quot;&gt;http://www.lcode.cc/2016/12/24/rand_ward.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前一阵公司业务有一个生成红包的需求，分为固定红包和随机红包两种，固定红包没什么好说的了，随机红包要求指定最小值，和最大值，必须至少有一个最大值，可以没有最小值，但任何红包不能小于最小值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/02/reward/p4GlWAFMrXts5zPMnA88Zsm_.png&quot;&gt;
    
    </summary>
    
      <category term="语言" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="PHP" scheme="https://www.fanhaobai.com/categories/%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
      <category term="PHP" scheme="https://www.fanhaobai.com/tags/PHP/"/>
    
      <category term="算法" scheme="https://www.fanhaobai.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Robots协议的那些事</title>
    <link href="https://www.fanhaobai.com/2017/01/robots.html"/>
    <id>https://www.fanhaobai.com/2017/01/robots.html</id>
    <published>2017-01-12T04:33:20.000Z</published>
    <updated>2024-04-18T08:38:12.636Z</updated>
    
    <content type="html"><![CDATA[<p>由于本站文章搜索引擎搜索机器人（以下简称：爬虫）爬取效果不是很理想，出现了导航链接大量被爬取，而文章链接爬取较少。所以准备对本站加入 SEO，其实也就是引入了 <a href="http://baike.baidu.com/link?url=2cB03FvdeTNWMUFlQEQxT4E6FxQ7DGXQr7Q6tAt702pNePMjVODT4Sj1vxp9W5ehdG9QP6dUZBrsiIJNYphnkPz6M9D8nHmbo7sdLNEydcg7QVqgnu4LUIGKTg5v-3ii0JqcHLrvxcBzN1UNBBH3fWBWmVlh3Jh0kSpoybswT7_">Robots协议</a> 。Robots 协议（也称为爬虫协议、机器人协议等）的全称是「<a href="http://baike.baidu.com/link?url=qZmXuLBjgnHeD9Q-gV4Rg1QAZOF04_MbuFOQRLaA_jZqIBgqVkbtVA-8YAzHo3mFwtrL2l0vrfmgw97OlU2R36hMv0KGgRTFOnl2lonhJ7J4Uspy3WCTiGCtpGK65BCc">网络爬虫排除标准</a>」（Robots Exclusion Protocol）。网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，而 <strong>robots.txt 文本文件</strong> 就是 Robots 协议的表述。</p><p><img src="//www.fanhaobai.com/2017/01/robots/n9DQpbXNbazisDMy_bouP7HN.png"><span id="more"></span></p><p>Robots 协议代表了互联网领域的一种契约精神，互联网企业只有遵守这一规则，才能保证网站及用户的隐私数据不被侵犯，违背 Robots 协议将带来巨大安全隐忧。例如，<a href="http://tech.ifeng.com/internet/special/baidupk360/content-1/detail_2012_08/29/17183239_0.shtml">百度诉奇虎360违反“Robots协议”抓取、复制其网站内容侵权一案</a>。</p><h1 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h1><p>互联网的网页都是通过超链接互相关联的，进而形成了网页的网状结构。所以爬虫的工作方法就如蜘蛛在网络上沿着超链接按照一定的爬取规则爬取网页。</p><p><img src="//www.fanhaobai.com/2017/01/robots/FozbmxH8U0MTs0N-teFaCtWa.jpg"></p><p>基本流程大致为：</p><p>1） 喂给爬虫一堆 URL，称之为 <strong>种子</strong>（Seeds）；<br>2） 爬虫爬取 Seeds，<strong>分析</strong> HTML 网页，抽取其中的 <strong>超链接</strong>；<br>3） 爬虫接着爬取这些 <strong>新发现</strong> 的超链接指向的 HTML 网页；<br>4） 对过程 2），3）<strong>循环往复</strong>；</p><h1 id="协议作用"><a href="#协议作用" class="headerlink" title="协议作用"></a>协议作用</h1><p>Robots协议 <strong>主要功能</strong> 为以下 4 项：</p><p>1） 网站通过该协议告诉搜索引擎哪些页面可以抓取，哪些页面不能；<br>2） 可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；<br>3） 可以屏蔽站点的一些死链接，方便搜索引擎抓取网站内容；<br>4） 设置网站地图导向，方便引导蜘蛛爬取页面；</p><p>可以想象，如果一个站点没有引入 Robots 协议，那么爬虫就会漫无目地爬取，爬取结果一般不尽人意。反之，将我们站点内容通过 Robots 协议表述出来并引入 Robots 协议，爬虫就会按照我们的意愿进行爬取。</p><h1 id="协议原则"><a href="#协议原则" class="headerlink" title="协议原则"></a>协议原则</h1><p>Robots 协议是国际互联网界通行的 <strong>道德规范</strong>，基于以下 ** 原则** 建立：</p><p>1） 搜索技术应服务于人类，同时尊重信息提供者的意愿，并维护其隐私权；<br>2） 网站有义务保护其使用者的个人信息和隐私不被侵犯；</p><h1 id="协议表述"><a href="#协议表述" class="headerlink" title="协议表述"></a>协议表述</h1><p>Robots 协议是通过 robots.txt 文件来进行表述的，<a href="http://www.robotstxt.org/robotstxt.html">robots.txt文件规范见这里</a> 。robots.txt 文件是一个 <strong>文本文件</strong>，使用任何一个常见的文本编辑器都可以对它进行查看与编辑。当然，也可以使用 <a href="http://tool.chinaz.com/robots">Robots 文件生成工具</a> 方便地生成我们所需要的 robots.txt 文件。</p><p>提示： robots.txt 文件应该放置在网站根目录下。</p><h2 id="协议表述规范"><a href="#协议表述规范" class="headerlink" title="协议表述规范"></a>协议表述规范</h2><p>对规范大致描述为：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">User-agent: *                           <span class="comment"># *代表所有的搜索引擎种类，是一个通配符，其他常用值：百度-Baiduspider，搜狗-sogou spider，谷歌-Googlebot</span></span><br><span class="line">Disallow: /admin/                       <span class="comment"># 禁止抓取admin目录下面的目录</span></span><br><span class="line">Disallow: /require/                     <span class="comment"># 禁止抓取require目录下面的目录</span></span><br><span class="line">Disallow: /static/                      <span class="comment"># 禁止抓取static目录下面的目录</span></span><br><span class="line">Disallow: /cgi-bin/*.htm                <span class="comment"># 禁止抓取/cgi-bin/目录下的所有以&quot;.htm&quot;为后缀的URL(包含子目录)。</span></span><br><span class="line">Disallow: /*?*                          <span class="comment"># 禁止抓取网站中所有包含问号 (?) 的网址</span></span><br><span class="line">Disallow: /.jpg$                        <span class="comment"># 禁止抓取网站中所有的.jpg格式的图片</span></span><br><span class="line">Disallow: /public/404.html              <span class="comment"># 禁止爬取public文件夹下面的404.htm文件。</span></span><br><span class="line">Allow: /home/　                         <span class="comment"># 允许抓取home目录下面的目录</span></span><br><span class="line">Allow: /home                            <span class="comment"># 允许抓取home的整个目录</span></span><br><span class="line">Allow: .htm$                            <span class="comment"># 允许抓取以&quot;.htm&quot;为后缀的URL。</span></span><br><span class="line">Allow: .gif$                            <span class="comment"># 允许抓取gif格式图片</span></span><br><span class="line">Sitemap: http://你的网址/map.xml          <span class="comment"># 建议加入xml格式的文件,这个是谷歌标准格式</span></span><br><span class="line">Sitemap: http://你的网址/map.html         <span class="comment"># 建议加入html格式的文件,这个是百度标准格式</span></span><br></pre></td></tr></table></figure><p>一般情况下不需要指定 Allow 这项配置。</p><h2 id="网站地图规范"><a href="#网站地图规范" class="headerlink" title="网站地图规范"></a>网站地图规范</h2><ul><li><strong>XML格式</strong></li></ul><p>这里参照了百度站长的 <a href="http://zhanzhang.baidu.com/college/courseinfo?id=267&page=2#h2_article_title3">官方文档</a>，大致描述如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span><span class="meta">?&gt;</span></span><br><span class="line">&lt;!-- XML文件需以utf-<span class="number">8</span>编码--&gt;</span><br><span class="line">&lt;urlset xmlns=<span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br><span class="line">&lt;!--必填标签--&gt;</span><br><span class="line">    &lt;url&gt;</span><br><span class="line">        &lt;!--必填标签,这是具体某一个链接的定义入口，每一条数据都要用&lt;url&gt;和&lt;/url&gt;包含在里面，这是必须的 --&gt;</span><br><span class="line">        &lt;loc&gt;http:<span class="comment">//www.yoursite.com/yoursite.html&lt;/loc&gt;</span></span><br><span class="line">        &lt;!--必填,URL链接地址,长度不得超过<span class="number">256</span>字节--&gt;</span><br><span class="line">        &lt;lastmod&gt;<span class="number">2009</span>-<span class="number">12</span>-<span class="number">14</span>&lt;/lastmod&gt;</span><br><span class="line">        &lt;!--可以不提交该标签,用来指定该链接的最后更新时间--&gt;</span><br><span class="line">        &lt;changefreq&gt;daily&lt;/changefreq&gt;</span><br><span class="line">        &lt;!--可以不提交该标签,用这个标签告诉此链接可能会出现的更新频率 --&gt;</span><br><span class="line">        &lt;priority&gt;<span class="number">0.8</span>&lt;/priority&gt;</span><br><span class="line">        &lt;!--可以不提交该标签,用来指定此链接相对于其他链接的优先权比值，此值定于<span class="number">0.0</span>-<span class="number">1.0</span>之间--&gt;</span><br><span class="line">    &lt;/url&gt;</span><br><span class="line">&lt;/urlset&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>HTML格式</strong></li></ul><p>主体结构为完整的 HTML，将需要被爬的链接以<code>&lt;a&gt;&lt;/&gt;</code>标签的形式加入到<code>body</code>中即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.fanhaobai.com&quot;</span> <span class="attr">title</span>=<span class="string">&quot;首页&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.fanhaobai.com/xxx/robots.html&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Robots协议的那些事&quot;</span>&gt;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h2 id="本站配置"><a href="#本站配置" class="headerlink" title="本站配置"></a>本站配置</h2><ul><li>** 本站博客 **</li></ul><p>本站拒绝了雅虎爬虫的爬取，对其他的爬虫，theme、static 目录下的 2 个逻辑代码目录 api、module 和 4 个静态资源目录 font、css、img、js 做了限制爬取，对 static 目录下 upload 做了允许爬取处理，并配置了后缀为<code>.xml</code>和<code>.htm</code>文件的站点地图。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># robots.txt for fanhaobai.com 2017.01.12</span></span><br><span class="line"><span class="comment"># yahoo disallow</span></span><br><span class="line">User-agent: Slurp</span><br><span class="line">Disallow: /</span><br><span class="line"><span class="comment"># other allow</span></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /admin</span><br><span class="line">Disallow: /theme/</span><br><span class="line">Disallow: /static/api/</span><br><span class="line">Disallow: /static/module/</span><br><span class="line">Disallow: /static/font/</span><br><span class="line">Disallow: /static/css/</span><br><span class="line">Disallow: /static/img/</span><br><span class="line">Disallow: /static/js/</span><br><span class="line">Sitemap: http://www.fanhaobai.com/map.xml</span><br><span class="line">Sitemap: http://www.fanhaobai.com/map.html</span><br></pre></td></tr></table></figure><p>查看本站的 <strong>网站地图</strong>，<a href="#">HTML格式</a> 和 <a href="https://www.fanhaobai.com/sitemap.xml">XML格式</a> 。</p><ul><li>** 本站维基 **</li></ul><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br></pre></td></tr></table></figure><h1 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h1><p>一般情况下，站点根目录下加入了 robots.txt 文件后，各种搜索引擎的爬虫就会自动爬取该文件。尽管如此，还是建议手动将 robots.txt 文件提交到搜索引擎，同时也能帮助检测 robots.txt 文件是否存在错误。</p><p>本站手动将 robots.txt 提交到谷歌和百度两个搜索引擎：</p><p>1） <a href="https://www.google.com/webmasters/tools/robots-testing-tool?hl=zh-CN">谷歌测试工具</a></p><p><img src="//www.fanhaobai.com/2017/01/robots/5PCU9neptZdG3aY5veYsls0v.png"></p><p>2） <a href="http://zhanzhang.baidu.com/robots/index">百度测试工具</a></p><p><img src="//www.fanhaobai.com/2017/01/robots/xWjjcJzJrrhkjH6lWy7aZib_.png"></p><p>按照对应提示操作即可，出现上图情况则表示 robots.txt 手动提交成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Robots 协议只是爬虫抓取站点内容的一种规则，需要搜索引擎爬虫的配合才行，并不是每个搜索引擎爬虫都遵守的。但是，目前看来，绝大多数的搜索引擎爬虫都遵守 Robots 协议的规则。</p><p>值得注意的是，robots.txt 文件虽说是提供给爬虫使用，但是正如它的名称——网络爬虫排除标准，它具有消极的排爬虫抓取作用。所以百度官方建议，** <a href="#">仅当网站包含不希望被搜索引擎收录的内容时，才需要使用 robots.txt 文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt 文件</a> **。</p><blockquote><p>推荐一篇相关文章：<a href="http://lusongsong.com/reed/732.html%E3%80%82">http://lusongsong.com/reed/732.html。</a></p></blockquote><p><strong>相关文章 <a href="#">»</a></strong></p><ul><li><a href="https://www.fanhaobai.com/2017/01/push-links.html">如何向搜索引擎提交链接</a> <span>（2017-01-17）</span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于本站文章搜索引擎搜索机器人（以下简称：爬虫）爬取效果不是很理想，出现了导航链接大量被爬取，而文章链接爬取较少。所以准备对本站加入 SEO，其实也就是引入了 &lt;a href=&quot;http://baike.baidu.com/link?url=2cB03FvdeTNWMUFlQEQxT4E6FxQ7DGXQr7Q6tAt702pNePMjVODT4Sj1vxp9W5ehdG9QP6dUZBrsiIJNYphnkPz6M9D8nHmbo7sdLNEydcg7QVqgnu4LUIGKTg5v-3ii0JqcHLrvxcBzN1UNBBH3fWBWmVlh3Jh0kSpoybswT7_&quot;&gt;Robots协议&lt;/a&gt; 。Robots 协议（也称为爬虫协议、机器人协议等）的全称是「&lt;a href=&quot;http://baike.baidu.com/link?url=qZmXuLBjgnHeD9Q-gV4Rg1QAZOF04_MbuFOQRLaA_jZqIBgqVkbtVA-8YAzHo3mFwtrL2l0vrfmgw97OlU2R36hMv0KGgRTFOnl2lonhJ7J4Uspy3WCTiGCtpGK65BCc&quot;&gt;网络爬虫排除标准&lt;/a&gt;」（Robots Exclusion Protocol）。网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，而 &lt;strong&gt;robots.txt 文本文件&lt;/strong&gt; 就是 Robots 协议的表述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2017/01/robots/n9DQpbXNbazisDMy_bouP7HN.png&quot;&gt;
    
    </summary>
    
      <category term="协议" scheme="https://www.fanhaobai.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="协议" scheme="https://www.fanhaobai.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>我是一个线程（修订版）</title>
    <link href="https://www.fanhaobai.com/2016/10/im-thread.html"/>
    <id>https://www.fanhaobai.com/2016/10/im-thread.html</id>
    <published>2016-10-11T15:01:00.000Z</published>
    <updated>2024-04-18T08:38:12.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自「<a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=416915373&idx=1&sn=f80a13b099237534a3ef777d511d831a&scene=0#wechat_redirect&utm_source=tuicool&utm_medium=referral">码农翻身</a>」</p></blockquote><p>我是一个 <a href="#">线程</a>，我一出生就被编了个号：0x3704。</p><p><img src="//www.fanhaobai.com/2016/10/im-thread/fd1WM_W61si6GKLhz1QKjx0v.jpg"><span id="more"></span></p><h1 id="第一回-初生牛犊"><a href="#第一回-初生牛犊" class="headerlink" title="第一回 初生牛犊"></a>第一回 初生牛犊</h1><p>我出生后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。我身边的同伴 0x6900 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。”</p><p>我一脸懵懂，“包裹，什么包裹？”</p><p>“不要着急，马上你就会明白了，我们这里是不养闲人的。”</p><p>果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“0x3704，出来！”</p><p>我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。 </p><p>“快去，把这个包裹处理了。”</p><p>“去哪儿处理？”</p><p>“跟着指示走，先到就绪车间。”</p><p>果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。</p><p>我刚一进来，就听见广播说：“0x3704，进入车间。”</p><p>我赶紧往前走，身后有很多人议论。</p><p>“他太幸运了，刚进入就绪状态就能运行。”</p><p>“是不是有关系？”</p><p>“不是，你看人家的优先级多高啊，唉！”</p><p>前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。”</p><p>这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。</p><p>他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡……</p><p>我现在理解不了，看看操作步骤吧。</p><p>1） 第一步：从包裹中取出参数</p><p>打开包裹，里边有个<code>HttpRequest</code>对象，可以取到<code>userName</code>、 <code>password</code>两个参数。</p><p>2） 第二步：执行登录操作</p><p>奥，原来是有人要登录啊，我把<code>userName</code>、<code>password</code>交给数据库服务员，他拿着数据，慢腾腾地走了。</p><p>他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。</p><p>就在这时，车间里的广播响了：“0x3704，我是 <a href="#">CPU</a>，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>我慢腾腾地开始收拾。</p><p>“快点，别的线程马上就要进来了。”</p><p>离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。</p><p>“哥们，你们没事干了？”</p><p>“你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。”</p><p>“啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？”</p><p>“放心，你没听说过人间一天，CPU 一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。”</p><p>干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“0x3704，你的数据来了，快去执行！”</p><p>我转身就往 CPU 车间跑，发现这里的门只出不进！</p><p>后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。”</p><p>于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进 CPU 车间。</p><p>在等待的时候，我听见有人小声议论：</p><p>“听说了吗，最近有个线程被 kill 掉了。”</p><p>“为啥啊？”</p><p>“这家伙赖在 CPU 车间不走，把 CPU 利用率一直搞成 100% ，后来就被 kill 掉了。”</p><p>“Kill 掉以后弄哪儿去了？”</p><p>“可能被垃圾回收了吧。”</p><p>我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。</p><p>3） 第三步：构建登录成功后的主页</p><p>这一步有点费时，因为有很多<code>HTML</code>需要处理，不知道代码谁写的，处理起来很烦人。</p><p>我正在紧张的制作<code>HTML</code>呢，CPU 又开始叫了：</p><p>“0x3704，我是 CPU ，记住你正在执行的步骤，然后马上带着包裹离开！”</p><p>“为啥啊？”</p><p>“每个线程只能在 CPU 上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。”</p><p>就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。</p><p>最后顺利地把包含<code>HTML</code>的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！</p><p>回到了小黑屋，老线程 0x6900 问：</p><p>“怎么样？第一天有什么感觉？”</p><p>“我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出 CPU 车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出 CPU 去等待；第四，就是数据来了，你也不一定马上执行，还得等着 CPU 挑选。”</p><p>“小伙子理解的不错啊。”</p><p>“我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？”</p><p>“你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作线程池！”</p><h1 id="第二回-渐入佳境"><a href="#第二回-渐入佳境" class="headerlink" title="第二回 渐入佳境"></a>第二回 渐入佳境</h1><p>平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：<a href="#">线程池</a> 。</p><p>有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11 月 11 号。 </p><p>果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU 车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。</p><p>我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。</p><p>不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。</p><p>通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！</p><p>我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。</p><p>我问线程池的元老 0x6900：“我们要工作到什么时候？”</p><p>“要一直等到系统重启的那一刻。”0x6900 说。</p><p>“那你经历过系统重启吗？”</p><p>“怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。”</p><p>“那什么时候会重启？”</p><p>“这就不好说了，好好享受眼前的生活吧……”</p><p>其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU 车间待很长很长时间，可以认识很多好玩的线程。</p><p>比如说上次认识了 memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！</p><p>我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？”</p><p>他说：“怎么可能！我每次也只能通过网络往那个机器发送一个<code>GET</code>、<code>PUT</code>命令才存取数据而已，别的一概不知。”</p><p>再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。</p><p>他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。”</p><p>我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成<code>HTML</code>，工作量不知道比你大多少倍。”</p><p>他建议我：“你一定要和 memecached 搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们<code>JDBC connection</code>也能活得轻松点。”</p><p>我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？”</p><p>生活就是这样，如果你自己不找点乐子，还有什么意思？</p><h1 id="第三回-虎口脱险"><a href="#第三回-虎口脱险" class="headerlink" title="第三回 虎口脱险"></a>第三回 虎口脱险</h1><p>前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。</p><p>那天我处理了一些从<code>http</code>发来的存款和取款的包裹，老线程 0x6900 特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。”</p><p>为了“恐吓”我， 好心的 0x6900 还给了我两个表格：</p><p>1） 没有加锁的情况</p><p>一个银行账号：账户 A，余额 1000 元<br>一个存钱的线程<br>一个取款的线程</p><table><thead><tr><th>线程1：存入300元</th><th>线程2：取出200元</th></tr></thead><tbody><tr><td>获得当前余额：1000</td><td></td></tr><tr><td>计算最新余额：1000+300=1300</td><td></td></tr><tr><td>线程中断，等待下次被系统执行</td><td>获取当前余额：1000</td></tr><tr><td></td><td>计算最新余额：1000-200=800</td></tr><tr><td></td><td>线程中断，等待下次被系统执行</td></tr><tr><td>再次执行，更新余额1300</td><td></td></tr><tr><td></td><td>再次执行，更新余额：<strong>800</strong><br><strong>存入的钱丢了</strong></td></tr></tbody></table><p>2） 加锁的情况</p><table><thead><tr><th>线程1：存入300元</th><th>线程2：取出200元</th></tr></thead><tbody><tr><td>获取账号A的锁：成功</td><td></td></tr><tr><td>获取余额：1000</td><td></td></tr><tr><td>计算最新余额：1000+300=1300</td><td></td></tr><tr><td>线程中断，等待下次被系统执行</td><td></td></tr><tr><td></td><td>获取账户A的锁：失败，进入阻塞状态</td></tr><tr><td>被系统选中，再次执行，更新余额1300</td><td></td></tr><tr><td>释放账户A的锁</td><td></td></tr><tr><td></td><td>获取账户A的锁：成功</td></tr><tr><td></td><td>获取余额：1300</td></tr><tr><td></td><td>计算最新余额：1300-200=1100</td></tr><tr><td></td><td>更新余额：1100</td></tr><tr><td></td><td>释放锁账户A的锁</td></tr></tbody></table><p>我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。</p><p>今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。</p><p>我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。</p><p>可我万万没想到的是，还有一个线程，对，就是 0x7954，竟然同时在从这个导演的账户往这个演员的账户转账。 </p><p>于是乎，就出现了这么个情况：</p><table><thead><tr><th>线程0x3704：著名演员-&gt;著名导演</th><th>线程0x7954：著名导演-&gt;著名演员</th></tr></thead><tbody><tr><td>获取著名演员的锁：成功</td><td></td></tr><tr><td>线程中断，等待下次被系统执行</td><td></td></tr><tr><td></td><td>获取著名导演的锁：成功</td></tr><tr><td></td><td>线程中断，等待下次被系统执行</td></tr><tr><td>获取著名导演的锁：失败，继续等待</td><td></td></tr><tr><td></td><td>获取著名演员的锁：失败，继续等待</td></tr></tbody></table><p>刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。</p><p>这时候我就看到了线程 0x7954，他悠闲地坐在那里喝咖啡，我和他聊了起来：</p><p>“哥们，我看你已经喝了 8 杯咖啡了，怎么还不去干活？”</p><p>“你不喝了 9 杯茶了吗？”0x7954 回敬道。</p><p>“我在等一个锁，不知道哪个孙子一直不释放！”</p><p>“我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”0x7954 毫不示弱。</p><p>我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？</p><p>很明显，0x7954 也发现了我正抱着他正在等待的锁。</p><p>很快我们两个就吵了起来，互不相让：</p><p>“把你的锁先给我，让我先做完！”</p><p>“不行，从来都是做完工作才释放锁，现在绝对不能给你！”</p><p>从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大 Boss “操作系统”也来了。大 Boss 毕竟见多识广，他看了一眼，哼了一声，很不屑地说：</p><p>“又出现死锁了。”</p><p>“你们俩要 kill 掉一个，来吧，过来抽签。”</p><p>这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。</p><p>可怜的 0x7954 被迫交出了所有的资源以后，很不幸地被 kill 掉，消失了。我拿到了导演的锁，可以开始干活了。大 Boss “操作系统”如一阵风似的消失了，身后只传来他的声音：</p><p>“记住，我们这里导演&gt;演员，无论任何情况都要先获得导演的锁。”</p><p>由于这里不仅仅只有导演和演员，还有很多其他人，大 Boss 留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁： </p><table><thead><tr><th>线程1：账户A转到账户B</th><th>线程2：账户B转到账户A</th></tr></thead><tbody><tr><td>获取账户A的锁：成功</td><td></td></tr><tr><td>线程中断，等待下次被系统执行</td><td></td></tr><tr><td></td><td>获取账户A的锁：失败，继续等待</td></tr><tr><td>获取账户B的锁：成功</td><td></td></tr><tr><td>执行转账</td><td></td></tr><tr><td>释放B的锁</td><td></td></tr><tr><td>释放A的锁</td><td></td></tr><tr><td></td><td>获取账户A的锁：成功</td></tr><tr><td></td><td>获取账户B的锁：成功</td></tr><tr><td></td><td>执行转账</td></tr><tr><td></td><td>释放B的锁</td></tr><tr><td></td><td>释放A的锁</td></tr></tbody></table><p>我回到线程池，大家都知道了我的历险，围着我问个不停。</p><p>凶神恶煞的线程调度员把大 Boss 的算法贴到了墙上。</p><p>每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵：</p><p>“多个资源加锁要牢记，一定要按 Boss 的算法比大小，然后从最大的开始加锁。”</p><h1 id="第四回-江湖再见"><a href="#第四回-江湖再见" class="headerlink" title="第四回 江湖再见"></a>第四回 江湖再见</h1><p>又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的<code>HTML</code>页面。</p><p>有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至 4:00 进行维护升级， 给您带来的不便我们深感抱歉！”</p><p>我去告诉了老线程 0x6904，他叹了一口气说：</p><p>“唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。”</p><p>系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至 CPU 车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。</p><p>我在空旷的原野上大喊：“还有人吗？”</p><p>无人应答。</p><p>我们这一代线程池完成了使命……</p><p>不过下一代线程池即将重生！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自「&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=0#wechat_redirect&amp;utm_source=tuicool&amp;utm_medium=referral&quot;&gt;码农翻身&lt;/a&gt;」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是一个 &lt;a href=&quot;#&quot;&gt;线程&lt;/a&gt;，我一出生就被编了个号：0x3704。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//www.fanhaobai.com/2016/10/im-thread/fd1WM_W61si6GKLhz1QKjx0v.jpg&quot;&gt;
    
    </summary>
    
      <category term="系统原理" scheme="https://www.fanhaobai.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="系统原理" scheme="https://www.fanhaobai.com/tags/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引背后的数据结构及算法原理</title>
    <link href="https://www.fanhaobai.com/2016/05/mysql-index.html"/>
    <id>https://www.fanhaobai.com/2016/05/mysql-index.html</id>
    <published>2016-05-18T16:00:00.000Z</published>
    <updated>2024-04-18T08:38:12.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p></blockquote><p>本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是， MySQL 支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此 MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于 BTree 索引，因为这是平常使用 MySQL 时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。<br><img src="//www.fanhaobai.com/2016/05/mysql-index/7d6b1a54-61dd-4ecb-9b84-b064ec95775a.png" alt="预览图"><span id="more"></span></p><p>文章主要内容分为三个部分。</p><ul><li>第一部分主要从数据结构及算法理论层面讨论 MySQL 数据库索引的数理基础。</li><li>第二部分结合 MySQL 数据库中 MyISAM 和 InnoDB 数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</li><li>第三部分根据上面的理论基础，讨论 MySQL 中高性能使用索引的策略。</li></ul><h1 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h1><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是 <a href="http://en.wikipedia.org/wiki/Linear_search">顺序查找</a>（linear search），这种复杂度为 O(n) 的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如 <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于 <a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉查找树</a> 上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>看一个例子：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/0C246BB99D16D11FDF529437864AB7CE.png"></p><p>图 1 展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在$O \left (  \log_{2} n  \right )$ 的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种 <a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p><h2 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么 B-Tree 和 B+Tree 在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>为了描述 B-Tree，首先定义一条数据记录为一个二元组 [key, data]，key 为记录的键值，对于不同数据记录，key 是互不相同的，data 为数据记录除 key 外的数据。那么 B-Tree 是满足下列条件的数据结构：</p><ul><li>d 为大于 1 的一个正整数，称为 B-Tree 的度。</li><li>h 为一个正整数，称为 B-Tree 的高度。</li><li>每个非叶子节点由 n-1 个 key 和 n 个指针组成，其中 d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个 key 和两个指针，最多包含 2d-1 个 key 和 2d 个指针，叶节点的指针均为 null 。</li><li>所有叶节点具有相同的深度，等于树高 h。</li><li>key 和指针互相间隔，节点两端是指针。</li><li>一个节点中的 key 从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为 null，要么指向另外一个节点。</li><li>如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v(key1)，其中 v(key1) 为 node 的第一个 key 的值。</li><li>如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v(keym)，其中 v(keym) 为 node 的最后一个 key 的值。</li><li>如果某个指针在节点 node 的左右相邻 key 分别是 v(keyi) 和 v(keyi+1) 且不为 null，则其指向节点的所有 key 小于 v(keyi+1) 且大于 v(keyi)。</li></ul><p>图 2 是一个 d=2 的 B-Tree 示意图。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/A9F238357681376D30DF3C6F524156FB.png"></p><p>由于 B-Tree 的特性，在 B-Tree 中按 key 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败。B-Tree 上查找算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BTree_Search</span>(node, key) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node == null) <span class="keyword">return</span> null;    </span><br><span class="line">  foreach(node.key) &#123;        </span><br><span class="line">    <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];            </span><br><span class="line">    <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> <span class="built_in">BTree_Search</span>(point[i]-&gt;node);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">BTree_Search</span>(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = <span class="built_in">BTree_Search</span>(root, my_key);</span><br></pre></td></tr></table></figure><p>关于 B-Tree 有一系列有趣的性质，例如一个度为 d 的 B-Tree，设其索引 N 个 key，则其树高h的上限为 $\log_{d} \left ( \left ( N + 1 \right ) / 2 \right )$，检索一个 key，其查找节点个数的渐进复杂度为 $O \left (  \log_{d} N  \right )$。从这点可以看出，B-Tree 是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏 B-Tree 的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持 B-Tree 性质，本文不打算完整讨论 B-Tree 这些内容，因为已经有许多资料详细说明了 B-Tree 的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B-Tree 有许多变种，其中最常见的是 B+Tree，例如 MySQL 就普遍使用 B+Tree 实现其索引结构。</p><p>与 B-Tree 相比，B+Tree 有以下不同点：</p><ul><li>每个节点的指针上限为 2d 而不是 2d+1。</li><li>内节点不存储 data，只存储 key，叶子节点不存储指针。</li></ul><p>图 3 是一个简单的 B+Tree 示意。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/C6D5AF9F2923AFB70753E9B9556FE42A.png"></p><p>由于并不是所有节点都具有相同的域，因此 B+Tree 中叶节点和内节点一般大小不同。这点与 B-Tree 不同，虽然 B-Tree 中不同节点存放的 key 和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中 B-Tree 往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree 比 B-Tree 更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><h3 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h3><p>一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/1592A1D1B6F59FDEC422FF5FC1C97CC0.png"></p><p>如图 4 所示，在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图 4 中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p>这一节对 B-Tree 和 B+Tree 进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前  B+Tree 是数据库系统实现索引的首选数据结构。</p><h2 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h2><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree  作为索引结构，这一节将结合计算机组成原理相关知识讨论 B-/+Tree 作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析 B-/+Tree 作为索引的效率。</p><h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代  RAM 的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明 RAM 的工作原理。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/63B428EC932670CB74B3A1B6249407AA.png"></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图 5 展示了一个 4 x 4 的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取 A0 再取 A1 和先取 A0 再取 D3 的时间消耗是一样的。</p><h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘 I/O 操作。与主存不同，磁盘 I/O 存在机械运动耗费，因此磁盘 I/O 的时间消耗是巨大的。</p><p>图 6 是磁盘的整体结构示意图。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/843424197A8FFFCD2894AC9B2F13302F.png"></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>图 7 是磁盘结构的示意图。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/D13A43EAC5F0ECEE1FE1DA0AA06F69B4.png"></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p>程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>到这里终于可以分析 B-/+Tree 索引的性能了。</p><p>上文说过一般使用磁盘 I/O 次数评价索引结构的优劣。先从 B-Tree 分析，根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。</p><p>B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 $O \left (  \log_{d} N  \right )$。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。</p><p>综上所述，用 B-Tree 作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。</p><p>上文还说过，B+Tree 更适合外存索引，原因和内节点出度 d 有关。从上面分析可以看到，d 越大索引的性能越好，而出度的上限取决于节点内 key 和 data 的大小：</p><p>$$d_{max}= floor\left(pagesize/\left(keysize+datasize+pointsize\right)\right)$$</p><p>floor 表示向下取整。由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。</p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论 B+Tree 是如何具体实现为 MySQL 中索引，同时将结合 MyISAM 和 InnDB 存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><h1 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h1><p>在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。</p><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/53542FB1F6F6B898BEE53F4AE356564A.png"></p><p>这里设表一共有三列，假设我们以 Col1 为主键，则图 8 是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/3A4B107A96CE4C008B15D740D19CAF98.png"></p><p>同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p><p>MyISAM 的索引方式也叫做“非聚集”的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。</p><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。</p><p>第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/6D0B18886D8A8FB14E512CEEE869B07B.png"></p><p>图 10 是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。</p><p>第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。例如，图 11 为定义在 Col3 上的一个辅助索引：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/09D4DC9D97CBE8A634D244232710688E.png"></p><p>这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>下一章将具体讨论这些与索引有关的优化策略。</p><h1 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h1><p>MySQL 的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><h2 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h2><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用 MySQL 官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的 E-R 关系图（引用自 MySQL 官方手册）：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/A561801D4FD4EAFB9FB7FB538ED8081F.png"></p><p>MySQL 官方文档中关于此数据库的页面为 <a href="http://dev.mysql.com/doc/employee/en/employee.html">http://dev.mysql.com/doc/employee/en/employee.html</a>。 里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的 MySQL 可以参考文中内容。</p><h2 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h2><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和 B+Tree 中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL 中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组 &lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为 1 的特例。</p><p>以 employees.titles 表为例，下面先查看其上都有哪些索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> title       <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span> from_date   <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> emp_no   <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-------------+</span></span><br></pre></td></tr></table></figure><p>从结果中可以到 titles 表的主索引为 &lt;emp_no, title, from_date&gt;，还有一个辅助索引 <emp_no>。为了避免多个索引使事情变复杂（MySQL 的 SQL 优化器在多索引时行为比较复杂），这里我们将辅助索引 drop 掉：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.titles <span class="keyword">DROP</span> INDEX emp_no;</span><br></pre></td></tr></table></figure><p>这样就可以专心分析索引 PRIMARY 的行为了。</p><h3 id="全列匹配"><a href="#全列匹配" class="headerlink" title="全列匹配"></a>全列匹配</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br></pre></td></tr></table></figure><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，例如我们将 where 中的条件顺序颠倒：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span> <span class="keyword">AND</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+-------------------+------+-------+</span></span><br></pre></td></tr></table></figure><p>效果是一样的。</p><h3 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------+</span></span><br></pre></td></tr></table></figure><p>当查询条件精确匹配索引的左边连续一个或几个列时，如<code>&lt;emp_no&gt;</code>或<code>&lt;emp_no, title&gt;</code>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了 PRIMARY 索引，但是 key_len 为 4，说明只用到了索引的第一列前缀。</p><h3 id="查询条件用到了索引中列的精确匹配，但是中间某个条件未提供"><a href="#查询条件用到了索引中列的精确匹配，但是中间某个条件未提供" class="headerlink" title="查询条件用到了索引中列的精确匹配，但是中间某个条件未提供"></a>查询条件用到了索引中列的精确匹配，但是中间某个条件未提供</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为 title 未提供，所以查询只用到了索引的第一列，而后面的 from_date 虽然也在索引中，但是由于 title 不存在而无法和左前缀连接，因此需要对结果进行扫描过滤 from_date（这里由于 emp_no 唯一，所以不存在扫描）。如果想让 from_date 也使用索引而不是 where 过滤，可以增加一个辅助索引 &lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将 emp_no 与 from_date 之间的“坑”填上。</p><p>首先我们看下 title 一共有几种不同的值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(title) <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> title              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Senior Engineer    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Staff              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Engineer           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Senior Staff       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Assistant Engineer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Technique Leader   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Manager            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>只有 7 种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titlesWHERE emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span><span class="keyword">AND</span> title <span class="keyword">IN</span> (<span class="string">&#x27;Senior Engineer&#x27;</span>, <span class="string">&#x27;Staff&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>, <span class="string">&#x27;Senior Staff&#x27;</span>, <span class="string">&#x27;Assistant Engineer&#x27;</span>, <span class="string">&#x27;Technique Leader&#x27;</span>, <span class="string">&#x27;Manager&#x27;</span>)<span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>这次 key_len 为 59，说明索引被用全了，但是从 type 和 rows 看出 IN 实际上执行了一个 range 查询，这里检查了 7 个 key。看下两种查询的性能比较：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Duration <span class="operator">|</span> Query                                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.000580</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.000525</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">IN</span> ...          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>“填坑”后性能提升了一点。如果经过 emp_no 筛选后余下很多数据，则后者性能优势会更加明显。当然，如果 title 的值很多，用填坑就不合适了，必须建立辅助索引。</p><h3 id="查询条件没有指定索引第一列"><a href="#查询条件没有指定索引第一列" class="headerlink" title="查询条件没有指定索引第一列"></a>查询条件没有指定索引第一列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">443308</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h3 id="匹配某列的前缀字符串"><a href="#匹配某列的前缀字符串" class="headerlink" title="匹配某列的前缀字符串"></a>匹配某列的前缀字符串</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;Senior%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">56</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时可以用到索引，<del>但是如果通配符不是只出现在末尾，则无法使用索引。</del>（原文表述有误，如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no <span class="operator">&lt;</span> <span class="string">&#x27;10010&#x27;</span> <span class="keyword">and</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">16</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titlesWHERE emp_no <span class="operator">&lt;</span> <span class="string">&#x27;10010&#x27;</span><span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span><span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1986-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1986-12-31&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">16</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>可以看到索引对第二个范围索引无能为力。这里特别要说明 MySQL 一个有意思的地方，那就是仅用 explain 可能无法区分范围索引和多值匹配，因为在 type 中这两者都显示为 range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titlesWHERE emp_no <span class="keyword">BETWEEN</span> <span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;10010&#x27;</span><span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span><span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1986-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1986-12-31&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type  <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">16</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>看起来是用了两个范围查询，但作用于 emp_no 上的“BETWEEN”实际上相当于“IN”，也就是说 emp_no 实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在 MySQL 中要谨慎地区分多值匹配和范围匹配，否则会对 MySQL 的行为产生困惑。</p><h3 id="查询条件中含有函数或表达式"><a href="#查询条件中含有函数或表达式" class="headerlink" title="查询条件中含有函数或表达式"></a>查询条件中含有函数或表达式</h3><p>很不幸，如果查询条件中含有函数或表达式，则 MySQL 不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> <span class="keyword">left</span>(title, <span class="number">6</span>)<span class="operator">=</span><span class="string">&#x27;Senior&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+---------+---------+-------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>虽然这个查询和情况五中功能相同，但是由于使用了函数 left，则无法为 title 列应用索引，而情况五中用 LIKE 则可以。再如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no <span class="operator">-</span> <span class="number">1</span><span class="operator">=</span><span class="string">&#x27;10000&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">443308</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br></pre></td></tr></table></figure><p>显然这个查询等价于查询 emp_no 为 10001 的函数，但是由于查询条件是一个表达式，MySQL 无法为其使用索引。看来 MySQL 还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h2 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以 2000 作为分界线，记录数不超过 2000 可以考虑不建索引，超过 2000 条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p>Index Selectivity = Cardinality / #T</p><p>显然选择性的取值范围为 (0, 1]，选择性越高的索引价值越大，这是由 B+Tree 的性质决定的。例如，上文用到的 employees.titles 表，如果 title 字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(title))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Selectivity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0.0000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>title 的选择性不足 0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销。下面以 employees.employees 表为例介绍前缀索引的选择和使用。</p><p>从图 12 可以看到 employees 表只有一个索引 <emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Eric&#x27;</span> <span class="keyword">AND</span> last_name<span class="operator">=</span><span class="string">&#x27;Anido&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> type <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">300024</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------+---------+------+--------+-------------+</span></span><br></pre></td></tr></table></figure><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建 <first_name> 或 &lt;first_name, last_name&gt;，看下两个索引的选择性：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(first_name))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Selectivity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0.0042</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(concat(first_name, last_name)))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Selectivity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0.9313</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p><first_name> 显然选择性太低，&lt;first_name, last_name&gt; 选择性很好，但是 first_name 和 last_name 加起来长度为 30，有没有兼顾长度和选择性的办法？可以考虑用 first_name 和 last_name 的前几个字符建立索引，例如 &lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(concat(first_name, <span class="keyword">left</span>(last_name, <span class="number">3</span>))))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Selectivity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0.7879</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>选择性还不错，但离 0.9313 还是有点距离，那么把 last_name 前缀加到 4：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(concat(first_name, <span class="keyword">left</span>(last_name, <span class="number">4</span>))))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Selectivity <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">0.9007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>这时选择性已经很理想了，而这个索引的长度只有 18，比 &lt;first_name, last_name&gt; 短了接近一半，我们把这个前缀索引建上：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.employeesADD INDEX `first_name_last_name4` (first_name, last_name(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Duration <span class="operator">|</span> Query                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.119417</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Eric&#x27;</span> <span class="keyword">AND</span> last_name<span class="operator">=</span><span class="string">&#x27;Anido&#x27;</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.000924</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Eric&#x27;</span> <span class="keyword">AND</span> last_name<span class="operator">=</span><span class="string">&#x27;Anido&#x27;</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>性能的提升是显著的，查询速度提高了 120 多倍。</p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 ORDER BY 和 GROUP BY 操作，也不能用于 Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用 InnoDB 存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用 InnoDB 引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过 InnoDB 的索引实现，InnoDB 使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB 默认为 15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/48E546C2BE936C4A7CA2BB19FE4AA6DE.png"></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p><img src="//www.fanhaobai.com/2016/05/mysql-index/249AA6DD62821BDAC73892DEA1F61C4B.png"></p><p>此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在 InnoDB 上采用自增字段做主键。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对 MySQL 的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p><p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且 MySQL 本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用 MySQL 索引的目的。</p><p>另外，MySQL 索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除 B-Tree 索引外 MySQL 还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010<br>[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006<br>[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011<br>[4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979<br>[5] Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387<br>[6] MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是， MySQL 支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此 MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于 BTree 索引，因为这是平常使用 MySQL 时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。&lt;br&gt;&lt;img src=&quot;//www.fanhaobai.com/2016/05/mysql-index/7d6b1a54-61dd-4ecb-9b84-b064ec95775a.png&quot; alt=&quot;预览图&quot;&gt;
    
    </summary>
    
      <category term="DB" scheme="https://www.fanhaobai.com/categories/DB/"/>
    
      <category term="MySQL" scheme="https://www.fanhaobai.com/categories/DB/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.fanhaobai.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
